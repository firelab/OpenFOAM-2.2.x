--- extra/scotch/src/Make.inc/Makefile.inc.linux	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/Make.inc/Makefile.inc.linux	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,21 @@
+EXE		=
+LIB		= .so
+OBJ		= .o
+
+MAKE		= make
+AR		= gcc
+ARFLAGS		= -shared -o
+CAT		= cat
+CCS		= gcc
+CCP		= mpicc
+CCD		= gcc
+CFLAGS		= -O3 -DCOMMON_FILE_COMPRESS_GZ -DCOMMON_RANDOM_FIXED_SEED -DSCOTCH_RENAME -Drestrict=__restrict
+CLIBFLAGS	= -shared -fPIC
+LDFLAGS		= -lz -lm -lrt
+CP		= cp
+LEX		= flex -Pscotchyy -olex.yy.c
+LN		= ln
+MKDIR		= mkdir
+MV		= mv
+RANLIB		= echo
+YACC		= bison -pscotchyy -y -b y
--- extra/scotch/src/Make.inc/Makefile.inc.mingw-w64	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/Make.inc/Makefile.inc.mingw-w64	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,23 @@
+EXE	=
+#MJ LIB	= .a
+LIB	= .dll
+OBJ	= .o
+
+MAKE	= make
+AR	= x86_64-w64-mingw32-gcc  
+
+CAT	= cat
+CC      = x86_64-w64-mingw32-gcc
+CCS	= x86_64-w64-mingw32-gcc
+CCP     = x86_64-w64-mingw32-gcc
+CCD     = 
+CFLAGS	= -O3 -m64 -Wall -DMSWIN -DNDEBUG -Drestrict=__restrict -DCOMMON_WINDOWS -DCOMMON_FILE_COMPRESS_GZ -DCOMMON_RANDOM_FIXED_SEED -DSCOTCH_RENAME -DCOMMON_RANDOM_RAND -DCOMMON_STUB_FORK -D'pipe(pfds)=_pipe(pfds,1024,0x8000)'
+LDFLAGS	= -lz
+ARFLAGS = $(CFLAGS) -shared -Wl,--output-def,libscotch.def,--out-implib,libscotch.a,--enable-auto-import,--strip-all -o
+CP	= cp 
+LEX	= flex
+LN	= ln
+MKDIR	= mkdir
+MV	= mv
+RANLIB	= echo
+YACC	= bison -pscotchyy -y -b y
--- extra/scotch/src/Make.inc/Makefile.inc.darwin	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/Make.inc/Makefile.inc.darwin	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,23 @@
+EXE	=
+#MJ LIB	= .a
+LIB	= .dylib
+OBJ	= .o
+
+MAKE	= make
+AR	= gcc
+
+CAT	= cat
+CCS	= gcc
+CC  = gcc
+CCP     = gcc
+CCD     = gcc
+CFLAGS	= -O3 -Drestrict=__restrict -DCOMMON_RANDOM_FIXED_SEED -DCOMMON_TIMING_OLD -DCOMMON_FILE_COMPRESS_GZ -DSCOTCH_RENAME
+LDFLAGS	= -lz -lm
+ARFLAGS	= $(CFLAGS) -dynamiclib -flat_namespace -undefined suppress -o
+CP	= cp
+LEX	= flex
+LN	= ln
+MKDIR	= mkdir
+MV	= mv
+RANLIB	= echo
+YACC	= bison -pscotchyy -y -b y
--- extra/scotch/src/libscotch/common.c	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/libscotch/common.c	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,116 @@
+/* Copyright 2004,2007 ENSEIRB, INRIA & CNRS
+**
+** This file is part of the Scotch software package for static mapping,
+** graph partitioning and sparse matrix ordering.
+**
+** This software is governed by the CeCILL-C license under French law
+** and abiding by the rules of distribution of free software. You can
+** use, modify and/or redistribute the software under the terms of the
+** CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
+** URL: "http://www.cecill.info".
+** 
+** As a counterpart to the access to the source code and rights to copy,
+** modify and redistribute granted by the license, users are provided
+** only with a limited warranty and the software's author, the holder of
+** the economic rights, and the successive licensors have only limited
+** liability.
+** 
+** In this respect, the user's attention is drawn to the risks associated
+** with loading, using, modifying and/or developing or reproducing the
+** software by the user in light of its specific status of free software,
+** that may mean that it is complicated to manipulate, and that also
+** therefore means that it is reserved for developers and experienced
+** professionals having in-depth computer knowledge. Users are therefore
+** encouraged to load and test the software's suitability as regards
+** their requirements in conditions enabling the security of their
+** systems and/or data to be ensured and, more generally, to use and
+** operate it in the same conditions as regards security.
+** 
+** The fact that you are presently reading this means that you have had
+** knowledge of the CeCILL-C license and that you accept its terms.
+*/
+/************************************************************/
+/**                                                        **/
+/**   NAME       : common.c                                **/
+/**                                                        **/
+/**   AUTHORS    : David GOUDIN                            **/
+/**                Pascal HENON                            **/
+/**                Francois PELLEGRINI                     **/
+/**                Pierre RAMET                            **/
+/**                                                        **/
+/**   FUNCTION   : Part of a parallel direct block solver. **/
+/**                These lines are common routines used    **/
+/**                by all modules.                         **/
+/**                                                        **/
+/**   DATES      : # Version 0.0  : from : 08 may 1998     **/
+/**                                 to     14 sep 1998     **/
+/**                # Version 2.0  : from : 27 sep 2004     **/
+/**                                 to     27 sep 2004     **/
+/**                                                        **/
+/************************************************************/
+
+/*
+**  The defines and includes.
+*/
+
+#define COMMON
+
+#include <time.h>
+#include "common.h"
+
+#ifdef MSWIN
+#include <sys/time.h>
+#endif
+
+/*******************/
+/*                 */
+/* Timing routine. */
+/*                 */
+/*******************/
+
+double
+clockGet (void)
+{
+#ifdef MPI_INT
+  return (MPI_Wtime ());
+#else /* MPI_INT */
+#ifdef MSWIN
+  struct timeval data;
+
+  gettimeofday(&data, NULL);
+
+  return (data.tv_sec + 1E-6*data.tv_usec);
+#elif defined(COMMON_TIMING_OLD)                          /* Old timing routine */
+  struct rusage       data;
+
+  getrusage (RUSAGE_SELF, &data);
+
+  return (((double) data.ru_utime.tv_sec  + (double) data.ru_stime.tv_sec) +
+          ((double) data.ru_utime.tv_usec + (double) data.ru_stime.tv_usec) * 1.0e-6L);
+#else /* COMMON_TIMING_OLD */
+  struct timespec     tp;
+
+  clock_gettime (CLOCK_REALTIME, &tp);            /* Elapsed time */
+
+  return ((double) tp.tv_sec + (double) tp.tv_nsec * 1.0e-9L);
+#endif /* COMMON_TIMING_OLD */
+#endif /* MPI_INT */
+}
+
+/***************************/
+/*                         */
+/* Usage printing routine. */
+/*                         */
+/***************************/
+
+void
+usagePrint (
+FILE * const                stream,
+const char ** const         data)
+{
+  const char **       cptr;
+
+  fprintf (stream, "Usage is:\n");
+  for (cptr = data; *cptr != NULL; cptr ++)
+    fprintf (stream, "  %s\n", *cptr);
+}
--- extra/scotch/src/libscotch/scotch.h	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/libscotch/scotch.h	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,332 @@
+/* Copyright 2004,2007-2010 ENSEIRB, INRIA & CNRS
+**
+** This file is part of the Scotch software package for static mapping,
+** graph partitioning and sparse matrix ordering.
+**
+** This software is governed by the CeCILL-C license under French law
+** and abiding by the rules of distribution of free software. You can
+** use, modify and/or redistribute the software under the terms of the
+** CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
+** URL: "http://www.cecill.info".
+** 
+** As a counterpart to the access to the source code and rights to copy,
+** modify and redistribute granted by the license, users are provided
+** only with a limited warranty and the software's author, the holder of
+** the economic rights, and the successive licensors have only limited
+** liability.
+** 
+** In this respect, the user's attention is drawn to the risks associated
+** with loading, using, modifying and/or developing or reproducing the
+** software by the user in light of its specific status of free software,
+** that may mean that it is complicated to manipulate, and that also
+** therefore means that it is reserved for developers and experienced
+** professionals having in-depth computer knowledge. Users are therefore
+** encouraged to load and test the software's suitability as regards
+** their requirements in conditions enabling the security of their
+** systems and/or data to be ensured and, more generally, to use and
+** operate it in the same conditions as regards security.
+** 
+** The fact that you are presently reading this means that you have had
+** knowledge of the CeCILL-C license and that you accept its terms.
+*/
+/************************************************************/
+/**                                                        **/
+/**   NAME       : ptscotch.h                              **/
+/**                                                        **/
+/**   AUTHOR     : Francois PELLEGRINI                     **/
+/**                                                        **/
+/**   FUNCTION   : Declaration file for the LibScotch      **/
+/**                static mapping and sparse matrix block  **/
+/**                ordering library.                       **/
+/**                                                        **/
+/**   DATES      : # Version 3.2  : from : 07 sep 1996     **/
+/**                                 to     22 aug 1998     **/
+/**                # Version 3.3  : from : 02 oct 1998     **/
+/**                                 to     31 may 1999     **/
+/**                # Version 3.4  : from : 10 oct 1999     **/
+/**                                 to     15 nov 2001     **/
+/**                # Version 4.0  : from : 11 dec 2001     **/
+/**                                 to     20 dec 2005     **/
+/**                # Version 5.0  : from : 26 apr 2006     **/
+/**                                 to   : 20 feb 2008     **/
+/**                # Version 5.1  : from : 30 nov 2007     **/
+/**                                 to   : 17 nov 2010     **/
+/**                                                        **/
+/************************************************************/
+
+/*
+**  The type and structure definitions.
+*/
+
+/*+ Version flags. +*/
+
+#define SCOTCH_VERSION 5
+#define SCOTCH_RELEASE 1
+#define SCOTCH_PATCHLEVEL 11
+
+/*+ Parallel processing flag. +*/
+
+#ifndef SCOTCH_PTSCOTCH
+#define SCOTCH_SEQSCOTCH
+#endif /* SCOTCH_PTSCOTCH */
+
+/** Need to check MSWIN for OpenFOAM build environment */
+#if defined(COMMON_WINDOWS) || defined(MSWIN)
+/* For int64_t definition */
+#include <stdint.h>
+#endif
+
+/*+ Integer type. +*/
+typedef int64_t SCOTCH_Idx;
+
+typedef int SCOTCH_Num;
+
+#define SCOTCH_NUMMAX               ((int) (((unsigned int) 1 << ((sizeof (int) << 3) - 1)) - 1))
+#define SCOTCH_NUMSTRING            "%d"
+
+/*+ Strategy string parametrization values +*/
+
+#define SCOTCH_STRATQUALITY         1
+#define SCOTCH_STRATSPEED           2
+#define SCOTCH_STRATBALANCE         4
+#define SCOTCH_STRATSAFETY          8
+#define SCOTCH_STRATSCALABILITY     16
+
+/*+ Opaque objects. The dummy sizes of these
+objects, computed at compile-time by program
+"dummysizes", are given as double values for
+proper padding                               +*/
+
+typedef struct {
+  double                    dummy[5];
+} SCOTCH_Arch;
+
+#ifdef SCOTCH_PTSCOTCH
+typedef struct {
+  double                    dummy[1];
+} SCOTCH_Dgraph;
+
+typedef struct {
+  double                    dummy[1];
+} SCOTCH_DgraphHaloReq;
+
+typedef struct {
+  double                    dummy[1];
+} SCOTCH_Dmapping;
+
+typedef struct {
+  double                    dummy[1];
+} SCOTCH_Dordering;
+#endif /* SCOTCH_PTSCOTCH */
+
+typedef struct {
+  double                    dummy[2];
+} SCOTCH_Geom;
+
+typedef struct {
+  double                    dummy[12];
+} SCOTCH_Graph;
+
+typedef struct {
+  double                    dummy[15];
+} SCOTCH_Mesh;
+
+typedef struct {
+  double                    dummy[13];
+} SCOTCH_Mapping;
+
+typedef struct {
+  double                    dummy[12];
+} SCOTCH_Ordering;
+
+typedef struct {
+  double                    dummy[1];
+} SCOTCH_Strat;
+
+/*
+**  The function prototypes.
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+SCOTCH_Arch *               SCOTCH_archAlloc    (void);
+int                         SCOTCH_archInit     (SCOTCH_Arch * const);
+void                        SCOTCH_archExit     (SCOTCH_Arch * const);
+int                         SCOTCH_archLoad     (SCOTCH_Arch * const, FILE * const);
+int                         SCOTCH_archSave     (const SCOTCH_Arch * const, FILE * const);
+int                         SCOTCH_archBuild    (SCOTCH_Arch * const, const SCOTCH_Graph * const, const SCOTCH_Num, const SCOTCH_Num * const, const SCOTCH_Strat * const);
+char *                      SCOTCH_archName     (const SCOTCH_Arch * const);
+SCOTCH_Num                  SCOTCH_archSize     (const SCOTCH_Arch * const);
+int                         SCOTCH_archCmplt    (SCOTCH_Arch * const, const SCOTCH_Num);
+int                         SCOTCH_archCmpltw   (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num * const);
+int                         SCOTCH_archHcub     (SCOTCH_Arch * const, const SCOTCH_Num);
+int                         SCOTCH_archMesh2    (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_archMesh3    (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_archTleaf    (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num * const, const SCOTCH_Num * const);
+int                         SCOTCH_archTorus2   (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_archTorus3   (SCOTCH_Arch * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_archVcmplt   (SCOTCH_Arch * const);
+int                         SCOTCH_archVhcub    (SCOTCH_Arch * const);
+
+#ifdef SCOTCH_PTSCOTCH
+SCOTCH_Dgraph *             SCOTCH_dgraphAlloc  (void);
+int                         SCOTCH_dgraphInit   (SCOTCH_Dgraph * const, MPI_Comm);
+void                        SCOTCH_dgraphExit   (SCOTCH_Dgraph * const);
+void                        SCOTCH_dgraphFree   (SCOTCH_Dgraph * const);
+int                         SCOTCH_dgraphLoad   (SCOTCH_Dgraph * const, FILE * const, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_dgraphSave   (SCOTCH_Dgraph * const, FILE * const);
+int                         SCOTCH_dgraphCheck  (const SCOTCH_Dgraph * const);
+int                         SCOTCH_dgraphBuild  (SCOTCH_Dgraph * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, const SCOTCH_Num, const SCOTCH_Num, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_dgraphBuildGrid3D (SCOTCH_Dgraph * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const int);
+int                         SCOTCH_dgraphGather (const SCOTCH_Dgraph * const, SCOTCH_Graph * const);
+int                         SCOTCH_dgraphScatter (SCOTCH_Dgraph * const, const SCOTCH_Graph * const);
+void                        SCOTCH_dgraphSize   (const SCOTCH_Dgraph * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_dgraphData   (const SCOTCH_Dgraph * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, MPI_Comm * const);
+int                         SCOTCH_dgraphStat   (const SCOTCH_Dgraph * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const);
+int                         SCOTCH_dgraphGhst   (SCOTCH_Dgraph * const);
+int                         SCOTCH_dgraphHalo   (SCOTCH_Dgraph * const, void * const, const MPI_Datatype);
+int                         SCOTCH_dgraphHaloAsync (SCOTCH_Dgraph * const, void * const, const MPI_Datatype, SCOTCH_DgraphHaloReq * const);
+SCOTCH_DgraphHaloReq *      SCOTCH_dgraphHaloReqAlloc (void);
+int                         SCOTCH_dgraphHaloWait (SCOTCH_DgraphHaloReq * const);
+int                         SCOTCH_dgraphMapInit (const SCOTCH_Dgraph * const, SCOTCH_Dmapping * const, const SCOTCH_Arch * const, SCOTCH_Num * const);
+void                        SCOTCH_dgraphMapExit (const SCOTCH_Dgraph * const, SCOTCH_Dmapping * const);
+int                         SCOTCH_dgraphMapSave (const SCOTCH_Dgraph * const, const SCOTCH_Dmapping * const, FILE * const);
+int                         SCOTCH_dgraphMapView (SCOTCH_Dgraph * const, const SCOTCH_Dmapping * const, FILE * const);
+int                         SCOTCH_dgraphMapCompute (SCOTCH_Dgraph * const, SCOTCH_Dmapping * const, SCOTCH_Strat * const);
+int                         SCOTCH_dgraphMap     (SCOTCH_Dgraph * const, const SCOTCH_Arch * const, SCOTCH_Strat * const, SCOTCH_Num * const);
+int                         SCOTCH_dgraphPart    (SCOTCH_Dgraph * const, const SCOTCH_Num, SCOTCH_Strat * const, SCOTCH_Num * const);
+int                         SCOTCH_dgraphCorderInit (const SCOTCH_Dgraph * const, SCOTCH_Ordering * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_dgraphCorderExit (const SCOTCH_Dgraph * const, SCOTCH_Ordering * const);
+
+int                         SCOTCH_dgraphOrderInit (const SCOTCH_Dgraph * const, SCOTCH_Dordering * const);
+void                        SCOTCH_dgraphOrderExit (const SCOTCH_Dgraph * const, SCOTCH_Dordering * const);
+int                         SCOTCH_dgraphOrderSave (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, FILE * const);
+int                         SCOTCH_dgraphOrderSaveBlock (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, FILE * const);
+int                         SCOTCH_dgraphOrderSaveMap (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, FILE * const);
+int                         SCOTCH_dgraphOrderSaveTree (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, FILE * const);
+int                         SCOTCH_dgraphOrderPerm (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, SCOTCH_Num * const);
+SCOTCH_Num                  SCOTCH_dgraphOrderCblkDist (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const);
+int                         SCOTCH_dgraphOrderTreeDist (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_dgraphOrderCompute (SCOTCH_Dgraph * const, SCOTCH_Dordering * const, SCOTCH_Strat * const);
+int                         SCOTCH_dgraphOrderComputeList (SCOTCH_Dgraph * const, SCOTCH_Dordering * const, const SCOTCH_Num, const SCOTCH_Num * const, SCOTCH_Strat * const);
+int                         SCOTCH_dgraphOrderGather (const SCOTCH_Dgraph * const, const SCOTCH_Dordering * const, SCOTCH_Ordering * const);
+
+SCOTCH_Dmapping *           SCOTCH_dmapAlloc    (void);
+
+SCOTCH_Dordering *          SCOTCH_dorderAlloc  (void);
+#endif /* SCOTCH_PTSCOTCH */
+
+void                        SCOTCH_errorProg    (const char * const);
+void                        SCOTCH_errorPrint   (const char * const, ...);
+void                        SCOTCH_errorPrintW  (const char * const, ...);
+
+SCOTCH_Geom *               SCOTCH_geomAlloc    (void);
+int                         SCOTCH_geomInit     (SCOTCH_Geom * const);
+void                        SCOTCH_geomExit     (SCOTCH_Geom * const);
+void                        SCOTCH_geomData     (const SCOTCH_Geom * const, SCOTCH_Num * const, double ** const);
+
+SCOTCH_Graph *              SCOTCH_graphAlloc   (void);
+int                         SCOTCH_graphInit    (SCOTCH_Graph * const);
+void                        SCOTCH_graphExit    (SCOTCH_Graph * const);
+void                        SCOTCH_graphFree    (SCOTCH_Graph * const);
+int                         SCOTCH_graphLoad    (SCOTCH_Graph * const, FILE * const, const SCOTCH_Num, const SCOTCH_Num);
+int                         SCOTCH_graphSave    (const SCOTCH_Graph * const, FILE * const);
+int                         SCOTCH_graphBuild   (SCOTCH_Graph * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num, const SCOTCH_Num * const, const SCOTCH_Num * const);
+SCOTCH_Num                  SCOTCH_graphBase    (SCOTCH_Graph * const, const SCOTCH_Num baseval);
+int                         SCOTCH_graphCheck   (const SCOTCH_Graph * const);
+void                        SCOTCH_graphSize    (const SCOTCH_Graph * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_graphData    (const SCOTCH_Graph * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num ** const);
+void                        SCOTCH_graphStat    (const SCOTCH_Graph * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const);
+int                         SCOTCH_graphGeomLoadChac (SCOTCH_Graph * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomLoadHabo (SCOTCH_Graph * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomLoadMmkt (SCOTCH_Graph * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomLoadScot (SCOTCH_Graph * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomSaveChac (const SCOTCH_Graph * const, const SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomSaveMmkt (const SCOTCH_Graph * const, const SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_graphGeomSaveScot (const SCOTCH_Graph * const, const SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+
+int                         SCOTCH_graphMapInit (const SCOTCH_Graph * const, SCOTCH_Mapping * const, const SCOTCH_Arch * const, SCOTCH_Num * const);
+void                        SCOTCH_graphMapExit (const SCOTCH_Graph * const, SCOTCH_Mapping * const);
+int                         SCOTCH_graphMapLoad (const SCOTCH_Graph * const, const SCOTCH_Mapping * const, FILE * const);
+int                         SCOTCH_graphMapSave (const SCOTCH_Graph * const, const SCOTCH_Mapping * const, FILE * const);
+int                         SCOTCH_graphMapView (const SCOTCH_Graph * const, const SCOTCH_Mapping * const, FILE * const);
+int                         SCOTCH_graphMapCompute (SCOTCH_Graph * const, SCOTCH_Mapping * const, SCOTCH_Strat * const);
+int                         SCOTCH_graphMap     (SCOTCH_Graph * const, const SCOTCH_Arch * const, SCOTCH_Strat * const, SCOTCH_Num * const);
+int                         SCOTCH_graphPart    (SCOTCH_Graph * const, const SCOTCH_Num, SCOTCH_Strat * const, SCOTCH_Num * const);
+
+int                         SCOTCH_graphOrderInit (const SCOTCH_Graph * const, SCOTCH_Ordering * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_graphOrderExit (const SCOTCH_Graph * const, SCOTCH_Ordering * const);
+int                         SCOTCH_graphOrderLoad (const SCOTCH_Graph * const, SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_graphOrderSave (const SCOTCH_Graph * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_graphOrderSaveMap (const SCOTCH_Graph * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_graphOrderSaveTree (const SCOTCH_Graph * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_graphOrderCompute (SCOTCH_Graph * const, SCOTCH_Ordering * const, SCOTCH_Strat * const);
+int                         SCOTCH_graphOrderComputeList (SCOTCH_Graph * const, SCOTCH_Ordering * const, const SCOTCH_Num, const SCOTCH_Num * const, SCOTCH_Strat * const);
+int                         SCOTCH_graphOrderFactor (const SCOTCH_Graph * const, const SCOTCH_Ordering * const, SCOTCH_Graph * const);
+int                         SCOTCH_graphOrderView (const SCOTCH_Graph * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_graphOrder   (SCOTCH_Graph * const, SCOTCH_Strat * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_graphOrderList (SCOTCH_Graph * const, const SCOTCH_Num, const SCOTCH_Num * const, SCOTCH_Strat * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_graphOrderCheck (const SCOTCH_Graph * const, const SCOTCH_Ordering * const);
+
+SCOTCH_Mapping *            SCOTCH_mapAlloc     (void);
+
+void                        SCOTCH_memoryTrace  (void);
+void                        SCOTCH_memoryUntrace (void);
+void                        SCOTCH_memoryTraceReset (void);
+unsigned long               SCOTCH_memoryTraceGet (void);
+
+int                         SCOTCH_meshInit     (SCOTCH_Mesh * const);
+void                        SCOTCH_meshExit     (SCOTCH_Mesh * const);
+int                         SCOTCH_meshLoad     (SCOTCH_Mesh * const, FILE * const, const SCOTCH_Num);
+int                         SCOTCH_meshSave     (const SCOTCH_Mesh * const, FILE * const);
+int                         SCOTCH_meshBuild    (SCOTCH_Mesh * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num * const, const SCOTCH_Num, const SCOTCH_Num * const);
+int                         SCOTCH_meshCheck    (const SCOTCH_Mesh * const);
+void                        SCOTCH_meshSize     (const SCOTCH_Mesh * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_meshData     (const SCOTCH_Mesh * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num ** const, SCOTCH_Num * const, SCOTCH_Num ** const, SCOTCH_Num * const);
+void                        SCOTCH_meshStat     (const SCOTCH_Mesh * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const, SCOTCH_Num * const, SCOTCH_Num * const, double * const, double * const);
+int                         SCOTCH_meshGraph    (const SCOTCH_Mesh * const, SCOTCH_Graph * const);
+int                         SCOTCH_meshGeomLoadHabo (SCOTCH_Mesh * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_meshGeomLoadScot (SCOTCH_Mesh * const, SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+int                         SCOTCH_meshGeomSaveScot (const SCOTCH_Mesh * const, const SCOTCH_Geom * const, FILE * const, FILE * const, const char * const);
+
+int                         SCOTCH_meshOrderInit (const SCOTCH_Mesh * const, SCOTCH_Ordering * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+void                        SCOTCH_meshOrderExit (const SCOTCH_Mesh * const, SCOTCH_Ordering * const);
+int                         SCOTCH_meshOrderSave (const SCOTCH_Mesh * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_meshOrderSaveMap (const SCOTCH_Mesh * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_meshOrderSaveTree (const SCOTCH_Mesh * const, const SCOTCH_Ordering * const, FILE * const);
+int                         SCOTCH_meshOrderCompute (SCOTCH_Mesh * const, SCOTCH_Ordering * const, SCOTCH_Strat * const);
+int                         SCOTCH_meshOrderComputeList (SCOTCH_Mesh * const, SCOTCH_Ordering * const, const SCOTCH_Num, const SCOTCH_Num * const, SCOTCH_Strat * const);
+int                         SCOTCH_meshOrder    (SCOTCH_Mesh * const, SCOTCH_Strat * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_meshOrderList (SCOTCH_Mesh * const, const SCOTCH_Num, const SCOTCH_Num * const, SCOTCH_Strat * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const, SCOTCH_Num * const);
+int                         SCOTCH_meshOrderCheck (const SCOTCH_Mesh * const, const SCOTCH_Ordering * const);
+
+SCOTCH_Ordering *           SCOTCH_orderAlloc   (void);
+
+void                        SCOTCH_randomReset  (void);
+
+SCOTCH_Strat *              SCOTCH_stratAlloc   (void);
+int                         SCOTCH_stratInit    (SCOTCH_Strat * const);
+void                        SCOTCH_stratExit    (SCOTCH_Strat * const);
+void                        SCOTCH_stratFree    (SCOTCH_Strat * const);
+int                         SCOTCH_stratSave    (const SCOTCH_Strat * const, FILE * const);
+#ifdef SCOTCH_PTSCOTCH
+int                         SCOTCH_stratDgraphMap (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratDgraphMapBuild (SCOTCH_Strat * const, const SCOTCH_Num, const SCOTCH_Num, const SCOTCH_Num, const double);
+int                         SCOTCH_stratDgraphOrder (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratDgraphOrderBuild (SCOTCH_Strat * const, const SCOTCH_Num, const SCOTCH_Num, const double);
+#endif /* SCOTCH_PTSCOTCH */
+int                         SCOTCH_stratGraphBipart (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratGraphMap (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratGraphMapBuild (SCOTCH_Strat * const, const SCOTCH_Num, const SCOTCH_Num, const double);
+int                         SCOTCH_stratGraphOrder (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratGraphOrderBuild (SCOTCH_Strat * const, const SCOTCH_Num, const double);
+int                         SCOTCH_stratMeshOrder (SCOTCH_Strat * const, const char * const);
+int                         SCOTCH_stratMeshOrderBuild (SCOTCH_Strat * const, const SCOTCH_Num, const double);
+
+void                        SCOTCH_version      (int * const, int * const, int * const);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
--- extra/scotch/src/libscotch/Makefile	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/libscotch/Makefile	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2961 @@
+## Copyright 2004,2007-2012 IPB, Universite de Bordeaux, INRIA & CNRS
+##
+## This file is part of the Scotch software package for static mapping,
+## graph partitioning and sparse matrix ordering.
+##
+## This software is governed by the CeCILL-C license under French law
+## and abiding by the rules of distribution of free software. You can
+## use, modify and/or redistribute the software under the terms of the
+## CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
+## URL: "http://www.cecill.info".
+## 
+## As a counterpart to the access to the source code and rights to copy,
+## modify and redistribute granted by the license, users are provided
+## only with a limited warranty and the software's author, the holder of
+## the economic rights, and the successive licensors have only limited
+## liability.
+## 
+## In this respect, the user's attention is drawn to the risks associated
+## with loading, using, modifying and/or developing or reproducing the
+## software by the user in light of its specific status of free software,
+## that may mean that it is complicated to manipulate, and that also
+## therefore means that it is reserved for developers and experienced
+## professionals having in-depth computer knowledge. Users are therefore
+## encouraged to load and test the software's suitability as regards
+## their requirements in conditions enabling the security of their
+## systems and/or data to be ensured and, more generally, to use and
+## operate it in the same conditions as regards security.
+## 
+## The fact that you are presently reading this means that you have had
+## knowledge of the CeCILL-C license and that you accept its terms.
+##
+
+includedir	= ../../include
+libdir		= ../../lib
+
+##
+##  General inference rules.
+##
+
+include ../Makefile.inc
+
+%$(OBJ)	:	%.c
+				$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -o $(@)
+
+%$(EXE)	:	%.c
+		 		$(CC) $(CFLAGS) -DSCOTCH_VERSION=$(VERSION) -DSCOTCH_RELEASE=$(RELEASE) -DSCOTCH_PATCHLEVEL=$(PATCHLEVEL) $(<) -o $(@) $(LDFLAGS)
+
+##
+##  Project rules.
+##
+
+.PHONY				:	libscotch ptscotch	scotch	ptinstall	install	clean	realclean
+
+libscotch : libscotch$(LIB) scotch.h
+
+scotch				:
+					$(MAKE) CC="$(CCS)" CCD="$(CCS)"	\
+					scotch.h				\
+					scotchf.h				\
+					libscotch$(LIB)				\
+					libscotcherr$(LIB)			\
+					libscotcherrexit$(LIB)
+
+ptscotch			:	scotch
+					$(MAKE) CFLAGS="$(CFLAGS) -DSCOTCH_PTSCOTCH" CC="$(CCP)"	\
+					ptscotch.h							\
+					ptscotchf.h							\
+					libptscotch$(LIB)						\
+					libptscotcherr$(LIB)						\
+					libptscotcherrexit$(LIB)
+
+install				:	$(includedir)/scotch.h			\
+					$(includedir)/scotchf.h			\
+					$(libdir)/libscotch$(LIB)
+
+ptinstall			:	install					\
+					$(includedir)/ptscotch.h		\
+					$(includedir)/ptscotchf.h		\
+					$(libdir)/libptscotch$(LIB)
+
+clean				:
+					-$(RM) *~ *$(OBJ) lib*$(LIB) parser_yy.c parser_ly.h parser_ll.c *scotch.h *scotchf.h y.output *dummysizes$(EXE)
+
+realclean			:	clean
+
+
+##
+##  Installation dependencies
+##
+
+$(includedir)/scotch.h		:	scotch.h
+					-$(CP) scotch.h $(includedir)
+
+$(includedir)/scotchf.h		:	scotchf.h
+					-$(CP) scotchf.h $(includedir)
+
+$(includedir)/ptscotch.h	:	ptscotch.h
+					-$(CP) ptscotch.h $(includedir)
+
+$(includedir)/ptscotchf.h	:	ptscotchf.h
+					-$(CP) ptscotchf.h $(includedir)
+
+$(libdir)/libscotch$(LIB)	:	libscotch$(LIB)
+					-$(CP) libscotch$(LIB) libscotcherr*$(LIB) $(libdir)
+
+$(libdir)/libptscotch$(LIB)	:	libptscotch$(LIB)
+					-$(CP) libptscotch$(LIB) libptscotcherr*$(LIB) $(libdir)
+
+##
+##  Library dependencies.
+##
+
+LIBPTSCOTCHDEPS =	bdgraph$(OBJ)				\
+			bdgraph_bipart_bd$(OBJ)			\
+			bdgraph_bipart_df$(OBJ)			\
+			bdgraph_bipart_ex$(OBJ)			\
+			bdgraph_bipart_ml$(OBJ)			\
+			bdgraph_bipart_sq$(OBJ)			\
+			bdgraph_bipart_st$(OBJ)			\
+			bdgraph_bipart_zr$(OBJ)			\
+			bdgraph_check$(OBJ)			\
+			bdgraph_gather_all$(OBJ)		\
+			bdgraph_store$(OBJ)			\
+			comm$(OBJ)				\
+			dgraph$(OBJ)				\
+			dgraph_allreduce$(OBJ)			\
+			dgraph_band$(OBJ)			\
+			dgraph_build$(OBJ)			\
+			dgraph_build_grid3d$(OBJ)		\
+			dgraph_build_hcub$(OBJ)			\
+			dgraph_check$(OBJ)			\
+			dgraph_coarsen$(OBJ)			\
+			dgraph_fold$(OBJ)			\
+			dgraph_fold_comm$(OBJ)			\
+			dgraph_fold_dup$(OBJ)			\
+			dgraph_gather$(OBJ)			\
+			dgraph_gather_all$(OBJ)			\
+			dgraph_ghst$(OBJ)			\
+			dgraph_halo$(OBJ)			\
+			dgraph_induce$(OBJ)			\
+			dgraph_io_load$(OBJ)			\
+			dgraph_io_save$(OBJ)			\
+			dgraph_match$(OBJ)			\
+			dgraph_match_sync_coll$(OBJ)		\
+			dgraph_match_sync_ptop$(OBJ)		\
+			dgraph_match_check$(OBJ)		\
+			dgraph_redist$(OBJ)			\
+			dgraph_scatter$(OBJ)			\
+			dgraph_view$(OBJ)			\
+			dmapping$(OBJ)				\
+			dmapping_io$(OBJ)			\
+			dorder$(OBJ)				\
+			dorder_gather$(OBJ)			\
+			dorder_io$(OBJ)				\
+			dorder_io_block$(OBJ)			\
+			dorder_io_tree$(OBJ)			\
+			dorder_perm$(OBJ)			\
+			dorder_tree_dist$(OBJ)			\
+			hdgraph$(OBJ)				\
+			hdgraph_check$(OBJ)			\
+			hdgraph_fold$(OBJ)			\
+			hdgraph_gather$(OBJ)			\
+			hdgraph_induce$(OBJ)			\
+			hdgraph_order_nd$(OBJ)			\
+			hdgraph_order_si$(OBJ)			\
+			hdgraph_order_sq$(OBJ)			\
+			hdgraph_order_st$(OBJ)			\
+			kdgraph$(OBJ)				\
+			kdgraph_gather$(OBJ)			\
+			kdgraph_map_rb$(OBJ)			\
+			kdgraph_map_rb_map$(OBJ)		\
+			kdgraph_map_rb_part$(OBJ)		\
+			kdgraph_map_st$(OBJ)			\
+			library_dgraph$(OBJ)			\
+			library_dgraph_f$(OBJ)			\
+			library_dgraph_band$(OBJ)		\
+			library_dgraph_band_f$(OBJ)		\
+			library_dgraph_build$(OBJ)		\
+			library_dgraph_build_f$(OBJ)		\
+			library_dgraph_build_grid3d$(OBJ)	\
+			library_dgraph_build_grid3d_f$(OBJ)	\
+			library_dgraph_check$(OBJ)		\
+			library_dgraph_check_f$(OBJ)		\
+			library_dgraph_coarsen$(OBJ)		\
+			library_dgraph_coarsen_f$(OBJ)		\
+			library_dgraph_gather$(OBJ)		\
+			library_dgraph_gather_f$(OBJ)		\
+			library_dgraph_grow$(OBJ)		\
+			library_dgraph_halo$(OBJ)		\
+			library_dgraph_halo_f$(OBJ)		\
+			library_dgraph_induce$(OBJ)		\
+			library_dgraph_induce_f$(OBJ)		\
+			library_dgraph_io_load$(OBJ)		\
+			library_dgraph_io_load_f$(OBJ)		\
+			library_dgraph_io_save$(OBJ)		\
+			library_dgraph_io_save_f$(OBJ)		\
+			library_dgraph_map$(OBJ)		\
+			library_dgraph_map_f$(OBJ)		\
+			library_dgraph_map_view$(OBJ)		\
+			library_dgraph_map_view_f$(OBJ)		\
+			library_dgraph_order$(OBJ)		\
+			library_dgraph_order_f$(OBJ)		\
+			library_dgraph_order_gather$(OBJ)	\
+			library_dgraph_order_gather_f$(OBJ)	\
+			library_dgraph_order_io$(OBJ)		\
+			library_dgraph_order_io_f$(OBJ)		\
+			library_dgraph_order_io_block$(OBJ)	\
+			library_dgraph_order_io_block_f$(OBJ)	\
+			library_dgraph_order_perm$(OBJ)		\
+			library_dgraph_order_perm_f$(OBJ)	\
+			library_dgraph_order_tree_dist$(OBJ)	\
+			library_dgraph_order_tree_dist_f$(OBJ)	\
+			library_dgraph_redist$(OBJ)		\
+			library_dgraph_redist_f$(OBJ)		\
+			library_dgraph_scatter$(OBJ)		\
+			library_dgraph_scatter_f$(OBJ)		\
+			library_dgraph_stat$(OBJ)		\
+			library_dgraph_stat_f$(OBJ)		\
+			library_dmapping$(OBJ)			\
+			library_dorder$(OBJ)			\
+			vdgraph$(OBJ)				\
+			vdgraph_check$(OBJ)			\
+			vdgraph_gather_all$(OBJ)		\
+			vdgraph_separate_bd$(OBJ)		\
+			vdgraph_separate_df$(OBJ)		\
+			vdgraph_separate_ml$(OBJ)		\
+			vdgraph_separate_sq$(OBJ)		\
+			vdgraph_separate_st$(OBJ)		\
+			vdgraph_separate_zr$(OBJ)		\
+			vdgraph_store$(OBJ)
+
+LIBSCOTCHDEPS	=	arch$(OBJ)				\
+			arch_build$(OBJ)			\
+			arch_cmplt$(OBJ)			\
+			arch_cmpltw$(OBJ)			\
+			arch_deco$(OBJ)				\
+			arch_dist$(OBJ)				\
+			arch_hcub$(OBJ)				\
+			arch_mesh$(OBJ)				\
+			arch_tleaf$(OBJ)			\
+			arch_torus$(OBJ)			\
+			arch_vcmplt$(OBJ)			\
+			arch_vhcub$(OBJ)			\
+			bgraph$(OBJ)				\
+			bgraph_bipart_bd$(OBJ)			\
+			bgraph_bipart_df$(OBJ)			\
+			bgraph_bipart_ex$(OBJ)			\
+			bgraph_bipart_fm$(OBJ)			\
+			bgraph_bipart_gg$(OBJ)			\
+			bgraph_bipart_gp$(OBJ)			\
+			bgraph_bipart_ml$(OBJ)			\
+			bgraph_bipart_st$(OBJ)			\
+			bgraph_bipart_zr$(OBJ)			\
+			bgraph_check$(OBJ)			\
+			bgraph_store$(OBJ)			\
+			common$(OBJ)				\
+			common_file$(OBJ)			\
+			common_file_compress$(OBJ)		\
+			common_file_uncompress$(OBJ)		\
+			common_integer$(OBJ)			\
+			common_memory$(OBJ)			\
+			common_string$(OBJ)			\
+			common_stub$(OBJ)			\
+			common_thread$(OBJ)			\
+			fibo$(OBJ)				\
+			gain$(OBJ)				\
+			geom$(OBJ)				\
+			graph$(OBJ)				\
+			graph_base$(OBJ)			\
+			graph_band$(OBJ)			\
+			graph_check$(OBJ)			\
+			graph_coarsen$(OBJ)			\
+			graph_induce$(OBJ)			\
+			graph_io$(OBJ)				\
+			graph_io_chac$(OBJ)			\
+			graph_io_habo$(OBJ)			\
+			graph_io_mmkt$(OBJ)			\
+			graph_io_scot$(OBJ)			\
+			graph_list$(OBJ)			\
+			graph_match$(OBJ)			\
+			hall_order_hd$(OBJ)			\
+			hall_order_hf$(OBJ)			\
+			hall_order_hx$(OBJ)			\
+			hgraph$(OBJ)				\
+			hgraph_check$(OBJ)			\
+			hgraph_induce$(OBJ)			\
+			hgraph_order_bl$(OBJ)			\
+			hgraph_order_cp$(OBJ)			\
+			hgraph_order_gp$(OBJ)			\
+			hgraph_order_hd$(OBJ)			\
+			hgraph_order_hf$(OBJ)			\
+			hgraph_order_hx$(OBJ)			\
+			hgraph_order_kp$(OBJ)			\
+			hgraph_order_nd$(OBJ)			\
+			hgraph_order_si$(OBJ)			\
+			hgraph_order_st$(OBJ)			\
+			hmesh$(OBJ)				\
+			hmesh_check$(OBJ)			\
+			hmesh_hgraph$(OBJ)			\
+			hmesh_induce$(OBJ)			\
+			hmesh_mesh$(OBJ)			\
+			hmesh_order_bl$(OBJ)			\
+			hmesh_order_cp$(OBJ)			\
+			hmesh_order_gr$(OBJ)			\
+			hmesh_order_gp$(OBJ)			\
+			hmesh_order_hd$(OBJ)			\
+			hmesh_order_hf$(OBJ)			\
+			hmesh_order_hx$(OBJ)			\
+			hmesh_order_nd$(OBJ)			\
+			hmesh_order_si$(OBJ)			\
+			hmesh_order_st$(OBJ)			\
+			kgraph$(OBJ)				\
+			kgraph_band$(OBJ)			\
+			kgraph_check$(OBJ)			\
+			kgraph_map_bd$(OBJ)			\
+			kgraph_map_cp$(OBJ)			\
+			kgraph_map_df$(OBJ)			\
+			kgraph_map_ex$(OBJ)			\
+			kgraph_map_fm$(OBJ)			\
+			kgraph_map_ml$(OBJ)			\
+			kgraph_map_rb$(OBJ)			\
+			kgraph_map_rb_map$(OBJ)			\
+			kgraph_map_rb_part$(OBJ)		\
+			kgraph_map_st$(OBJ)			\
+			kgraph_store$(OBJ)			\
+			library_arch$(OBJ)			\
+			library_arch_f$(OBJ)			\
+			library_arch_build$(OBJ)		\
+			library_arch_build_f$(OBJ)		\
+			library_common_f$(OBJ)			\
+			library_geom$(OBJ)			\
+			library_geom_f$(OBJ)			\
+			library_graph$(OBJ)			\
+			library_graph_f$(OBJ)			\
+			library_graph_base$(OBJ)		\
+			library_graph_base_f$(OBJ)		\
+			library_graph_check$(OBJ)		\
+			library_graph_check_f$(OBJ)		\
+			library_graph_coarsen$(OBJ)		\
+			library_graph_coarsen_f$(OBJ)		\
+			library_graph_color$(OBJ)		\
+			library_graph_color_f$(OBJ)		\
+			library_graph_io_chac$(OBJ)		\
+			library_graph_io_chac_f$(OBJ)		\
+			library_graph_io_habo$(OBJ)		\
+			library_graph_io_habo_f$(OBJ)		\
+			library_graph_io_mmkt$(OBJ)		\
+			library_graph_io_mmkt_f$(OBJ)		\
+			library_graph_io_scot$(OBJ)		\
+			library_graph_io_scot_f$(OBJ)		\
+			library_graph_map$(OBJ)			\
+			library_graph_map_f$(OBJ)		\
+			library_graph_map_io$(OBJ)		\
+			library_graph_map_io_f$(OBJ)		\
+			library_graph_map_view$(OBJ)		\
+			library_graph_map_view_f$(OBJ)		\
+			library_graph_order$(OBJ)		\
+			library_graph_order_f$(OBJ)		\
+			library_graph_part_ovl$(OBJ)		\
+			library_graph_part_ovl_f$(OBJ)		\
+			library_mapping$(OBJ)			\
+			library_mesh$(OBJ)			\
+			library_mesh_f$(OBJ)			\
+			library_mesh_graph$(OBJ)		\
+			library_mesh_graph_f$(OBJ)		\
+			library_mesh_io_habo$(OBJ)		\
+			library_mesh_io_habo_f$(OBJ)		\
+			library_mesh_io_scot$(OBJ)		\
+			library_mesh_io_scot_f$(OBJ)		\
+			library_mesh_order$(OBJ)		\
+			library_mesh_order_f$(OBJ)		\
+			library_order$(OBJ)			\
+			library_parser$(OBJ)			\
+			library_parser_f$(OBJ)			\
+			library_random$(OBJ)			\
+			library_random_f$(OBJ)			\
+			library_strat$(OBJ)			\
+			library_version$(OBJ)			\
+			library_version_f$(OBJ)			\
+			mapping$(OBJ)				\
+			mapping_io$(OBJ)			\
+			mesh$(OBJ)				\
+			mesh_check$(OBJ)			\
+			mesh_coarsen$(OBJ)			\
+			mesh_graph$(OBJ)			\
+			mesh_induce_sepa$(OBJ)			\
+			mesh_io$(OBJ)				\
+			mesh_io_habo$(OBJ)			\
+			mesh_io_scot$(OBJ)			\
+			order$(OBJ)				\
+			order_check$(OBJ)			\
+			order_io$(OBJ)				\
+			parser$(OBJ)				\
+			parser_ll$(OBJ)				\
+			parser_yy$(OBJ)				\
+			vgraph$(OBJ)				\
+			vgraph_check$(OBJ)			\
+			vgraph_separate_bd$(OBJ)		\
+			vgraph_separate_df$(OBJ)		\
+			vgraph_separate_es$(OBJ)		\
+			vgraph_separate_fm$(OBJ)		\
+			vgraph_separate_gg$(OBJ)		\
+			vgraph_separate_gp$(OBJ)		\
+			vgraph_separate_ml$(OBJ)		\
+			vgraph_separate_st$(OBJ)		\
+			vgraph_separate_th$(OBJ)		\
+			vgraph_separate_vw$(OBJ)		\
+			vgraph_separate_zr$(OBJ)		\
+			vgraph_store$(OBJ)			\
+			vmesh$(OBJ)				\
+			vmesh_check$(OBJ)			\
+			vmesh_separate_fm$(OBJ)			\
+			vmesh_separate_gg$(OBJ)			\
+			vmesh_separate_gr$(OBJ)			\
+			vmesh_separate_ml$(OBJ)			\
+			vmesh_separate_zr$(OBJ)			\
+			vmesh_separate_st$(OBJ)			\
+			vmesh_store$(OBJ)			\
+			wgraph$(OBJ)				\
+			wgraph_check$(OBJ)			\
+			wgraph_part_fm$(OBJ)  			\
+			wgraph_part_gg$(OBJ)          		\
+			wgraph_part_gp$(OBJ)	        	\
+			wgraph_part_ml$(OBJ)   			\
+			wgraph_part_rb$(OBJ)  			\
+			wgraph_part_st$(OBJ)  			\
+			wgraph_part_zr$(OBJ)  			\
+			wgraph_store$(OBJ)			\
+			library_error_exit$(OBJ)
+
+##
+##  Todo list.
+##
+
+common$(OBJ)			:	common.c				\
+					module.h				\
+					common.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_file$(OBJ)		:	common_file.c				\
+					module.h				\
+					common.h				\
+					common_file.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_file_compress$(OBJ)	:	common_file_compress.c			\
+					module.h				\
+					common.h				\
+					common_file.h				\
+					common_file_compress.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_file_uncompress$(OBJ)	:	common_file_uncompress.c		\
+					module.h				\
+					common.h				\
+					common_file.h				\
+					common_file_compress.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_integer$(OBJ)		:	common_integer.c			\
+					module.h				\
+					common.h				\
+					common_sort.c
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_memory$(OBJ)		:	common_memory.c				\
+					module.h				\
+					common.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_string$(OBJ)		:	common_string.c				\
+					module.h				\
+					common.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_stub$(OBJ)		:	common_stub.c				\
+					module.h				\
+					common.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+common_thread$(OBJ)		:	common_thread.c				\
+					module.h				\
+					common.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -DSCOTCH_COMMON_RENAME -o $(@)
+
+arch$(OBJ)			:	arch.c					\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_cmplt.h				\
+					arch_cmpltw.h				\
+					arch_deco.h				\
+					arch_dist.h				\
+					arch_hcub.h				\
+					arch_mesh.h				\
+					arch_tleaf.h				\
+					arch_torus.h				\
+					arch_vcmplt.h				\
+					arch_vhcub.h
+
+arch_build$(OBJ)		:	arch_build.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					arch_deco.h				\
+					arch_vcmplt.h				\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					arch_build.h
+
+arch_cmplt$(OBJ)		:	arch_cmplt.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_cmplt.h
+
+arch_cmpltw$(OBJ)		:	arch_cmpltw.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_cmpltw.h
+
+arch_deco$(OBJ)			:	arch_deco.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_deco.h
+
+arch_dist$(OBJ)			:	arch_dist.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_dist.h
+
+arch_hcub$(OBJ)			:	arch_hcub.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_hcub.h
+
+arch_mesh$(OBJ)			:	arch_mesh.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_mesh.h
+
+arch_tleaf$(OBJ)		:	arch_tleaf.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_tleaf.h
+
+arch_torus$(OBJ)		:	arch_torus.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_torus.h
+
+arch_vcpmlt$(OBJ)		:	arch_vcmplt.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_vcmplt.h
+
+arch_vhcub$(OBJ)		:	arch_vhcub.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					arch_vhcub.h
+
+bdgraph$(OBJ)			:	bdgraph.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					dmapping.h				\
+					bdgraph.h
+
+bdgraph_bipart_bd$(OBJ)		:	bdgraph_bipart_bd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					dgraph.h				\
+					dgraph_halo.h				\
+					bdgraph.h				\
+					bdgraph_bipart_bd.h			\
+					bdgraph_bipart_st.h
+
+bdgraph_bipart_df$(OBJ)		:	bdgraph_bipart_df.c			\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					bdgraph.h				\
+					bdgraph_bipart_df.h
+
+bdgraph_bipart_ex$(OBJ)		:	bdgraph_bipart_ex.c			\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					bdgraph.h				\
+					bdgraph_bipart_ex.h
+
+bdgraph_bipart_ml$(OBJ)		:	bdgraph_bipart_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					bdgraph.h				\
+					bdgraph_bipart_ml.h			\
+					bdgraph_bipart_st.h
+
+bdgraph_bipart_sq$(OBJ)		:	bdgraph_bipart_sq.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					parser.h				\
+					arch.h					\
+					graph.h					\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					dgraph.h				\
+					bdgraph.h				\
+					bdgraph_bipart_sq.h
+
+bdgraph_bipart_st$(OBJ)		:	bdgraph_bipart_st.c			\
+					module.h				\
+					common.h				\
+					gain.h					\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					bdgraph.h				\
+					bdgraph_bipart_bd.h			\
+					bdgraph_bipart_df.h			\
+					bdgraph_bipart_ex.h			\
+					bdgraph_bipart_ml.h			\
+					bdgraph_bipart_sq.h			\
+					bdgraph_bipart_st.h			\
+					bdgraph_bipart_zr.h
+
+bdgraph_bipart_zr$(OBJ)		:	bdgraph_bipart_zr.c			\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					bdgraph.h				\
+					bdgraph_bipart_zr.h
+
+bdgraph_check$(OBJ)		:	bdgraph_check.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					bdgraph.h
+
+bdgraph_gather_all$(OBJ)	:	bdgraph_gather_all.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					arch.h					\
+					graph.h					\
+					bgraph.h				\
+					dgraph.h				\
+					bdgraph.h
+
+bdgraph_store$(OBJ)		:	bdgraph_store.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					bdgraph.h
+
+bgraph$(OBJ)			:	bgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h
+
+bgraph_check$(OBJ)		:	bgraph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h
+
+bgraph_bipart_bd$(OBJ)		:	bgraph_bipart_bd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_bd.h			\
+					bgraph_bipart_st.h
+
+bgraph_bipart_df$(OBJ)		:	bgraph_bipart_df.c			\
+					bgraph_bipart_df_loop.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_df.h
+
+bgraph_bipart_ex$(OBJ)		:	bgraph_bipart_ex.c			\
+					module.h				\
+					common.h				\
+					gain.h					\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_ex.h			\
+					bgraph_bipart_fm.h			\
+					bgraph_bipart_gg.h
+
+bgraph_bipart_fm$(OBJ)		:	bgraph_bipart_fm.c			\
+					gain.h					\
+					fibo.h					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_fm.h
+
+bgraph_bipart_gg$(OBJ)		:	bgraph_bipart_gg.c			\
+					gain.h					\
+					fibo.h					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_gg.h
+
+bgraph_bipart_gp$(OBJ)		:	bgraph_bipart_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_gp.h
+
+bgraph_bipart_ml$(OBJ)		:	bgraph_bipart_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_ml.h			\
+					bgraph_bipart_st.h
+
+bgraph_bipart_st$(OBJ)		:	bgraph_bipart_st.c			\
+					gain.h					\
+					fibo.h					\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_bd.h			\
+					bgraph_bipart_df.h			\
+					bgraph_bipart_ex.h			\
+					bgraph_bipart_fm.h			\
+					bgraph_bipart_gg.h			\
+					bgraph_bipart_gp.h			\
+					bgraph_bipart_ml.h			\
+					bgraph_bipart_st.h			\
+					bgraph_bipart_zr.h
+
+bgraph_bipart_zr$(OBJ)		:	bgraph_bipart_zr.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h				\
+					bgraph_bipart_zr.h
+
+bgraph_store$(OBJ)		:	bgraph_store.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					bgraph.h
+
+comm$(OBJ)			:	comm.c					\
+					module.h				\
+					common.h				\
+					comm.h
+
+dgraph$(OBJ)			:	dgraph.c				\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_allreduce$(OBJ)		:	dgraph_allreduce.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_allreduce.h
+
+dgraph_band$(OBJ)		:	dgraph_band.c				\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_build$(OBJ)		:	dgraph_build.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_allreduce.h			\
+					dgraph_build.h
+
+dgraph_build_grid3d$(OBJ)	:	dgraph_build_grid3d.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_build_grid3d.h
+
+dgraph_build_hcub$(OBJ)		:	dgraph_build_hcub.c			\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_check$(OBJ)		:	dgraph_check.c				\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_coarsen$(OBJ)		:	dgraph_coarsen.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_allreduce.h			\
+					dgraph_coarsen.h			\
+					dgraph_match.h
+
+dgraph_fold$(OBJ)		:	dgraph_fold.c				\
+					module.h				\
+					common.h				\
+					comm.h					\
+					dgraph.h				\
+					dgraph_fold.h				\
+					dgraph_fold_comm.h
+
+dgraph_fold_comm$(OBJ)		:	dgraph_fold_comm.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					dgraph.h				\
+					dgraph_fold_comm.h
+
+dgraph_fold_dup$(OBJ)		:	dgraph_fold_dup.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_fold_dup.h
+
+dgraph_gather$(OBJ)		:	dgraph_gather.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					dgraph.h
+
+dgraph_gather_all$(OBJ)		:	dgraph_gather_all.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					graph.h					\
+					dgraph.h
+
+dgraph_ghst$(OBJ)		:	dgraph_ghst.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_ghst.h
+
+dgraph_halo$(OBJ)		:	dgraph_halo.c				\
+					dgraph_halo_fill.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_halo.h
+
+dgraph_induce$(OBJ)		:	dgraph_induce.c				\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_io_load$(OBJ)		:	dgraph_io_load.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_io_load.h
+
+dgraph_io_save$(OBJ)		:	dgraph_io_save.c			\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dgraph_match$(OBJ)		:	dgraph_match.c				\
+					dgraph_match_scan.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					dgraph_match.h
+
+dgraph_match_check$(OBJ)	:	dgraph_match_check.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					dgraph_match.h
+
+dgraph_match_sync_coll$(OBJ)	:	dgraph_match_sync_coll.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_coarsen.h                        \
+					dgraph_match.h				\
+					graph.h
+
+dgraph_match_sync_ptop$(OBJ)	:	dgraph_match_sync_ptop.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_coarsen.h                        \
+					dgraph_match.h				\
+					graph.h
+
+dgraph_redist$(OBJ)		:	dgraph_redist.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					dgraph.h
+
+dgraph_scatter$(OBJ)		:	dgraph_scatter.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					dgraph.h
+
+dgraph_view$(OBJ)		:	dgraph_view.c				\
+					module.h				\
+					common.h				\
+					dgraph.h
+
+dmapping$(OBJ)			:	dmapping.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					dmapping.h
+
+dmapping_io$(OBJ)		:	dmapping_io.c				\
+					module.h				\
+					common.h				\
+					comm.h					\
+					arch.h					\
+					dgraph.h				\
+					dgraph_allreduce.h			\
+					dmapping.h
+
+dorder$(OBJ)			:	dorder.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h
+
+dorder_gather$(OBJ)		:	dorder_gather.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_allreduce.h			\
+					dorder.h				\
+					dorder_gather.h				\
+					order.h
+
+dorder_io$(OBJ)			:	dorder_io.c				\
+					module.h				\
+					common.h				\
+					comm.h					\
+					dgraph.h				\
+					dorder.h				\
+					order.h
+
+dorder_io_block$(OBJ)		:	dorder_io_block.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					order.h
+
+dorder_io_tree$(OBJ)		:	dorder_io_tree.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					dgraph.h				\
+					dorder.h				\
+					order.h
+
+dorder_perm$(OBJ)		:	dorder_perm.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					dorder_perm.h
+
+dorder_tree_dist$(OBJ)		:	dorder_tree_dist.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h
+
+fibo$(OBJ)			:	fibo.c					\
+					module.h				\
+					common.h				\
+					fibo.h                                  
+
+gain$(OBJ)			:	gain.c					\
+					module.h				\
+					common.h				\
+					gain.h
+
+geom$(OBJ)			:	geom.c					\
+					module.h				\
+					common.h				\
+					geom.h
+
+graph$(OBJ)			:	graph.c					\
+					module.h				\
+					common.h				\
+					graph.h
+
+graph_band$(OBJ)		:	graph_band.c				\
+					module.h				\
+					common.h				\
+					graph.h
+
+graph_base$(OBJ)		:	graph_base.c				\
+					module.h				\
+					common.h				\
+					graph.h
+
+graph_check$(OBJ)		:	graph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h
+
+graph_coarsen$(OBJ)		:	graph_coarsen.c				\
+					graph_coarsen_edge.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_coarsen.h
+
+graph_induce$(OBJ)		:	graph_induce.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_induce.h
+
+graph_io$(OBJ)			:	graph_io.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_io.h
+
+graph_io_chac$(OBJ)		:	graph_io_chac.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h
+
+graph_io_habo$(OBJ)		:	graph_io_habo.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					graph_io_habo.h
+
+graph_io_mmkt$(OBJ)		:	graph_io_mmkt.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					graph_io_mmkt.h
+
+graph_io_scot$(OBJ)		:	graph_io_scot.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					graph_io_scot.h
+
+graph_list$(OBJ)		:	graph_list.c				\
+					module.h				\
+					common.h				\
+					graph.h
+
+graph_match$(OBJ)		:	graph_match.c				\
+					graph_match_scan.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					graph_match.h
+
+hall_order_hd$(OBJ)		:	hall_order_hd.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hall_order_hd.h
+
+hall_order_hf$(OBJ)		:	hall_order_hf.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hall_order_hf.h
+
+hall_order_hx$(OBJ)		:	hall_order_hx.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					hall_order_hx.h
+
+hdgraph$(OBJ)			:	hdgraph.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					hdgraph.h
+
+hdgraph_check$(OBJ)		:	hdgraph_check.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					hdgraph.h
+
+hdgraph_fold$(OBJ)		:	hdgraph_fold.c				\
+					module.h				\
+					common.h				\
+					comm.h					\
+					dgraph.h				\
+					dgraph_fold_comm.h			\
+					hdgraph.h				\
+					hdgraph_fold.h
+
+hdgraph_gather$(OBJ)		:	hdgraph_gather.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					graph.h					\
+					hgraph.h				\
+					dgraph.h				\
+					hdgraph.h
+
+hdgraph_induce$(OBJ)		:	hdgraph_induce.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					hdgraph.h
+
+hdgraph_order_nd$(OBJ)		:	hdgraph_order_nd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_st.h			\
+					dgraph.h				\
+					dorder.h				\
+					hdgraph.h				\
+					hdgraph_order_nd.h			\
+					hdgraph_order_sq.h			\
+					hdgraph_order_st.h			\
+					vdgraph.h				\
+					vdgraph_separate_st.h
+
+hdgraph_order_si$(OBJ)		:	hdgraph_order_si.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					hdgraph.h				\
+					hdgraph_order_si.h
+
+hdgraph_order_sq$(OBJ)		:	hdgraph_order_sq.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_st.h			\
+					dgraph.h				\
+					dorder.h				\
+					hdgraph.h				\
+					hdgraph_order_sq.h
+
+hdgraph_order_st$(OBJ)		:	hdgraph_order_st.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					dorder.h				\
+					hdgraph.h				\
+					vdgraph.h				\
+					vdgraph_separate_st.h			\
+					hdgraph_order_nd.h			\
+					hdgraph_order_si.h			\
+					hdgraph_order_sq.h			\
+					hdgraph_order_st.h
+
+hgraph$(OBJ)			:	hgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hgraph.h
+
+hgraph_check$(OBJ)		:	hgraph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hgraph.h
+
+hgraph_induce$(OBJ)		:	hgraph_induce.c				\
+					hgraph_induce_edge.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hgraph.h				\
+					hgraph_induce.h
+
+hgraph_order_bl$(OBJ)		:	hgraph_order_bl.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_bl.h
+
+hgraph_order_cp$(OBJ)		:	hgraph_order_cp.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_cp.h			\
+					hgraph_order_st.h
+
+hgraph_order_gp$(OBJ)		:	hgraph_order_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_gp.h
+
+hgraph_order_hd$(OBJ)		:	hgraph_order_hd.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hall_order_hd.h				\
+					hall_order_hx.h				\
+					hgraph_order_hd.h			\
+					hgraph_order_hx.h			\
+					hgraph_order_si.h
+
+hgraph_order_hf$(OBJ)		:	hgraph_order_hf.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hall_order_hf.h				\
+					hall_order_hx.h				\
+					hgraph_order_hf.h			\
+					hgraph_order_hx.h			\
+					hgraph_order_si.h
+
+hgraph_order_hx$(OBJ)		:	hgraph_order_hx.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hgraph.h				\
+					hgraph_order_hx.h
+
+hgraph_order_nd$(OBJ)		:	hgraph_order_nd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_nd.h			\
+					hgraph_order_st.h			\
+					vgraph.h				\
+					vgraph_separate_st.h
+
+hgraph_order_si$(OBJ)		:	hgraph_order_si.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_si.h
+
+hgraph_order_st$(OBJ)		:	hgraph_order_st.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_bl.h			\
+					hgraph_order_cp.h			\
+					hgraph_order_gp.h			\
+					hgraph_order_hd.h			\
+					hgraph_order_hf.h			\
+					hgraph_order_kp.h			\
+					hgraph_order_nd.h			\
+					hgraph_order_si.h			\
+					hgraph_order_st.h			\
+					kgraph.h				\
+					kgraph_map_st.h				\
+					vgraph.h				\
+					vgraph_separate_st.h
+
+hmesh$(OBJ)			:	hmesh.c					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h
+
+hmesh_check$(OBJ)		:	hmesh_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h
+
+hmesh_hgraph$(OBJ)		:	hmesh_hgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					hgraph.h				\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_hgraph.h
+
+hmesh_induce$(OBJ)		:	hmesh_induce.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h
+
+hmesh_mesh$(OBJ)		:	hmesh_mesh.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h
+
+hmesh_order_bl$(OBJ)		:	hmesh_order_bl.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_bl.h			\
+					hmesh_order_st.h
+
+hmesh_order_cp$(OBJ)		:	hmesh_order_cp.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_cp.h			\
+					hmesh_order_st.h
+
+hmesh_order_gp$(OBJ)		:	hmesh_order_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_gp.h
+
+hmesh_order_gp$(OBJ)		:	hmesh_order_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_gp.h
+
+hmesh_order_hd$(OBJ)		:	hmesh_order_hd.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hall_order_hd.h				\
+					hall_order_hx.h				\
+					hmesh_order_hd.h			\
+					hmesh_order_si.h
+
+hmesh_order_hf$(OBJ)		:	hmesh_order_hf.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hall_order_hf.h				\
+					hall_order_hx.h				\
+					hmesh_order_hf.h			\
+					hmesh_order_si.h
+
+hmesh_order_hx$(OBJ)		:	hmesh_order_hx.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_hx.h
+
+hmesh_order_nd$(OBJ)		:	hmesh_order_nd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_nd.h			\
+					hmesh_order_st.h			\
+					vmesh.h					\
+					vmesh_separate_st.h
+
+hmesh_order_si$(OBJ)		:	hmesh_order_si.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h					\
+					mesh.h					\
+					hmesh.h					\
+					hmesh_order_si.h
+
+hmesh_order_st$(OBJ)		:	hmesh_order_st.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					hgraph.h				\
+					hgraph_order_st.h			\
+					mesh.h					\
+					hmesh.h					\
+					order.h					\
+					vmesh_separate_st.h			\
+					hmesh_order_bl.h			\
+					hmesh_order_gp.h			\
+					hmesh_order_gr.h			\
+					hmesh_order_hd.h			\
+					hmesh_order_hf.h			\
+					hmesh_order_nd.h			\
+					hmesh_order_si.h			\
+					hmesh_order_st.h
+
+kdgraph$(OBJ)			:	kdgraph.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					dgraph.h				\
+					dmapping.h				\
+					kdgraph.h
+
+kdgraph_gather$(OBJ)		:	kdgraph_gather.c			\
+					module.h				\
+					common.h				\
+					arch.h					\
+					graph.h					\
+					mapping.h				\
+					kgraph.h				\
+					dgraph.h				\
+					kdgraph.h
+
+kdgraph_map_rb$(OBJ)		:	kdgraph_map_rb.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					graph.h					\
+					dgraph.h				\
+					dmapping.h				\
+					kdgraph.h				\
+					kdgraph_map_rb.h			\
+					kdgraph_map_rb_map.h			\
+					kdgraph_map_rb_part.h
+
+kdgraph_map_rb_map$(OBJ)	:	kdgraph_map_rb_map.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					graph.h					\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_st.h				\
+					dgraph.h				\
+					dmapping.h				\
+					bdgraph.h				\
+					bdgraph_bipart_st.h			\
+					kdgraph.h				\
+					kdgraph_map_rb.h			\
+					kdgraph_map_rb_map.h			\
+					kdgraph_map_st.h
+
+kdgraph_map_rb_part$(OBJ)	:	kdgraph_map_rb_part.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					graph.h					\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_st.h				\
+					dgraph.h				\
+					dmapping.h				\
+					bdgraph.h				\
+					bdgraph_bipart_st.h			\
+					kdgraph.h				\
+					kdgraph_map_rb.h			\
+					kdgraph_map_rb_part.h			\
+					kdgraph_map_st.h
+
+kdgraph_map_st$(OBJ)		:	kdgraph_map_st.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					graph.h					\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					mapping.h				\
+					dmapping.h				\
+					bdgraph.h				\
+					bdgraph_bipart_st.h			\
+					kgraph.h				\
+					kgraph_map_st.h				\
+					kdgraph.h				\
+					kdgraph_map_rb.h			\
+					kdgraph_map_st.h
+
+kgraph$(OBJ)			:	kgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h
+
+kgraph_band$(OBJ)		:	kgraph_band.c		   		\
+					module.h				\
+					common.h				\
+					arch.h					\
+					graph.h			        	\
+					mapping.h				\
+					kgraph.h
+
+kgraph_check$(OBJ)		:	kgraph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h
+
+kgraph_map_bd$(OBJ)		:	kgraph_map_bd.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_bd.h
+
+kgraph_map_cp$(OBJ)		:	kgraph_map_cp.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_cp.h
+
+kgraph_map_df$(OBJ)		:	kgraph_map_df.c				\
+					kgraph_map_df_loop.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_df.h
+
+kgraph_map_ex$(OBJ)		:	kgraph_map_ex.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_ex.h
+
+kgraph_map_fm$(OBJ)		:	kgraph_map_fm.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_fm.h                         \
+					kgraph_map_rb.h
+
+kgraph_map_ml$(OBJ)		:	kgraph_map_ml.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_ml.h
+
+kgraph_map_rb$(OBJ)		:	kgraph_map_rb.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					kgraph.h				\
+					kgraph_map_rb.h				\
+					kgraph_map_rb_map.h			\
+					kgraph_map_rb_part.h
+
+kgraph_map_rb_map$(OBJ)		:	kgraph_map_rb_map.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					kgraph.h				\
+					kgraph_map_rb.h				\
+					kgraph_map_rb_map.h
+
+kgraph_map_rb_part$(OBJ)	:	kgraph_map_rb_part.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					kgraph.h				\
+					kgraph_map_rb.h				\
+					kgraph_map_rb_part.h
+
+kgraph_map_st$(OBJ)		:	kgraph_map_st.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					kgraph.h				\
+					kgraph_map_bd.h				\
+					kgraph_map_cp.h				\
+					kgraph_map_df.h				\
+					kgraph_map_fm.h				\
+					kgraph_map_ml.h				\
+					kgraph_map_rb.h
+
+kgraph_store$(OBJ)		:	kgraph_store.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h
+
+library_arch$(OBJ)		:	library_arch.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					arch_cmplt.h				\
+					scotch.h
+
+library_arch_f$(OBJ)		:	library_arch_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_arch_build$(OBJ)	:	library_arch_build.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					arch_build.h				\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					scotch.h
+
+library_arch_build_f$(OBJ)	:	library_arch_build_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_common_f$(OBJ)		:	library_common_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_dgraph$(OBJ)		:	library_dgraph.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_f$(OBJ)		:	library_dgraph_f.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_band$(OBJ)	:	library_dgraph_band.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_band_f$(OBJ)	:	library_dgraph_band_f.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_build$(OBJ)	:	library_dgraph_build.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_build_f$(OBJ)	:	library_dgraph_build_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_build_grid3d$(OBJ):	library_dgraph_build_grid3d.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_build_grid3d_f$(OBJ):	library_dgraph_build_grid3d_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_check$(OBJ)	:	library_dgraph_check.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_check_f$(OBJ)	:	library_dgraph_check_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_coarsen$(OBJ)	:	library_dgraph_coarsen.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					ptscotch.h
+
+library_dgraph_coarsen_f$(OBJ)	:	library_dgraph_coarsen_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_gather$(OBJ)	:	library_dgraph_gather.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_gather_f$(OBJ)	:	library_dgraph_gather_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_grow$(OBJ)	:	library_dgraph_grow.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_halo$(OBJ)	:	library_dgraph_halo.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dgraph_halo.h				\
+					ptscotch.h
+
+library_dgraph_halo_f$(OBJ)	:	library_dgraph_halo_f.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_induce$(OBJ)	:	library_dgraph_induce.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_induce_f$(OBJ)	:	library_dgraph_induce_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_io_load$(OBJ)	:	library_dgraph_io_load.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_io_load_f$(OBJ)	:	library_dgraph_io_load_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_io_save$(OBJ)	:	library_dgraph_io_save.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_io_save_f$(OBJ)	:	library_dgraph_io_save_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_map$(OBJ)	:	library_dgraph_map.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					arch.h					\
+					dgraph.h				\
+					dmapping.h				\
+					kdgraph.h				\
+					kdgraph_map_st.h			\
+					library_dmapping.h			\
+					ptscotch.h
+
+library_dgraph_map_f$(OBJ)	:	library_dgraph_map_f.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_map_view$(OBJ)	:	library_dgraph_map_view.c		\
+					module.h				\
+					common.h				\
+					parser.h				\
+					dgraph.h				\
+					dgraph_halo.h				\
+					arch.h					\
+					dmapping.h				\
+					kdgraph.h				\
+					library_dmapping.h			\
+					ptscotch.h
+
+library_dgraph_map_view_f$(OBJ)	:	library_dgraph_map_view_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order$(OBJ)	:	library_dgraph_order.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					dgraph.h				\
+					dorder.h				\
+					hdgraph.h				\
+					hdgraph_order_st.h			\
+					ptscotch.h
+
+library_dgraph_order_f$(OBJ)	:	library_dgraph_order_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order_gather$(OBJ):	library_dgraph_order_gather.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					order.h					\
+					dorder.h				\
+					library_order.h				\
+					ptscotch.h
+
+library_dgraph_order_gather_f$(OBJ):	library_dgraph_order_gather_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order_io$(OBJ)	:	library_dgraph_order_io.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					ptscotch.h
+
+library_dgraph_order_io_f$(OBJ)	:	library_dgraph_order_io_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order_io_block$(OBJ):	library_dgraph_order_io_block.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					ptscotch.h
+
+library_dgraph_order_io_block_f$(OBJ):	library_dgraph_order_io_block_f.c	\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order_perm$(OBJ)	:	library_dgraph_order_perm.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					ptscotch.h
+
+library_dgraph_order_perm_f$(OBJ):	library_dgraph_order_perm_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_order_tree_dist$(OBJ):	library_dgraph_order_tree_dist.c	\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h				\
+					ptscotch.h
+
+library_dgraph_order_tree_dist_f$(OBJ):	library_dgraph_order_tree_dist_f.c	\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_redist$(OBJ)	:	library_dgraph_redist.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_redist_f$(OBJ)	:	library_dgraph_redist_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_scatter$(OBJ)	:	library_dgraph_scatter.c		\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h
+
+library_dgraph_scatter_f$(OBJ)	:	library_dgraph_scatter_f.c		\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dgraph_stat$(OBJ)	:	library_dgraph_stat.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					ptscotch.h				\
+					library_dgraph_stat.h
+
+library_dgraph_stat_f$(OBJ)	:	library_dgraph_stat_f.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dmapping$(OBJ)		:	library_dmapping.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_dorder$(OBJ)		:	library_dorder.c			\
+					module.h				\
+					common.h				\
+					ptscotch.h
+
+library_error$(OBJ)		:	library_error.c				\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_error_exit$(OBJ)	:	library_error_exit.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_error_pt$(OBJ)		:	library_error.c				\
+					module.h				\
+					common.h				\
+					scotch.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -o $(@)
+
+library_error_exit_pt$(OBJ)	:	library_error_exit.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+					$(CC) $(CFLAGS) $(CLIBFLAGS) -c $(<) -o $(@)
+
+library_geom$(OBJ)		:	library_geom.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					scotch.h
+
+library_geom_f$(OBJ)		:	library_geom_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph$(OBJ)		:	library_graph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_io.h				\
+					scotch.h
+
+library_graph_f$(OBJ)		:	library_graph_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_base$(OBJ)	:	library_graph_base.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					scotch.h
+
+library_graph_base_f$(OBJ)	:	library_graph_base_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_check$(OBJ)	:	library_graph_check.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					scotch.h
+
+library_graph_check_f$(OBJ)	:	library_graph_check_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_coarsen$(OBJ)	:	library_graph_coarsen.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					scotch.h
+
+library_graph_coarsen_f$(OBJ)	:	library_graph_coarsen_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_color$(OBJ)	:	library_graph_color.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					scotch.h
+
+library_graph_color_f$(OBJ)	:	library_graph_color_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_io_chac$(OBJ)	:	library_graph_io_chac.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					scotch.h
+
+library_graph_io_chac_f$(OBJ)	:	library_graph_io_chac_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_io_habo$(OBJ)	:	library_graph_io_habo.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					scotch.h
+
+library_graph_io_habo_f$(OBJ)	:	library_graph_io_habo_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_io_mmkt$(OBJ)	:	library_graph_io_mmkt.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					scotch.h
+
+library_graph_io_mmkt_f$(OBJ)	:	library_graph_io_mmkt_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_io_scot$(OBJ)	:	library_graph_io_scot.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					scotch.h
+
+library_graph_io_scot_f$(OBJ)	:	library_graph_io_scot_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_map$(OBJ)		:	library_graph_map.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					kgraph_map_st.h				\
+					library_mapping.h			\
+					scotch.h
+
+library_graph_map_f$(OBJ)	:	library_graph_map_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_map_io$(OBJ)	:	library_graph_map_io.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					library_mapping.h			\
+					library_graph_map_io.h			\
+					scotch.h
+
+library_graph_map_io_f$(OBJ)	:	library_graph_map_io_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_map_view$(OBJ)	:	library_graph_map_view.c		\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					kgraph.h				\
+					library_mapping.h			\
+					library_graph_map_view.h		\
+					scotch.h
+
+library_graph_map_view_f$(OBJ)	:	library_graph_map_view_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_order$(OBJ)	:	library_graph_order.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					order.h					\
+					hgraph.h				\
+					hgraph_order_st.h			\
+					library_order.h				\
+					scotch.h
+
+library_graph_order_f$(OBJ)	:	library_graph_order_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_graph_part_ovl$(OBJ)	:	library_graph_part_ovl.c		\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					wgraph.h				\
+					wgraph_part_st.h			\
+					scotch.h
+
+library_graph_part_ovl_f$(OBJ)	:	library_graph_part_ovl_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mapping$(OBJ)		:	library_mapping.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mesh$(OBJ)		:	library_mesh.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					scotch.h
+
+library_mesh_f$(OBJ)		:	library_mesh_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mesh_graph$(OBJ)	:	library_mesh_graph.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					scotch.h
+
+library_mesh_graph_f$(OBJ)	:	library_mesh_graph_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mesh_io_habo$(OBJ)	:	library_mesh_io_habo.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					mesh.h					\
+					scotch.h
+
+library_mesh_io_habo_f$(OBJ)	:	library_mesh_io_habo_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mesh_io_scot$(OBJ)	:	library_mesh_io_scot.c			\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					mesh.h					\
+					scotch.h
+
+library_mesh_io_scot_f$(OBJ)	:	library_mesh_io_scot_f.c		\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_mesh_order$(OBJ)	:	library_mesh_order.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					mesh.h					\
+					hmesh.h					\
+					order.h					\
+					hmesh_order_st.h			\
+					scotch.h				\
+					library_order.h
+
+library_mesh_order_f$(OBJ)	:	library_mesh_order_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_order$(OBJ)		:	library_order.c				\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_parser$(OBJ)		:	library_parser.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					scotch.h
+
+library_parser_f$(OBJ)		:	library_parser_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_random$(OBJ)		:	library_random.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_random_f$(OBJ)		:	library_random_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_strat$(OBJ)		:	library_strat.c				\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_version$(OBJ)		:	library_version.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+library_version_f$(OBJ)		:	library_version_f.c			\
+					module.h				\
+					common.h				\
+					scotch.h
+
+mapping$(OBJ)			:	mapping.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h
+
+mapping_io$(OBJ)		:	mapping_io.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					mapping_io.h
+
+mesh$(OBJ)			:	mesh.c					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h
+
+mesh_check$(OBJ)		:	mesh_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h
+
+mesh_coarsen$(OBJ)		:	mesh_coarsen.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h
+
+mesh_graph$(OBJ)		:	mesh_graph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					mesh_graph.h
+
+mesh_induce_sepa$(OBJ)		:	mesh_induce_sepa.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					mesh_induce_sepa.h
+
+mesh_io$(OBJ)			:	mesh_io.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					graph_io.h				\
+					mesh.h					\
+					mesh_io.h
+
+mesh_io_habo$(OBJ)		:	mesh_io_habo.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					mesh.h
+
+mesh_io_scot$(OBJ)		:	mesh_io_scot.c				\
+					module.h				\
+					common.h				\
+					geom.h					\
+					graph.h					\
+					mesh.h
+
+order$(OBJ)			:	order.c					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h
+
+order_check$(OBJ)		:	order_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h
+
+order_io$(OBJ)			:	order_io.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h
+
+order_tree$(OBJ)		:	order_tree.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					order.h
+
+parser$(OBJ)			:	parser.c				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					parser_yy.h
+
+parser_ll.c			:	parser_ll.l				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					parser_ll.h				\
+					parser_ly.h
+					($(LEX) parser_ll.l &&			\
+					 $(MV) lex.yy.c parser_ll.c) ||		\
+					$(CP) last_resort/parser_ll.c . 
+
+parser_ll$(OBJ)			:	parser_ll.c				\
+					parser_ly.h
+
+parser_ly.h			:	parser_yy$(OBJ)
+
+parser_yy.c			:	parser_yy.y				\
+					module.h				\
+					common.h				\
+					parser.h				\
+					parser_yy.h
+					($(YACC) -d -v parser_yy.y &&		\
+					 $(MV) y.tab.c parser_yy.c &&		\
+					 $(MV) y.tab.h parser_ly.h) ||		\
+					$(CP) last_resort/parser_ly.h last_resort/parser_yy.c .
+
+parser_yy$(OBJ)			:	parser_yy.c
+
+vdgraph$(OBJ)			:	vdgraph.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					vdgraph.h
+
+vdgraph_check$(OBJ)		:	vdgraph_check.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					vdgraph.h
+
+vdgraph_gather_all$(OBJ)	:	vdgraph_gather_all.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					graph.h					\
+					vgraph.h				\
+					dgraph.h				\
+					vdgraph.h
+
+vdgraph_separate_bd$(OBJ)	:	vdgraph_separate_bd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					dgraph.h				\
+					vdgraph.h				\
+					vdgraph_separate_bd.h			\
+					vdgraph_separate_st.h
+
+vdgraph_separate_df$(OBJ)	:	vdgraph_separate_df.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					vdgraph.h				\
+					vdgraph_separate_df.h
+
+vdgraph_separate_ml$(OBJ)	:	vdgraph_separate_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					vdgraph.h				\
+					vdgraph_separate_ml.h			\
+					vdgraph_separate_st.h
+
+vdgraph_separate_sq$(OBJ)	:	vdgraph_separate_sq.c			\
+					module.h				\
+					common.h				\
+					comm.h					\
+					parser.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_st.h			\
+					dgraph.h				\
+					vdgraph.h				\
+					vdgraph_separate_sq.h
+
+vdgraph_separate_st$(OBJ)	:	vdgraph_separate_st.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_st.h			\
+					dgraph.h				\
+					dgraph_coarsen.h			\
+					vdgraph.h				\
+					vdgraph_separate_bd.h			\
+					vdgraph_separate_df.h			\
+					vdgraph_separate_ml.h			\
+					vdgraph_separate_sq.h			\
+					vdgraph_separate_st.h			\
+					vdgraph_separate_zr.h
+
+vdgraph_separate_zr$(OBJ)	:	vdgraph_separate_zr.c			\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					vdgraph.h				\
+					vdgraph_separate_zr.h
+
+vdgraph_store$(OBJ)		:	vdgraph_store.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					vdgraph.h
+
+vgraph$(OBJ)			:	vgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h
+
+vgraph_check$(OBJ)		:	vgraph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h
+
+vgraph_separate_bd$(OBJ)	:	vgraph_separate_bd.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_bd.h			\
+					vgraph_separate_st.h
+
+vgraph_separate_df$(OBJ)	:	vgraph_separate_df.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_df.h
+
+vgraph_separate_es$(OBJ)	:	vgraph_separate_es.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					vgraph.h				\
+					vgraph_separate_es.h
+
+vgraph_separate_fm$(OBJ)	:	vgraph_separate_fm.c			\
+					module.h				\
+					common.h				\
+					gain.h					\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_gg.h			\
+					vgraph_separate_fm.h
+
+vgraph_separate_gg$(OBJ)	:	vgraph_separate_gg.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_gg.h
+
+vgraph_separate_gp$(OBJ)	:	vgraph_separate_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_gp.h
+
+vgraph_separate_ml$(OBJ)	:	vgraph_separate_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					vgraph.h				\
+					vgraph_separate_ml.h			\
+					vgraph_separate_st.h
+
+vgraph_separate_th$(OBJ)	:	vgraph_separate_th.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_th.h
+
+vgraph_separate_vw$(OBJ)	:	vgraph_separate_vw.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_vw.h
+
+vgraph_separate_zr$(OBJ)	:	vgraph_separate_zr.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_zr.h
+
+vgraph_separate_st$(OBJ)	:	vgraph_separate_st.c			\
+					gain.h					\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					arch.h					\
+					mapping.h				\
+					bgraph.h				\
+					bgraph_bipart_st.h			\
+					vgraph.h				\
+					vgraph_separate_bd.h			\
+					vgraph_separate_df.h			\
+					vgraph_separate_fm.h			\
+					vgraph_separate_gg.h			\
+					vgraph_separate_gp.h			\
+					vgraph_separate_ml.h			\
+					vgraph_separate_th.h			\
+					vgraph_separate_vw.h			\
+					vgraph_separate_zr.h			\
+					vgraph_separate_st.h
+
+vgraph_store$(OBJ)		:	vgraph_store.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					vgraph.h
+
+vmesh$(OBJ)			:	vmesh.c					\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h
+
+vmesh_check$(OBJ)		:	vmesh_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h
+
+vmesh_separate_fm$(OBJ)		:	vmesh_separate_fm.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h					\
+					vmesh_separate_fm.h
+
+vmesh_separate_gg$(OBJ)		:	vmesh_separate_gg.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h					\
+					vmesh_separate_gg.h
+
+vmesh_separate_gr$(OBJ)		:	vmesh_separate_gr.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					vgraph.h				\
+					vgraph_separate_st.h			\
+					mesh.h					\
+					vmesh.h					\
+					vmesh_separate_gr.h
+
+vmesh_separate_ml$(OBJ)		:	vmesh_separate_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					mesh.h					\
+					mesh_coarsen.h				\
+					vmesh.h					\
+					vmesh_separate_ml.h			\
+					vmesh_separate_st.h
+
+vmesh_separate_zr$(OBJ)		:	vmesh_separate_zr.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h					\
+					vmesh_separate_zr.h
+
+vmesh_separate_st$(OBJ)		:	vmesh_separate_st.c			\
+					gain.h					\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					mesh.h					\
+					mesh_coarsen.h				\
+					vmesh.h					\
+					vmesh_separate_fm.h			\
+					vmesh_separate_gg.h			\
+					vmesh_separate_gr.h			\
+					vmesh_separate_ml.h			\
+					vmesh_separate_zr.h			\
+					vmesh_separate_st.h
+
+vmesh_store$(OBJ)		:	vmesh_store.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					mesh.h					\
+					vmesh.h
+
+wgraph$(OBJ)			:	wgraph.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h
+
+wgraph_check$(OBJ)		:	wgraph_check.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h
+
+wgraph_part_fm$(OBJ)		:	wgraph_part_fm.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h				\
+					wgraph_part_fm.h
+
+wgraph_part_gg$(OBJ)		:	wgraph_part_gg.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h				\
+					wgraph_part_gg.h
+
+wgraph_part_gp$(OBJ)		:	wgraph_part_gp.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h				\
+					wgraph_part_gp.h
+
+wgraph_part_ml$(OBJ)		: 	wgraph_part_ml.c			\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					wgraph.h				\
+					wgraph_part_ml.h			\
+					wgraph_part_st.h
+
+wgraph_part_rb$(OBJ)		:	wgraph_part_rb.c			\
+					module.h				\
+					common.h                                \
+					parser.h                                \
+					graph.h                                 \
+					arch.h                                  \
+					mapping.h                               \
+					vgraph.h                                \
+					vgraph_separate_st.h                    \
+					vgraph_separate_zr.h                    \
+					wgraph.h                                \
+					wgraph_part_rb.h
+
+wgraph_part_st$(OBJ)		:	wgraph_part_st.c			\
+					gain.h					\
+					module.h				\
+					common.h				\
+					parser.h				\
+					graph.h					\
+					graph_coarsen.h				\
+					vgraph.h				\
+					vgraph_separate_st.h			\
+					wgraph.h				\
+					wgraph_part_fm.h			\
+					wgraph_part_gg.h			\
+					wgraph_part_gp.h			\
+					wgraph_part_ml.h			\
+					wgraph_part_rb.h			\
+					wgraph_part_zr.h			\
+					wgraph_part_st.h
+
+wgraph_part_zr$(OBJ)		: 	wgraph_part_zr.c			\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h				\
+					wgraph_part_zr.h
+
+wgraph_store$(OBJ)		:	wgraph_store.c				\
+					module.h				\
+					common.h				\
+					graph.h					\
+					wgraph.h
+
+dummysizes$(EXE)		:	dummysizes.c				\
+					module.h				\
+					common.h				\
+					arch.h					\
+					graph.h					\
+					geom.h					\
+					mesh.h					\
+					mapping.h				\
+					order.h					\
+					parser.h
+			 		$(CCD) $(CFLAGS) -DSCOTCH_VERSION=$(VERSION) -DSCOTCH_RELEASE=$(RELEASE) -DSCOTCH_PATCHLEVEL=$(PATCHLEVEL) $(<) -o $(@) $(LDFLAGS)
+
+ptdummysizes$(EXE)		:	dummysizes.c				\
+					module.h				\
+					common.h				\
+					dgraph.h				\
+					dorder.h
+			 		$(CCD) $(CFLAGS) -DSCOTCH_VERSION=$(VERSION) -DSCOTCH_RELEASE=$(RELEASE) -DSCOTCH_PATCHLEVEL=$(PATCHLEVEL) $(<) -o $(@) $(LDFLAGS)
+
+scotch.h			:	dummysizes$(EXE)			\
+					library.h
+					./dummysizes$(EXE) library.h scotch.h
+
+scotchf.h			:	dummysizes$(EXE) 			\
+					library_f.h
+					./dummysizes$(EXE) library_f.h scotchf.h
+
+ptscotch.h			:	ptdummysizes$(EXE)			\
+					library_pt.h
+					./ptdummysizes$(EXE) library_pt.h ptscotch.h
+
+ptscotchf.h			:	ptdummysizes$(EXE)			\
+					library_pt_f.h
+					./ptdummysizes$(EXE) library_pt_f.h ptscotchf.h
+
+libscotch$(LIB)			:	$(LIBSCOTCHDEPS)
+					$(AR) $(ARFLAGS) $(@) $(?) $(LDFLAGS)
+					-$(RANLIB) $(@)
+
+libscotcherr$(LIB)		:	library_error$(OBJ)
+					$(AR) $(ARFLAGS) $(@) $(?)
+					-$(RANLIB) $(@)
+
+libscotcherrexit$(LIB)		:	library_error_exit$(OBJ)
+					$(AR) $(ARFLAGS) $(@) $(?)
+					-$(RANLIB) $(@)
+
+libptscotch$(LIB)		:	$(LIBPTSCOTCHDEPS)
+					$(AR) $(ARFLAGS) $(@) $(?)
+					-$(RANLIB) $(@)
+
+libptscotcherr$(LIB)		:	library_error_pt$(OBJ)
+					$(AR) $(ARFLAGS) $(@) $(?)
+					-$(RANLIB) $(@)
+
+libptscotcherrexit$(LIB)	:	library_error_exit_pt$(OBJ)
+					$(AR) $(ARFLAGS) $(@) $(?)
+					-$(RANLIB) $(@)
--- extra/scotch/src/libscotch/common.h	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/libscotch/common.h	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,429 @@
+/* Copyright 2004,2007-2012 IPB, Universite de Bordeaux, INRIA & CNRS
+**
+** This file is part of the Scotch software package for static mapping,
+** graph partitioning and sparse matrix ordering.
+**
+** This software is governed by the CeCILL-C license under French law
+** and abiding by the rules of distribution of free software. You can
+** use, modify and/or redistribute the software under the terms of the
+** CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
+** URL: "http://www.cecill.info".
+** 
+** As a counterpart to the access to the source code and rights to copy,
+** modify and redistribute granted by the license, users are provided
+** only with a limited warranty and the software's author, the holder of
+** the economic rights, and the successive licensors have only limited
+** liability.
+** 
+** In this respect, the user's attention is drawn to the risks associated
+** with loading, using, modifying and/or developing or reproducing the
+** software by the user in light of its specific status of free software,
+** that may mean that it is complicated to manipulate, and that also
+** therefore means that it is reserved for developers and experienced
+** professionals having in-depth computer knowledge. Users are therefore
+** encouraged to load and test the software's suitability as regards
+** their requirements in conditions enabling the security of their
+** systems and/or data to be ensured and, more generally, to use and
+** operate it in the same conditions as regards security.
+** 
+** The fact that you are presently reading this means that you have had
+** knowledge of the CeCILL-C license and that you accept its terms.
+*/
+/************************************************************/
+/**                                                        **/
+/**   NAME       : common.h                                **/
+/**                                                        **/
+/**   AUTHORS    : Francois PELLEGRINI                     **/
+/**                David GOUDIN                            **/
+/**                Pascal HENON                            **/
+/**                Pierre RAMET                            **/
+/**                Cedric CHEVALIER (v5.0)                 **/
+/**                Sebastien FOURESTIER (v6.0)             **/
+/**                                                        **/
+/**   FUNCTION   : Part of a parallel direct block solver. **/
+/**                These lines are the common data         **/
+/**                declarations for all modules.           **/
+/**                                                        **/
+/**   DATES      : # Version 0.0  : from : 08 may 1998     **/
+/**                                 to   : 08 jan 2001     **/
+/**                # Version 1.0  : from : 06 jun 2002     **/
+/**                                 to   : 06 jun 2002     **/
+/**                # Version 2.0  : from : 13 jun 2005     **/
+/**                                 to   : 01 jul 2008     **/
+/**                # Version 5.1  : from : 09 nov 2008     **/
+/**                                 to   : 23 nov 2010     **/
+/**                # Version 6.0  : from : 03 mar 2011     **/
+/**                                 to     24 nov 2012     **/
+/**                                                        **/
+/************************************************************/
+
+#define COMMON_H
+
+/*
+** The includes.
+*/
+
+#ifndef _XOPEN_SOURCE
+#define _XOPEN_SOURCE               600
+#endif /* _XOPEN_SOURCE */
+#ifndef __USE_XOPEN2K
+#define __USE_XOPEN2K                             /* For POSIX pthread_barrier_t */
+#endif /* __USE_XOPEN2K */
+
+#include            <ctype.h>
+#include            <math.h>
+#include            <memory.h>
+#include            <stdio.h>
+#include            <stdarg.h>
+#include            <stdlib.h>
+#if (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_STDINT_H))
+#include            <stdint.h>
+#endif /* (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_STDINT_H)) */
+#ifdef HAVE_MALLOC_H
+#include            <malloc.h>                    /* Deprecated, but required on some old systems */
+#endif /* HAVE_MALLOC_H */
+#include            <string.h>
+#include            <strings.h>
+#include            <time.h>                      /* For the effective calls to clock () */
+#include            <limits.h>
+#include            <float.h>
+#include            <sys/types.h>
+#if ((defined COMMON_TIMING_OLD) || (defined HAVE_SYS_TIME_H))
+#include            <sys/time.h>
+#endif /* ((defined COMMON_TIMING_OLD) || (defined HAVE_SYS_TIME_H)) */
+#if ((defined COMMON_TIMING_OLD) || (defined HAVE_SYS_RESOURCE_H))
+#include            <sys/resource.h>
+#endif /* ((defined COMMON_TIMING_OLD) || (defined HAVE_SYS_RESOURCE_H)) */
+#if ((defined COMMON_WINDOWS) || (defined HAVE_WINDOWS_H))
+#include            <windows.h>
+#include            <stdint.h>
+typedef uint32_t u_int32_t;
+#endif /* ((defined COMMON_WINDOWS) || (defined HAVE_WINDOWS_H)) */
+#if ((! defined COMMON_WINDOWS) && (! defined HAVE_NOT_UNISTD_H))
+#include            <unistd.h>
+#endif /* ((! defined COMMON_WINDOWS) && (! defined HAVE_NOT_UNISTD_H)) */
+
+#ifdef SCOTCH_PTSCOTCH
+#include            <mpi.h>
+#endif /* SCOTCH_PTSCOTCH */
+
+#if ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD))
+#include            <pthread.h>
+#endif /* ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD)) */
+
+/*
+**  Working definitions.
+*/
+
+#ifdef COMMON_MEMORY_TRACE
+#define memAlloc(size)              memAllocRecord ((size) | 8)
+#define memRealloc(ptr,size)        memReallocRecord ((ptr), ((size) | 8))
+#define memFree(ptr)                (memFreeRecord ((void *) (ptr)), 0)
+#else /* COMMON_MEMORY_TRACE */
+#define memAlloc(size)              malloc ((size) | 8) /* For platforms which return NULL for malloc(0) */
+#define memRealloc(ptr,size)        realloc ((ptr),((size) | 8))
+#define memFree(ptr)                (free ((char *) (ptr)), 0)
+#endif /* COMMON_MEMORY_TRACE */
+
+#define memSet(ptr,val,siz)         memset ((void *) (ptr), (val), (siz))
+#define memCpy(dst,src,siz)         memcpy ((void *) (dst), (void *) (src), (siz))
+#define memMov(dst,src,siz)         memmove ((void *) (dst), (void *) (src), (siz))
+
+#define MIN(x,y)                    (((x) < (y)) ? (x) : (y))
+#define MAX(x,y)                    (((x) < (y)) ? (y) : (x))
+#define ABS(x)                      MAX ((x), -(x))
+#define SIGN(x)                     (((x) < 0) ? -1 : 1)
+
+/*
+**  Handling of generic types.
+*/
+
+#if (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T))
+#define UINT32                      uint32_t
+#else /* (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T)) */
+#define UINT32                      u_int32_t
+#endif /* (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T)) */
+
+#ifndef INT                                       /* If type not externally overriden */
+#ifdef INTSIZE32
+#define INT                         int32_t
+#define UINT                        UINT32
+#define COMM_INT                    MPI_INTEGER4
+#define INTSTRING                   "%d"
+#else /* INTSIZE32 */
+#ifdef INTSIZE64
+#define INT                         int64_t
+#if (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T))
+#define UINT                        uint64_t
+#else /* (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T)) */
+#define UINT                        u_int64_t
+#endif /* (((defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined HAVE_UINT_T)) */
+#define COMM_INT                    MPI_LONG_LONG
+#define INTSTRING                   "%lld"
+#else /* INTSIZE64 */
+#ifdef LONG                                       /* Better not use it */
+#define INT                         long          /* Long integer type */
+#define UINT                        unsigned long
+#define COMM_INT                    MPI_LONG
+#define INTSTRING                   "%ld"
+#else /* LONG */
+#define INT                         int           /* Default integer type */
+#define UINT                        unsigned int
+#define COMM_INT                    MPI_INT       /* Generic MPI integer type */
+#define INTSTRING                   "%d"
+#endif /* LONG      */
+#endif /* INTSIZE64 */
+#endif /* INTSIZE32 */
+#endif /* INT       */
+
+#ifndef IDX                                       /* If type not externally overriden */
+#ifdef IDXSIZE32
+#define IDX                         int32_t
+#else /* IDXSIZE32 */
+#ifdef IDXSIZE64
+#define IDX                         int64_t
+#else /* IDXSIZE64 */
+#define IDX                         INT
+#endif /* IDXSIZE64 */
+#endif /* IDXSIZE32 */
+#endif /* IDX       */
+
+#ifndef INTSIZEBITS
+#define INTSIZEBITS                 (sizeof (INT) << 3)
+#endif /* INTSIZEBITS */
+
+#define INTVALMAX                   ((INT) (((UINT) 1 << (INTSIZEBITS - 1)) - 1))
+
+#define byte unsigned char                        /* Byte type */
+#ifndef BYTE
+#define BYTE                        byte
+#endif /* BYTE */
+#ifndef COMM_BYTE
+#define COMM_BYTE                   MPI_BYTE
+#endif /* COMM_BYTE */
+#define COMM_PART                   COMM_BYTE
+
+/*
+**  Handling of pseudo-random numbers.
+*/
+
+/* The pseudo-random state structure. It is
+   based on a Mersenne twister generator, also
+   referred to as MT19937. */
+
+typedef struct IntRandState_ {
+  UINT32                    randtab[624];         /* State vector */
+  int                       randnum;              /* Index value  */
+} IntRandState;
+
+/*
+**  Handling of flag arrays.
+*/
+
+#define flagSize(n)                 (((n) + (sizeof (int) << 3) - 1) / (sizeof (int) << 3))
+#define flagVal(a,n)                (((a)[(n) / (sizeof (int) << 3)] >> ((n) & ((sizeof (int) << 3) - 1))) & 1)
+#define flagSet(a,n)                (a)[(n) / (sizeof (int) << 3)] |= (1 << ((n) & ((sizeof (int) << 3) - 1)))
+
+/*
+**  Handling of timers.
+*/
+
+/** The clock type. **/
+
+typedef struct Clock_ {
+  double                    time[2];              /*+ The start and accumulated times +*/
+} Clock;
+
+/*
+**  Handling of threads.
+*/
+
+/** The thread creation flags **/
+
+#define THREADNONE                  0x0000        /* Thread capabilities */
+
+#define THREADHASBARRIER            0x0001
+
+#define THREADCANBARRIER            THREADHASBARRIER
+#define THREADCANSCAN               THREADHASBARRIER
+#define THREADCANREDUCE             THREADHASBARRIER
+
+/** The thread barrier structure and routines **/
+
+#ifdef COMMON_PTHREAD_BARRIER
+
+#ifndef PTHREAD_BARRIER_SERIAL_THREAD
+#define PTHREAD_BARRIER_SERIAL_THREAD -1
+#endif /* PTHREAD_BARRIER_SERIAL_THREAD */
+
+typedef struct ThreadBarrier_ {
+  int                       thrdnbr;              /*+ Number of threads to wait for       +*/
+  volatile int              thrdcur;              /*+ Number of threads currently blocked +*/
+  volatile int              instnum;              /*+ Number of barrier instance          +*/
+  pthread_mutex_t           mutedat;
+  pthread_cond_t            conddat;
+} ThreadBarrier;
+
+int                         threadBarrierDestroy (ThreadBarrier *);
+int                         threadBarrierInit   (ThreadBarrier *, void *, int); /* Thread attribute not used */
+int                         threadBarrierWait   (ThreadBarrier *);
+
+#else /* COMMON_PTHREAD_BARRIER */
+
+#define ThreadBarrier               pthread_barrier_t
+
+#define threadBarrierDestroy        pthread_barrier_destroy
+#define threadBarrierInit           pthread_barrier_init
+#define threadBarrierWait           pthread_barrier_wait
+
+#endif /* COMMON_PTHREAD_BARRIER */
+
+#define threadBarrier(t)            threadBarrierWait (&(((ThreadGroupHeader *) (((ThreadHeader *) (void *) (t))->grouptr))->barrdat))
+
+/** The thread service routines auxiliary function types **/
+
+typedef int (* ThreadLaunchJoinFunc) (void * const, void * const);
+typedef int (* ThreadLaunchStartFunc) (void * const);
+typedef void (* ThreadReduceFunc) (void * const, void * const, void * const);
+typedef void (* ThreadScanFunc)   (void * const, void * const, void * const, const int);
+
+/** The thread group header block. **/
+
+typedef struct ThreadGroupHeader_ {
+#if ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD))
+  int                       flagval;              /*+ Thread block flags       +*/
+  size_t                    datasiz;              /*+ Size of data array cell  +*/
+  int                       thrdnbr;              /*+ Number of threads        +*/
+  ThreadLaunchStartFunc     stafptr;              /*+ Pointer to start routine +*/
+  ThreadLaunchJoinFunc      joifptr;              /*+ Pointer to join routine  +*/
+  ThreadBarrier             barrdat;              /*+ Barrier data structure   +*/
+#endif /* ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD)) */
+} ThreadGroupHeader;
+
+/** The thread header block. **/
+
+typedef struct ThreadHeader_ {
+  void *                    grouptr;              /*+ Pointer to thread group +*/
+#if ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD))
+  pthread_t                 thidval;              /*+ Thread ID               +*/
+  int                       thrdnum;              /*+ Thread instance number  +*/
+#endif /* ((defined COMMON_PTHREAD) || (defined SCOTCH_PTHREAD)) */
+} ThreadHeader;
+
+/** The number of threads **/
+
+#ifdef SCOTCH_PTHREAD
+
+#ifndef SCOTCH_PTHREAD_NUMBER
+#define SCOTCH_PTHREAD_NUMBER       1
+#endif /* SCOTCH_PTHREAD_NUMBER */
+
+#else /* SCOTCH_PTHREAD */
+
+#ifdef SCOTCH_PTHREAD_NUMBER
+#undef SCOTCH_PTHREAD_NUMBER
+#endif /* SCOTCH_PTHREAD_NUMBER */
+#define SCOTCH_PTHREAD_NUMBER       1
+
+#endif /* SCOTCH_PTHREAD */
+
+/*
+**  Handling of files.
+*/
+
+/** The file structure. **/
+
+typedef struct File_ {
+  char *                    name;                 /*+ File name    +*/
+  FILE *                    pntr;                 /*+ File pointer +*/
+  char *                    mode;                 /*+ Opening mode +*/
+} File;
+
+/*
+**  Function prototypes.
+*/
+
+void *                      memAllocGroup       (void **, ...);
+void *                      memReallocGroup     (void *, ...);
+void *                      memOffset           (void *, ...);
+#ifdef COMMON_MEMORY_TRACE
+void *                      memAllocRecord      (size_t);
+void *                      memReallocRecord    (void * const, size_t);
+void                        memFreeRecord       (void * const);
+IDX                         memCur              (); /* What is internally an intptr_t has to be turned into an interface type */
+IDX                         memMax              ();
+#endif /* COMMON_MEMORY_TRACE */
+
+void                        usagePrint          (FILE * const, const char (* []));
+
+int                         fileBlockOpen       (File * const, const int);
+int                         fileBlockOpenDist   (File * const, const int, const int, const int, const int);
+void                        fileBlockClose      (File * const, const int);
+FILE *                      fileCompress        (FILE * const, const int);
+int                         fileCompressType    (const char * const);
+FILE *                      fileUncompress      (FILE * const, const int);
+int                         fileUncompressType  (const char * const);
+int                         fileNameDistExpand  (char ** const, const int, const int, const int);
+
+void                        errorProg           (const char * const);
+void                        errorPrint          (const char * const, ...);
+void                        errorPrintW         (const char * const, ...);
+
+int                         intLoad             (FILE * const, INT * const);
+int                         intSave             (FILE * const, const INT);
+void                        intAscn             (INT * const, const INT, const INT);
+void                        intPerm             (INT * const, const INT);
+void                        intRandInit         (void);
+void                        intRandReset        (void);
+void                        intRandSeed         (INT);
+INT                         intRandVal          (INT);
+void                        intSort1asc1        (void * const, const INT);
+void                        intSort2asc1        (void * const, const INT);
+void                        intSort2asc2        (void * const, const INT);
+void                        intSort3asc1        (void * const, const INT);
+void                        intSort3asc2        (void * const, const INT);
+INT                         intSearchDicho      (const INT * const, const INT, const INT, const INT);
+INT                         intGcd              (INT, INT);
+
+void                        clockInit           (Clock * const);
+void                        clockStart          (Clock * const);
+void                        clockStop           (Clock * const);
+double                      clockVal            (Clock * const);
+double                      clockGet            (void);
+
+void                        stringSubst         (char * const, const char * const, const char * const);
+
+#ifdef COMMON_PTHREAD
+int                         threadLaunch        (void * const, void * const, const size_t, int (*) (void *), int (*) (void *, void *), const int, const int);
+void                        threadReduce        (void * const, void * const, ThreadReduceFunc const, const int);
+void                        threadScan          (void * const, void * const, ThreadScanFunc const);
+#endif /* COMMON_PTHREAD */
+
+/*
+**  Macro definitions.
+*/
+
+#define clockInit(clk)              ((clk)->time[0]  = (clk)->time[1] = 0)
+#define clockStart(clk)             ((clk)->time[0]  = clockGet ())
+#define clockStop(clk)              ((clk)->time[1] += (clockGet () - (clk)->time[0]))
+#define clockVal(clk)               ((clk)->time[1])
+
+#define DATASIZE(n,p,i)             ((INT) (((n) + ((p) - 1 - (i))) / (p)))
+#define DATASCAN(n,p,i)             ((i) * ((INT) (n) / (INT) (p)) + (((i) > ((n) % (p))) ? ((n) % (p)) : (i)))
+
+#define FORTRAN(nu,nl,pl,pc)        FORTRAN2(REPLACE(nu),REPLACE(nl),pl,pc)
+#define FORTRAN2(nu,nl,pl,pc)                    \
+void nu pl;                                      \
+void nl pl                                       \
+{ nu pc; }                                       \
+void GLUE(nl,_) pl                               \
+{ nu pc; }                                       \
+void GLUE(nl,__) pl                              \
+{ nu pc; }                                       \
+void nu pl
+
+#define REPLACE(s)                  s
+#define GLUE(p,s)                   p##s
+
+#define STRINGIFY2(n)               #n
+#define STRINGIFY(n)                STRINGIFY2(n)
--- extra/scotch/src/Makefile	(.../tags/2.2.x-2)	(revision 0)
+++ extra/scotch/src/Makefile	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,129 @@
+## Copyright 2004,2007,2008,2010-2012 IPB, Universite de Bordeaux, INRIA & CNRS
+##
+## This file is part of the Scotch software package for static mapping,
+## graph partitioning and sparse matrix ordering.
+##
+## This software is governed by the CeCILL-C license under French law
+## and abiding by the rules of distribution of free software. You can
+## use, modify and/or redistribute the software under the terms of the
+## CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
+## URL: "http://www.cecill.info".
+## 
+## As a counterpart to the access to the source code and rights to copy,
+## modify and redistribute granted by the license, users are provided
+## only with a limited warranty and the software's author, the holder of
+## the economic rights, and the successive licensors have only limited
+## liability.
+## 
+## In this respect, the user's attention is drawn to the risks associated
+## with loading, using, modifying and/or developing or reproducing the
+## software by the user in light of its specific status of free software,
+## that may mean that it is complicated to manipulate, and that also
+## therefore means that it is reserved for developers and experienced
+## professionals having in-depth computer knowledge. Users are therefore
+## encouraged to load and test the software's suitability as regards
+## their requirements in conditions enabling the security of their
+## systems and/or data to be ensured and, more generally, to use and
+## operate it in the same conditions as regards security.
+## 
+## The fact that you are presently reading this means that you have had
+## knowledge of the CeCILL-C license and that you accept its terms.
+##
+
+VERSION	= 6
+RELEASE = 0
+PATCHLEVEL = 0
+
+.PHONY				:	clean	default	install	ptscotch	realclean	required	scotch
+
+default				:	scotch
+
+required			:	Makefile.inc	../bin	../include	../lib
+
+Makefile.inc			:
+					@echo "#####################################################################"
+			        	@echo "BEFORE COMPILING Scotch OR PT-Scotch, YOU SHOULD HAVE AN APPROPRIATE"
+					@echo "Makefile.inc FILE IN THIS DIRECTORY. PLEASE LOOK INTO DIRECTORY"
+	        			@echo " ./Make.inc FOR AN EXISTING Makefile.inc FILE THAT FITS YOUR NEED, OR"
+		        		@echo "USE THEM AS MODELS IN CASE YOU NEED TO BUILD A NEW ONE FOR YOUR"
+		        		@echo "PARTICULAR PLATFORM."
+			        	@echo "#####################################################################"
+			        	@echo "Then, type \"make scotch\" (default) for the sequential library"
+			        	@echo "and software, or \"make ptscotch\" for the parallel library and"
+			        	@echo "software."
+					@exit 1
+
+include Makefile.inc
+
+prefix		?= /usr/local
+bindir		?= $(prefix)/bin
+includedir	?= $(prefix)/include
+libdir		?= $(prefix)/lib
+datarootdir	?= $(prefix)/share
+mandir		?= $(datarootdir)/man
+
+../bin				:
+					-$(MKDIR) ../bin
+
+../include			:
+					-$(MKDIR) ../include
+
+../lib				:
+					-$(MKDIR) ../lib
+
+$(bindir)			:
+					-$(MKDIR) $(bindir)
+
+$(datarootdir)			:
+					-$(MKDIR) $(datarootdir)
+
+$(includedir)			:
+					-$(MKDIR) $(includedir)
+
+$(libdir)			:
+					-$(MKDIR) $(libdir)
+
+$(mandir)			:	$(datarootdir)
+					-$(MKDIR) $(mandir)
+
+$(mandir)/man1			:	$(mandir)
+					-$(MKDIR) $(mandir)/man1
+
+libscotch			:       required
+					(cd libscotch ;      $(MAKE) VERSION=$(VERSION) RELEASE=$(RELEASE) PATCHLEVEL=$(PATCHLEVEL) libscotch)
+
+scotch				:	required
+					(cd libscotch ;      $(MAKE) VERSION=$(VERSION) RELEASE=$(RELEASE) PATCHLEVEL=$(PATCHLEVEL) scotch && $(MAKE) install)
+					(cd scotch ;         $(MAKE) VERSION=$(VERSION) RELEASE=$(RELEASE) PATCHLEVEL=$(PATCHLEVEL) scotch && $(MAKE) install)
+					(cd libscotchmetis ; $(MAKE)                                                                scotch && $(MAKE) install)
+
+ptscotch			:	required
+					(cd libscotch ;      $(MAKE) VERSION=$(VERSION) RELEASE=$(RELEASE) PATCHLEVEL=$(PATCHLEVEL) ptscotch && $(MAKE) ptinstall)
+					(cd scotch ;         $(MAKE) VERSION=$(VERSION) RELEASE=$(RELEASE) PATCHLEVEL=$(PATCHLEVEL) ptscotch && $(MAKE) ptinstall)
+					(cd libscotchmetis ; $(MAKE)                                                                ptscotch && $(MAKE) ptinstall)
+
+check				:	scotch
+					(cd check ; $(MAKE) check)
+
+ptcheck				:	ptscotch
+					(cd check ; $(MAKE) ptcheck)
+
+install				:	required	$(bindir)	$(includedir)	$(libdir)	$(mandir)/man1
+					-$(CP) -f ../bin/[agm]*$(EXE) $(bindir)
+					-$(CP) -f ../bin/d[agm]*$(EXE) $(bindir)
+					-$(CP) -f ../include/*scotch*.h $(includedir)
+					-$(CP) -f ../lib/*scotch*$(LIB) $(libdir)
+					-$(CP) -Rf ../man/* $(mandir)
+
+clean				:	required
+					(cd libscotch ;      $(MAKE) clean)
+					(cd scotch ;         $(MAKE) clean)
+					(cd libscotchmetis ; $(MAKE) clean)
+					(cd check ;          $(MAKE) clean)
+
+realclean			:	required
+					(cd libscotch ;      $(MAKE) realclean)
+					(cd scotch ;         $(MAKE) realclean)
+					(cd libscotchmetis ; $(MAKE) realclean)
+					(cd check ;          $(MAKE) realclean)
+					-$(RM) ../bin/* ../include/* ../lib/*
--- extra/tecio/tecio.patch	(.../tags/2.2.x-2)	(revision 0)
+++ extra/tecio/tecio.patch	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,109 @@
+diff -rupN tecio//tecsrc/Make/files /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/Make/files
+--- tecio//tecsrc/Make/files	1969-12-31 19:00:00.000000000 -0500
++++ /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/Make/files	2011-08-26 20:19:28.374779001 -0400
+@@ -0,0 +1,21 @@
++alloc.cpp
++arrlist.cpp
++auxdata.cpp
++dataio4.cpp
++dataio.cpp
++dataset0.cpp
++dataset.cpp
++datautil.cpp
++filestream.cpp
++geom2.cpp
++q_msg.cpp
++q_unicode.cpp
++set.cpp
++strlist.cpp
++strutil.cpp
++tassert.cpp
++tecxxx.cpp
++TranslatedString.cpp
++
++LIB = $(FOAM_LIBBIN)/libtecio
++
+diff -rupN tecio//tecsrc/Make/options /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/Make/options
+--- tecio//tecsrc/Make/options	1969-12-31 19:00:00.000000000 -0500
++++ /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/Make/options	2011-08-26 20:22:29.294778995 -0400
+@@ -0,0 +1,31 @@
++#if defined(MSWIN)
++
++    TECIO_FLAGS = -DMAKEARCHIVE -DMSWIN -DUSEENUM -DTHREED -DNO_ASSERTS
++
++#elif defined(DARWIN)
++
++    TECIO_FLAGS = -DMAKEARCHIVE -DLINUX -DLINUX64 -DUSEENUM -DTHREED -U_WIN32
++
++#elif defined(linux64)
++
++    TECIO_FLAGS = -DMAKEARCHIVE -DLINUX -DLINUX64 -DUSEENUM -DTHREED -U_WIN32
++
++#elif defined(linux)
++
++    TECIO_FLAGS = -DMAKEARCHIVE -DLINUX -DUSEENUM -DTHREED -U_WIN32
++
++#else
++
++#   error architecture not supported for compiling tecio.
++
++#endif
++
++TECIO_INC =
++TECIO_LIBS =
++
++EXE_INC = \
++    $(TECIO_FLAGS)
++
++LIB_LIBS =
++
++PROJECT_LIBS=
+diff -rupN tecio//tecsrc/MASTER.h /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/MASTER.h
+--- tecio//tecsrc/MASTER.h	2009-11-25 12:42:22.000000000 -0500
++++ /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/MASTER.h	2011-08-26 20:42:34.274778998 -0400
+@@ -221,7 +221,7 @@
+ #include "stdafx.h"
+ 
+ #if defined MSWIN
+-#include "W__BASE.h"
++/*#include "W__BASE.h"*/
+ #endif
+ 
+ #include <string>
+@@ -524,7 +524,8 @@
+ #    if XmVERSION == 1 && XmREVISION == 0
+ #    endif
+ #  else
+-#    include <X11/Intrinsic.h>
++/*#    include <X11/Intrinsic.h>*/
++typedef void *Widget;
+ #  endif
+ #endif
+ 
+diff -rupN tecio//tecsrc/TECXXX.h /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/TECXXX.h
+--- tecio//tecsrc/TECXXX.h	2011-06-21 11:53:24.000000000 -0400
++++ /home/rjs/projects/of/of2.0/ThirdParty-2.0.x/tecio/tecsrc/TECXXX.h	2011-08-26 20:27:02.514779002 -0400
+@@ -154,17 +154,14 @@
+ #endif /* DLLIMPORT */
+ 
+ 
+-#if defined (TECPLOTKERNEL)
+-# define LIBCALL
+-# define LIBFUNCTION
+-#elif defined (MAKEARCHIVE)
+-# define LIBCALL STDCALL
+-# define LIBFUNCTION EXTERNC DLLEXPORT
+-#else /* !TECPLOTKERNAL && !MAKEARCHIVE */
+-# define LIBCALL STDCALL
+-# define LIBFUNCTION EXTERNC DLLIMPORT
++#if defined (TECPLOTKERNEL)
++/* CORE SOURCE CODE REMOVED */
++#else /* !TECPLOTKERNAL && !MAKEARCHIVE */
++# define LIBCALL
++# define LIBFUNCTION EXTERNC
+ #endif
+ 
++
+ /*
+  *  V11.3 tecio functions
+  */
--- wmake/rules/linux64Gcc/gpulibCUDA	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64Gcc/gpulibCUDA	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+GPUFLAGS =
+GPUINC   = -I$(CUDA_ARCH_PATH)/src
+GPULIBS  = -L$(CUDA_ARCH_PATH)/install/lib -lofgpu
--- wmake/rules/linux64Gcc/c	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/rules/linux64Gcc/c	(.../branches/2.2.x-2)	(revision 831)
@@ -12,5 +12,5 @@
 
 LINK_LIBS   = $(cDBUG)
 
-LINKLIBSO   = $(cc) -shared
-LINKEXE     = $(cc) -Xlinker --add-needed -Xlinker -z -Xlinker nodefs
+LINKLIBSO   = $(cc) -shared -Xlinker --strip-all
+LINKEXE     = $(cc) -Xlinker --add-needed -Xlinker -z -Xlinker nodefs -Xlinker --strip-all
--- wmake/rules/linux64Gcc/c++	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/rules/linux64Gcc/c++	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,6 @@
 .SUFFIXES: .C .cxx .cc .cpp
 
-c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wold-style-cast -Wnon-virtual-dtor
+c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wnon-virtual-dtor
 
 CC          = g++ -m64
 
@@ -17,5 +17,5 @@
 
 LINK_LIBS   = $(c++DBUG)
 
-LINKLIBSO   = $(CC) $(c++FLAGS) -shared -Xlinker --add-needed -Xlinker --no-as-needed
-LINKEXE     = $(CC) $(c++FLAGS) -Xlinker --add-needed -Xlinker --no-as-needed
+LINKLIBSO   = $(CC) $(c++FLAGS) -shared -Xlinker --add-needed -Xlinker --no-as-needed -Xlinker --strip-all
+LINKEXE     = $(CC) $(c++FLAGS) -Xlinker --add-needed -Xlinker --no-as-needed -Xlinker --strip-all
--- wmake/rules/linux64Gcc/mplibOPENMPI	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64Gcc/mplibOPENMPI	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     =
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpi
--- wmake/rules/linux64Gcc/general	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/rules/linux64Gcc/general	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,6 @@
 CPP        = cpp -traditional-cpp $(GFLAGS)
 
-PROJECT_LIBS = -l$(WM_PROJECT) -ldl
+PROJECT_LIBS = -l$(WM_PROJECT) -L$(FOAM_LIBBIN)/dummy -lPstream
 
 include $(GENERAL_RULES)/standard
 
--- wmake/rules/linux64mingw-w64/gpulibCUDA	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/gpulibCUDA	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+GPUFLAGS =
+GPUINC   = -I$(CUDA_ARCH_PATH)/src
+GPULIBS  = -L$(CUDA_ARCH_PATH)/install/win/lib -lofgpu
--- wmake/rules/linux64mingw-w64/c++Debug	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/c++Debug	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG     = -gstabs3 -DFULLDEBUG
+c++OPT      = -O0 -fdefault-inline
--- wmake/rules/linux64mingw-w64/c	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/c	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,16 @@
+.SUFFIXES: .c .h
+
+cWARN        = -Wall
+
+cc          = x86_64-w64-mingw32-gcc -m64
+
+include $(RULES)/c$(WM_COMPILE_OPTION)
+
+cFLAGS      = $(GFLAGS) $(cWARN) $(cOPT) $(cDBUG) $(LIB_HEADER_DIRS)
+
+ctoo        = $(WM_SCHEDULER) $(cc) $(cFLAGS) -c $$SOURCE -o $@
+
+LINK_LIBS   = $(cDBUG)
+
+LINKLIBSO   = $(cc) -Wl,--output-def,$(LIB).def,--out-implib,$(LIB).a,--enable-auto-import,--enable-auto-image-base,--strip-all -shared
+LINKEXE     = $(cc) -Wl,--enable-auto-import,--enable-auto-image-base,--force-exe-suffix,--strip-all
--- wmake/rules/linux64mingw-w64/mplibMPICH	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplibMPICH	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpich -lrt
--- wmake/rules/linux64mingw-w64/mplibMPICH-GM	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplibMPICH-GM	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     =
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpich -L$(GM_LIB_PATH) -lgm
--- wmake/rules/linux64mingw-w64/cDebug	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/cDebug	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = -gstabs3 -DFULLDEBUG
+cOPT        = -O1 -finline-functions
--- wmake/rules/linux64mingw-w64/c++Opt	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/c++Opt	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG     = 
+c++OPT      = -O3 -DNDEBUG
--- wmake/rules/linux64mingw-w64/mplibOPENMPI	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplibOPENMPI	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = -DOMPI_SKIP_MPICXX
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpi
--- wmake/rules/linux64mingw-w64/c++Prof	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/c++Prof	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG    = -gstabs3 -pg
+c++OPT     = -O2
--- wmake/rules/linux64mingw-w64/mplib	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplib	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = 
+PLIBS      = 
--- wmake/rules/linux64mingw-w64/cOpt	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/cOpt	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = 
+cOPT        = -O3 -DNDEBUG
--- wmake/rules/linux64mingw-w64/mplibGAMMA	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplibGAMMA	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lgamma
--- wmake/rules/linux64mingw-w64/X	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/X	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+XFLAGS     =
+XINC       = 
+XLIBS      =
--- wmake/rules/linux64mingw-w64/c++	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/c++	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,23 @@
+.SUFFIXES: .C .cxx .cc .cpp
+
+c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wnon-virtual-dtor
+
+CC          = x86_64-w64-mingw32-g++ -m64
+
+include $(RULES)/c++$(WM_COMPILE_OPTION)
+
+ptFLAGS     = -DNoRepository -ftemplate-depth-40
+
+c++FLAGS    = $(GFLAGS) $(c++WARN) $(c++OPT) $(c++DBUG) $(ptFLAGS) $(LIB_HEADER_DIRS)
+
+Ctoo        = $(WM_SCHEDULER) $(CC) $(c++FLAGS) -c $$SOURCE -o $@
+cxxtoo      = $(Ctoo)
+cctoo       = $(Ctoo)
+cpptoo      = $(Ctoo)
+
+LINK_LIBS   = $(c++DBUG)
+
+# Tried using -Wl,-no-undefined,--enable-runtime-pseudo-reloc
+# but didnt forgive undefined symbols during linking
+LINKLIBSO   = $(CC) $(c++FLAGS) -Wl,--output-def,$(LIB).def,--out-implib,$(LIB).a,--enable-auto-import,--enable-auto-image-base,--strip-all -shared
+LINKEXE     = $(CC) $(c++FLAGS) -Wl,--enable-auto-import,--enable-auto-image-base,--force-exe-suffix,--strip-all
--- wmake/rules/linux64mingw-w64/mplibMSMPI	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/mplibMSMPI	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = -I$(MPI_ARCH_PATH)/Inc
+PLIBS      = -L$(MPI_ARCH_PATH)/Lib/amd64 -lmsmpi
--- wmake/rules/linux64mingw-w64/cProf	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/cProf	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = -gstabs3 -pg
+cOPT        = -O2
--- wmake/rules/linux64mingw-w64/general	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/linux64mingw-w64/general	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,19 @@
+CPP        = /lib/cpp -traditional-cpp $(GFLAGS)
+LD         = x86_64-w64-mingw32-ld
+AR         = x86_64-w64-mingw32-ar
+RANLIB     = x86_64-w64-mingw32-ranlib
+
+PROJECT_LIBS = -l$(WM_PROJECT) -L$(FOAM_LIBBIN)/dummy -lPstream
+
+include $(GENERAL_RULES)/standard
+
+include $(RULES)/X
+include $(RULES)/c
+include $(RULES)/c++
+
+SO      = dll
+EXE_EXT = .exe
+
+# Ensure we know what OS we are compiling for
+# during MakefileFiles and MakefileOptions
+GFLAGS  += -DMSWIN -DLITTLE_ENDIAN
--- wmake/rules/darwinGcc/gpulibCUDA	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/gpulibCUDA	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+GPUFLAGS =
+GPUINC   = -I$(CUDA_ARCH_PATH)/src
+GPULIBS  = -L$(CUDA_ARCH_PATH)/install/lib -lofgpu
--- wmake/rules/darwinGcc/c++Debug	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/c++Debug	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG    = -ggdb3 -DFULLDEBUG
+c++OPT      = -O0 -fdefault-inline
--- wmake/rules/darwinGcc/c	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/c	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,18 @@
+.SUFFIXES: .c .h
+
+cWARN        = -Wall
+
+cc          = gcc
+
+include $(RULES)/c$(WM_COMPILE_OPTION)
+
+# mac-OSX-10 = -isysroot /Developer/SDKs/MacOSX10.6.sdk -mmacosx-version-min=10.6
+
+cFLAGS      = $(GFLAGS) $(mac-OSX-10) $(cWARN) $(cOPT) $(cDBUG) $(LIB_HEADER_DIRS) -fPIC
+
+ctoo        = $(WM_SCHEDULER) $(cc) $(cFLAGS) -c $$SOURCE -o $@
+
+LINK_LIBS   = $(cDBUG)
+
+LINKLIBSO   = $(CC) $(cFLAGS) -dynamiclib -flat_namespace -undefined suppress
+LINKEXE     = $(CC) $(cFLAGS) -flat_namespace -undefined suppress
--- wmake/rules/darwinGcc/mplibMPICH	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplibMPICH	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = -DMPICH_SKIP_MPICXX
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpich -lrt
--- wmake/rules/darwinGcc/mplibMPICH-GM	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplibMPICH-GM	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     =
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpich -L$(GM_LIB_PATH) -lgm
--- wmake/rules/darwinGcc/cDebug	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/cDebug	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = -ggdb -DFULLDEBUG
+cOPT        = -O1 -fdefault-inline -finline-functions
--- wmake/rules/darwinGcc/c++Opt	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/c++Opt	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG     = 
+c++OPT      = -O3
--- wmake/rules/darwinGcc/mplibOPENMPI	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplibOPENMPI	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = -DOMPI_SKIP_MPICXX
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lmpi
--- wmake/rules/darwinGcc/c++Prof	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/c++Prof	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+c++DBUG    = -pg
+c++OPT     = -O2
--- wmake/rules/darwinGcc/mplibHPMPI	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplibHPMPI	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     =
+PINC       = -I$(MPI_ARCH_PATH)/include -D_MPICC_H
+PLIBS      = -L$(MPI_ARCH_PATH)/lib/linux_ia32 -lmpi
--- wmake/rules/darwinGcc/mplib	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplib	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = 
+PLIBS      = 
--- wmake/rules/darwinGcc/cOpt	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/cOpt	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = 
+cOPT        = -O3
--- wmake/rules/darwinGcc/mplibGAMMA	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/mplibGAMMA	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+PFLAGS     = 
+PINC       = -I$(MPI_ARCH_PATH)/include
+PLIBS      = -L$(MPI_ARCH_PATH)/lib -lgamma
--- wmake/rules/darwinGcc/X	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/X	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+XFLAGS     =
+XINC       = $(XFLAGS) -I/usr/X11R6/include
+XLIBS      = -L/usr/X11R6/lib -lXext -lX11
--- wmake/rules/darwinGcc/c++	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/c++	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,22 @@
+.SUFFIXES: .C .cxx .cc .cpp
+
+c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wnon-virtual-dtor
+
+CC          = g++
+
+include $(RULES)/c++$(WM_COMPILE_OPTION)
+
+ptFLAGS     = -DNoRepository -ftemplate-depth-40
+# mac-OSX-10 = -isysroot /Developer/SDKs/MacOSX10.6.sdk -mmacosx-version-min=10.6
+
+c++FLAGS    = $(GFLAGS) $(mac-OSX-10) $(c++WARN) $(c++OPT) $(c++DBUG) $(ptFLAGS) $(LIB_HEADER_DIRS) -fPIC
+
+Ctoo        = $(WM_SCHEDULER) $(CC) $(c++FLAGS) -c $$SOURCE -o $@
+cxxtoo      = $(Ctoo)
+cctoo       = $(Ctoo)
+cpptoo      = $(Ctoo)
+
+LINK_LIBS   = $(c++DBUG)
+
+LINKLIBSO   = $(CC) $(c++FLAGS) -dynamiclib -flat_namespace -undefined suppress
+LINKEXE     = $(CC) $(c++FLAGS) -flat_namespace -undefined suppress
--- wmake/rules/darwinGcc/cProf	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/cProf	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,2 @@
+cDBUG       = -pg
+cOPT        = -O2
--- wmake/rules/darwinGcc/general	(.../tags/2.2.x-2)	(revision 0)
+++ wmake/rules/darwinGcc/general	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,16 @@
+CPP        = cpp -traditional-cpp $(GFLAGS)
+LD         = ld
+
+PROJECT_LIBS = -l$(WM_PROJECT) -L$(FOAM_LIBBIN)/dummy -lPstream
+
+include $(GENERAL_RULES)/standard
+
+include $(RULES)/X
+include $(RULES)/c
+include $(RULES)/c++
+
+SO      = dylib
+
+# Ensure we know what OS we are compiling for
+# during MakefileFiles and MakefileOptions
+GFLAGS  += -DDARWIN -DLITTLE_ENDIAN
--- wmake/wcleanAll	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/wcleanAll	(.../branches/2.2.x-2)	(revision 831)
@@ -65,7 +65,7 @@
 find . -name '*.dep' -exec rm {} \;
 
 echo "Cleaning Make subdirectories"
-find . -depth \( -name Make -o -name "Make.[A-Za-z]*" \) -type d -print | \
+find . -depth \( -name Make -o -name "Make.[A-Za-z]*" -o -name '.svn' \) -type d -print | \
     xargs -i find '{}' -mindepth 1 -maxdepth 1 -type d -print | \
     xargs rm -rf
 
--- wmake/wmakeLnInclude	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/wmakeLnInclude	(.../branches/2.2.x-2)	(revision 831)
@@ -155,7 +155,7 @@
 # things placed in the 'noLink' directory are skipped
 #
 find .. $findOpt \
-    \( -name lnInclude -o -name Make -o -name config -o -name noLink \) -prune \
+    \( -name lnInclude -o -name Make -o -name config -o -name noLink -o -name '.svn' \) -prune \
  -o \( -name '*.[CHh]' -o -name '*.[ch]xx' -o -name '*.[ch]pp' -o -name '*.type' \)  \
  -exec ln $lnOpt {} . \;
 
--- wmake/wmake	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/wmake	(.../branches/2.2.x-2)	(revision 831)
@@ -181,7 +181,7 @@
     then
         # FOAM_APPS=$(find . -maxdepth 1 \( -type d -a ! -name "." -a ! -name Optional -a ! -name Make \)  -printf "%f ")
         # avoid 'find' with '-printf' ... not entirely portable
-        FOAM_APPS=$(for d in *; do [ -d "$d" -a "$d" != Optional -a "$d" != Make ] && echo "$d"; done | xargs)
+        FOAM_APPS=$(for d in *; do [ -d "$d" -a "$d" != Optional -a "$d" != Make -a "$d" != ".svn" ] && echo "$d"; done | xargs)
         $make -k -f $WM_DIR/MakefileApps FOAM_APPS="$FOAM_APPS"
         exit $?
     fi
--- wmake/Makefile	(.../tags/2.2.x-2)	(revision 831)
+++ wmake/Makefile	(.../branches/2.2.x-2)	(revision 831)
@@ -93,6 +93,9 @@
 # Shared library extension
 SO              = so
 
+# Executable extension
+EXE_EXT         =
+
 # Project executable
 EXE             = $(WM_PROJECT).out
 
@@ -145,18 +148,21 @@
 # define link statements for executables
 #------------------------------------------------------------------------------
 
-$(EXE):  $(OBJECTS)
-	     @$(WM_SCRIPTS)/makeTargetDir $(EXE)
+EXECUTABLE  = $(EXE)$(EXE_EXT)
+SEXECUTABLE = $(SEXE)$(EXE_EXT)
+
+$(EXECUTABLE):  $(OBJECTS)
+	     @$(WM_SCRIPTS)/makeTargetDir $(EXECUTABLE)
 	     $(LINKEXE) $(OBJECTS) -L$(LIB_PLATFORMS) \
-	     $(EXE_LIBS) $(PROJECT_LIBS) $(SYS_LIBS) $(LINK_LIBS) $(GLIBS) -o $(EXE)
+	     $(EXE_LIBS) $(PROJECT_LIBS) $(SYS_LIBS) $(LINK_LIBS) $(GLIBS) -o $(EXECUTABLE)
 
-exe:     $(SEXE)
-	     @echo \'$(SEXE)\' is up to date.
+exe:     $(SEXECUTABLE)
+	     @echo \`$(SEXECUTABLE)\' is up to date.
 
-$(SEXE): $(OBJECTS)
-	     @$(WM_SCRIPTS)/makeTargetDir $(SEXE)
+$(SEXECUTABLE): $(OBJECTS)
+	     @$(WM_SCRIPTS)/makeTargetDir $(SEXECUTABLE)
 	     $(LINKEXE) $(OBJECTS) $(EXE_LIBS) \
-         $(SYS_LIBS) $(LINK_LIBS) $(GLIBS) -o $(SEXE)
+         $(SYS_LIBS) $(LINK_LIBS) $(GLIBS) -o $(SEXECUTABLE)
 
 
 #------------------------------------------------------------------------------
@@ -172,7 +178,7 @@
 	     @$(WM_SCRIPTS)/makeTargetDir $(LIB)
 	     @rm -f so_locations
 	     @cd $(OBJECTS_DIR) ; \
-	     $(LINKLIBSO) $(LOCAL_OBJECTS) -L$(LIB_PLATFORMS) $(LIB_LIBS) $(GLIB_LIBS) -o $(LIB).$(SO)
+	     $(LINKLIBSO) $(LOCAL_OBJECTS) -L$(LIB_PLATFORMS) $(PROJECT_LIBS) $(LIB_LIBS) $(GLIB_LIBS) -o $(LIB).$(SO)
 
 lib:     $(LIB).a
 	     @echo \'$(LIB).a\' is up to date.
--- applications/utilities/postProcessing/dataConversion/foamToGMV/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToGMV/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,5 +9,5 @@
 EXE_LIBS = \
     -lfiniteVolume \
     -lmeshTools \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian
--- applications/utilities/postProcessing/dataConversion/foamToEnsightParts/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToEnsightParts/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,5 +8,5 @@
     -lfiniteVolume \
     -llagrangian \
     -lmeshTools \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lconversion
--- applications/utilities/postProcessing/dataConversion/smapToFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/smapToFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -2,5 +2,5 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 EXE_LIBS = \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lfiniteVolume
--- applications/utilities/postProcessing/dataConversion/foamToEnsight/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToEnsight/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,6 +9,6 @@
     -lfiniteVolume \
     -lmeshTools \
     -lsampling \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian
 
--- applications/utilities/postProcessing/dataConversion/foamToTecplot360/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToTecplot360/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,6 +8,6 @@
 EXE_LIBS = \
     -llagrangian \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
     -L$(FOAM_EXT_LIBBIN) -ltecio
--- applications/utilities/postProcessing/dataConversion/foamToVTK/lagrangianWriter.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/lagrangianWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -43,7 +43,10 @@
     binary_(binary),
     fName_(fName),
     cloudName_(cloudName),
-    os_(fName.c_str())
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    os_(fName.c_str(), 
+	ios_base::out|ios_base::binary)
 {
     const fvMesh& mesh = vMesh_.mesh();
 
--- applications/utilities/postProcessing/dataConversion/foamToVTK/surfaceMeshWriter.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/surfaceMeshWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -41,7 +41,10 @@
     binary_(binary),
     pp_(pp),
     fName_(fName),
-    os_(fName.c_str())
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    os_(fName.c_str(), 
+	ios_base::out|ios_base::binary)
 {
     // Write header
     writeFuns::writeHeader(os_, binary_, name);
--- applications/utilities/postProcessing/dataConversion/foamToVTK/internalWriter.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/internalWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -38,7 +38,10 @@
     vMesh_(vMesh),
     binary_(binary),
     fName_(fName),
-    os_(fName.c_str())
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    os_(fName.c_str(), 
+	ios_base::out|ios_base::binary)
 {
     const fvMesh& mesh = vMesh_.mesh();
     const vtkTopo& topo = vMesh_.topo();
--- applications/utilities/postProcessing/dataConversion/foamToVTK/writePointSet.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/writePointSet.C	(.../branches/2.2.x-2)	(revision 831)
@@ -42,7 +42,10 @@
     const fileName& fileName
 )
 {
-    std::ofstream ostr(fileName.c_str());
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    std::ofstream ostr(fileName.c_str(), 
+		       ios_base::out|ios_base::binary);
 
     writeFuns::writeHeader
     (
--- applications/utilities/postProcessing/dataConversion/foamToVTK/writeSurfFields.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/writeSurfFields.C	(.../branches/2.2.x-2)	(revision 831)
@@ -47,7 +47,10 @@
 {
     const fvMesh& mesh = vMesh.mesh();
 
-    std::ofstream str(fileName.c_str());
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    std::ofstream str(fileName.c_str(), 
+		      ios_base::out|ios_base::binary);
 
     writeFuns::writeHeader
     (
--- applications/utilities/postProcessing/dataConversion/foamToVTK/writeFaceSet.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/writeFaceSet.C	(.../branches/2.2.x-2)	(revision 831)
@@ -39,7 +39,10 @@
 {
     const faceList& faces = vMesh.mesh().faces();
 
-    std::ofstream ostr(fileName.c_str());
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    std::ofstream ostr(fileName.c_str(), 
+		       ios_base::out|ios_base::binary);
 
     writeFuns::writeHeader
     (
--- applications/utilities/postProcessing/dataConversion/foamToVTK/patchWriter.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/patchWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -42,7 +42,10 @@
     nearCellValue_(nearCellValue),
     fName_(fName),
     patchIDs_(patchIDs),
-    os_(fName.c_str())
+    // Use binary mode in case we write binary.
+    // Causes windows reading to fail if we don't
+    os_(fName.c_str(), 
+	ios_base::out|ios_base::binary)
 {
     const fvMesh& mesh = vMesh_.mesh();
     const polyBoundaryMesh& patches = mesh.boundaryMesh();
--- applications/utilities/postProcessing/dataConversion/foamToVTK/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,6 @@
 EXE_LIBS = \
     -lfiniteVolume \
     -llagrangian \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools
 
--- applications/utilities/postProcessing/dataConversion/foamDataToFluent/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/dataConversion/foamDataToFluent/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/createSprayFields.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/createSprayFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,75 @@
+// Construct of ptrs to all spray fields
+List<IOField<scalar>* > sprayScalarFieldPtrs
+(
+    sprayScalarNames.size(),
+    reinterpret_cast<IOField<scalar>*>(0)
+);
+
+List<IOField<vector>* > sprayVectorFieldPtrs
+(
+    sprayVectorNames.size(),
+    reinterpret_cast<IOField<vector>*>(0)
+);
+
+{
+     int sprayFieldI = 0;
+
+    // Set scalar fields
+    forAll(sprayScalarNames, fieldI)
+    {
+        IOobject ioHeader
+        (
+            sprayScalarNames[fieldI],
+            runTime.timeName(),
+            cloud::prefix,
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+            sprayScalarFieldPtrs[sprayFieldI] = new IOField<scalar>(ioHeader);
+        }
+        else
+        {
+            Info<< "    dummy lagrangian field for "
+                << sprayScalarNames[fieldI] << endl;
+        }
+
+        sprayFieldI++;
+    }
+}
+
+
+// Set vector fields
+
+{
+    int sprayFieldI = 0;
+
+    forAll(sprayVectorNames, fieldI)
+    {
+        IOobject ioHeader
+        (
+            sprayVectorNames[fieldI],
+            runTime.timeName(),
+            cloud::prefix,
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+            sprayVectorFieldPtrs[sprayFieldI] = new IOField<vector>(ioHeader);
+        }
+        else
+        {
+            Info<< "    dummy lagrangian field for "
+                << sprayVectorNames[fieldI] << endl;
+        }
+
+        sprayFieldI++;
+    }
+}
+
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/createFields.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/createFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,197 @@
+// Construct List of pointers to all vol fields
+int nFields = volScalarNames.size() + 3*volVectorNames.size();
+List<volScalarField*> volFieldPtrs
+(
+    nFields,
+    reinterpret_cast<volScalarField*>(0)
+);
+
+stringList volFieldNames(nFields);
+
+nFields = 0;
+{
+    // Load all scalar fields and store ptr to it
+    forAll(volScalarNames, fieldI)
+    {
+        word fieldName = volScalarNames[fieldI];
+
+        // Check if present
+        IOobject ioHeader
+        (
+            fieldName,
+            runTime.timeName(),
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+           volFieldPtrs[nFields] = new volScalarField
+            (
+                ioHeader,
+                mesh
+            );
+        }
+
+        fieldName = getFieldViewName(fieldName);
+
+        volFieldNames[nFields] = fieldName;
+
+        nFields++;
+    }
+
+
+    // Load all  (componenents of) vector fields
+    forAll(volVectorNames, fieldI)
+    {
+        word fieldName = volVectorNames[fieldI];
+
+        // Check if present
+        IOobject ioHeader
+        (
+            fieldName,
+            runTime.timeName(),
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+            volVectorField vvf(ioHeader, mesh);
+
+            // X component
+            volFieldPtrs[nFields] =
+                new volScalarField
+                (
+                    vvf.component(vector::X)
+                );
+
+            // Y component
+            volFieldPtrs[nFields+1] =
+                new volScalarField
+                (
+                    vvf.component(vector::Y)
+                );
+
+            // Z component
+            volFieldPtrs[nFields+2] =
+                new volScalarField
+                (
+                    vvf.component(vector::Z)
+                );
+        }
+
+        fieldName = getFieldViewName(fieldName);
+
+        volFieldNames[nFields]   = fieldName + ("x;" +  fieldName);
+        volFieldNames[nFields+1] = fieldName + "y";
+        volFieldNames[nFields+2] = fieldName + "z";
+
+        nFields += 3;
+    }
+}
+
+
+
+//
+// Construct List of pointers to all surface fields
+//
+
+
+
+int nSurfFields = surfScalarNames.size() + 3*surfVectorNames.size();
+List<surfaceScalarField*> surfFieldPtrs
+(
+    nSurfFields,
+    reinterpret_cast<surfaceScalarField*>(0)
+);
+
+stringList surfFieldNames(nSurfFields);
+
+nSurfFields = 0;
+{
+    // Load all scalar fields
+    forAll(surfScalarNames, fieldI)
+    {
+        word fieldName = surfScalarNames[fieldI];
+
+        // Check if present
+        IOobject ioHeader
+        (
+            fieldName,
+            runTime.timeName(),
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+            surfFieldPtrs[nSurfFields] =
+                new surfaceScalarField
+                (
+                    ioHeader,
+                    mesh
+                );
+        }
+
+        fieldName = getFieldViewName(fieldName);
+
+        surfFieldNames[nSurfFields] = fieldName;
+
+        nSurfFields++;
+    }
+
+
+    // Set (componenents of) vector fields
+    forAll(surfVectorNames, fieldI)
+    {
+        word fieldName = surfVectorNames[fieldI];
+
+        // Check if present
+        IOobject ioHeader
+        (
+            fieldName,
+            runTime.timeName(),
+            mesh,
+            IOobject::MUST_READ,
+            IOobject::NO_WRITE
+        );
+
+        if (ioHeader.headerOk())
+        {
+            surfaceVectorField svf(ioHeader, mesh);
+
+            // X component
+            surfFieldPtrs[nSurfFields] =
+                new surfaceScalarField
+                (
+                    svf.component(vector::X)
+                );
+
+            // Y component
+            surfFieldPtrs[nSurfFields+1] =
+                new surfaceScalarField
+                (
+                    svf.component(vector::Y)
+                );
+
+            // Z component
+            surfFieldPtrs[nSurfFields+2] =
+                new surfaceScalarField
+                (
+                    svf.component(vector::Z)
+                );
+        }
+
+        fieldName = getFieldViewName(fieldName);
+
+        surfFieldNames[nSurfFields]   = fieldName + ("x;" + fieldName);
+        surfFieldNames[nSurfFields+1] = fieldName + "y";
+        surfFieldNames[nSurfFields+2] = fieldName + "z";
+
+        nSurfFields += 3;
+    }
+}
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/fieldviewTopology.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/fieldviewTopology.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,176 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::fieldviewTopology
+
+Description
+
+SourceFiles
+    fieldviewTopology.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef fieldviewTopology_H
+#define fieldviewTopology_H
+
+#include "labelList.H"
+#include "faceList.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+// Forward declaration of classes
+class polyMesh;
+class cellShape;
+
+/*---------------------------------------------------------------------------*\
+                           Class fieldviewTopology Declaration
+\*---------------------------------------------------------------------------*/
+
+class fieldviewTopology
+{
+    // Private data
+
+        //- Hexes in fieldview format
+        List<int> hexLabels_;
+
+        List<int> prismLabels_;
+
+        List<int> pyrLabels_;
+
+        List<int> tetLabels_;
+
+        //- Number of non-hex/prism/pyr/tet labels
+        label nPoly_;
+
+
+        //
+        // Patches
+        //
+
+        //- Quad and tri patch faces in fv format
+        labelListList quadFaceLabels_;
+
+        //- Number of polyhedral faces per patch
+        labelList nPolyFaces_;
+
+
+    // Private Member Functions
+
+        static labelList calcFaceAddressing
+        (
+            const faceList& allFaces,   // faces given faceLabels
+            const cellShape& shape,
+            const labelList& faces,     // faceLabels for given cell
+            const label cellI
+        );
+
+
+        //- Disallow default bitwise copy construct
+        fieldviewTopology(const fieldviewTopology&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const fieldviewTopology&);
+
+
+public:
+
+    // Constructors
+
+        //- Construct from components
+        fieldviewTopology(const polyMesh& mesh, const bool setWallInfo);
+
+
+    // Member Functions
+
+        // Access
+
+            const List<int>& hexLabels() const
+            {
+                return hexLabels_;
+            }
+
+            const List<int>& prismLabels() const
+            {
+                return prismLabels_;
+            }
+
+            const List<int>& pyrLabels() const
+            {
+                return pyrLabels_;
+            }
+
+            const List<int>& tetLabels() const
+            {
+                return tetLabels_;
+            }
+
+            label nHex() const
+            {
+                return hexLabels().size()/9;
+            }
+
+            label nPrism() const
+            {
+                return prismLabels().size()/7;
+            }
+
+            label nPyr() const
+            {
+                return pyrLabels().size()/6;
+            }
+
+            label nTet() const
+            {
+                return tetLabels().size()/5;
+            }
+
+            label nPoly() const
+            {
+                return nPoly_;
+            }
+
+            const labelListList& quadFaceLabels() const
+            {
+                return quadFaceLabels_;
+            }
+
+            const labelList& nPolyFaces() const
+            {
+                return nPolyFaces_;
+            }
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/fv_reader_tags.h	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/fv_reader_tags.h	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,37 @@
+#ifndef FV_READER_TAGS_H
+#define FV_READER_TAGS_H
+
+/* Numeric tags (codes) for FIELDVIEW binary file format. */
+
+#define FV_MAGIC	0x00010203	/* decimal 66051 */
+
+/* Content of the file (grid only, results only or combined). */
+#define FV_GRIDS_FILE           1
+#define FV_RESULTS_FILE         2
+#define FV_COMBINED_FILE        3
+
+#define FV_NODES        	1001
+#define FV_FACES        	1002
+#define FV_ELEMENTS     	1003
+#define FV_VARIABLES    	1004
+#define FV_BNDRY_VARS   	1006
+#define FV_ARB_POLY_FACES       1007
+#define FV_ARB_POLY_ELEMENTS    1008
+#define FV_ARB_POLY_BNDRY_VARS  1009
+
+#define FV_TET_ELEM_ID          1
+#define FV_HEX_ELEM_ID          2
+#define FV_PRISM_ELEM_ID        3
+#define FV_PYRA_ELEM_ID         4
+#define FV_ARB_POLY_ELEM_ID     5
+
+/* Values for "wall_info" array (see comments in fv_encode_elem_header). */
+#ifdef __STDC__
+#define A_WALL         (07u)
+#define NOT_A_WALL     (0u)
+#else
+#define A_WALL         (07)
+#define NOT_A_WALL     (0)
+#endif
+
+#endif /* FV_READER_TAGS_H */
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeFunctions.C	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeFunctions.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,97 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "writeFunctions.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+// C++ version of fwrite_str80 from FieldView/uns/write_binary_uns.c
+// Write padded string of 80 char.
+bool writeStr80(std::ostream& os, const string& str)
+{
+    char cBuf[80];
+
+    memset(cBuf, '\0', 80);
+
+    int len = str.size();
+
+    strncpy(cBuf, str.c_str(), (len < 80 ? len : 80));
+
+    os.write(cBuf, 80*sizeof(char));
+
+    return os.good();
+}
+
+
+// Write single integer
+bool writeInt(std::ostream& os, int val1)
+{
+    os.write(reinterpret_cast<char*>(&val1), sizeof(int));
+
+    return os.good();
+}
+
+
+// Write single float
+bool writeFloat(std::ostream& os, scalar val1)
+{
+    float floatVal = val1;
+
+    os.write(reinterpret_cast<char*>(&floatVal), sizeof(float));
+
+    return os.good();
+}
+
+
+// Debug: write raw bytes
+void writeBytes(char* start, int nBytes)
+{
+    cout.setf(std::ios::hex, std::ios::basefield);
+
+    cout<< start << " : ";
+
+    for (int i = 0; i < nBytes; i++)
+    {
+        cout<< " " << start[i];
+    }
+    cout << std::endl;
+
+    cout.setf(std::ios::dec);
+}
+
+
+// Debug: write wall flags data
+void writeWallFlags(Ostream& os, label cellI, const labelList& wallFlags)
+{
+    os  << "cell " << cellI << " wallsFlags:";
+    forAll(wallFlags, wallFaceI)
+    {
+        os  << wallFlags[wallFaceI] << ' ';
+    }
+    os  << endl;
+}
+
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/write_binary_uns.c	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/write_binary_uns.c	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,641 @@
+/*
+** Support functions for writing a combined (grid and results) file
+** in the binary FIELDVIEW unstructured format.
+*/
+
+/* Include system stuff for I/O and string and exit functions. */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* Include the defines for the FV_* codes and wall_info values. */
+#include "fv_reader_tags.h"
+
+
+/* Don't change these - used by fv_encode_elem_header ! */
+#define MAX_NUM_ELEM_FACES     6
+#define BITS_PER_WALL  3
+#define ELEM_TYPE_BIT_SHIFT    (MAX_NUM_ELEM_FACES*BITS_PER_WALL)
+
+
+/*
+** fv_encode_elem_header:  return an encoded binary element header
+**
+** Input:
+**    elem_type:  integer element type as shown in fv_reader_tags.h
+**    wall_info:  array of integer "wall" flags, one for each face of
+**                the element.  The wall flags are used during streamline
+**                calculation.  Currently, the only meaningful values are
+**                A_WALL and NOT_A_WALL as shown in fv_reader_tags.h.
+**                Streamlines are forced away from faces marked as
+**                "A_WALL", by limiting velocity and position very near
+**                the wall.
+** Output:
+**    Function return value is the encoded binary element header.
+*/
+
+#ifdef __STDC__
+unsigned int fv_encode_elem_header (int elem_type, int wall_info[])
+#else
+unsigned int fv_encode_elem_header (elem_type, wall_info)
+int elem_type;
+int wall_info[];
+#endif
+{
+    unsigned int header;
+    int i, nfaces;
+
+    switch (elem_type)
+    {
+        case FV_TET_ELEM_ID:
+            header = (1 << ELEM_TYPE_BIT_SHIFT);
+            nfaces = 4;
+            break;
+        case FV_HEX_ELEM_ID:
+            header = (4 << ELEM_TYPE_BIT_SHIFT);
+            nfaces = 6;
+            break;
+        case FV_PRISM_ELEM_ID:
+            header = (3 << ELEM_TYPE_BIT_SHIFT);
+            nfaces = 5;
+            break;
+        case FV_PYRA_ELEM_ID:
+            header = (2 << ELEM_TYPE_BIT_SHIFT);
+            nfaces = 5;
+            break;
+        default:
+            fprintf(stderr, "ERROR:  Unknown element type\n");
+            return 0;
+    }
+
+    for (i = 0; i < nfaces; i++)
+    {
+        unsigned int u = wall_info[i];
+        if (u > A_WALL)
+        {
+            fprintf(stderr, "ERROR:  Bad wall value\n");
+            return 0;
+        }
+        header |= (u << (i*BITS_PER_WALL));
+    }
+    return header;
+}
+
+/*
+** fwrite_str80:  write out a string padded to 80 characters.
+**
+** Like fwrite, this returns the number of items written, which
+** should be 80 if successful, and less than 80 if it failed.
+*/
+#ifdef __STDC__
+size_t fwrite_str80 (char *str, FILE *fp)
+#else
+int fwrite_str80 (str, fp)
+char *str;
+FILE *fp;
+#endif
+{
+    char cbuf[80];
+    size_t len;
+    int i;
+
+    /* Most of this just to avoid garbage after the name. */
+    len = strlen(str);
+    strncpy(cbuf, str, len < 80 ? len : 80);
+
+    for (i = len; i < 80; i++)
+        cbuf[i] = '\0';  /* pad with zeros */
+
+    return fwrite(cbuf, sizeof(char), 80, fp);
+}
+
+
+/*
+** Sample program which writes out a single unstructured grid containing
+** four hex elements, with pressure and velocity data at the nodes, and
+** surface data for temperature and velocity on some of the boundaries.
+**
+** The data is written as a combined (grid and results) file in the
+** binary FIELDVIEW unstructured format.
+**
+** For simplicity, no error checking is done on the calls to fwrite
+** and fwrite_str80.
+*/
+#if 0	/***** CHANGE THIS TO "#if 1" TO RUN THE SAMPLE PROGRAM. *****/
+int main()
+{
+    char *file_name = "quad_hex.uns";
+    FILE *outfp;
+    int num_grids = 1;
+    int num_face_types = 5;
+    /*
+    ** Note that one of the boundary type names is "wall."
+    ** The boundary name "wall" has no special meaning in FIELDVIEW.
+    ** Boundary types and element walls are independent pieces of
+    ** information.  The only way to mark an element face as a wall
+    ** (for streamline calculation) is with the wall_info array passed
+    ** to fv_encode_elem_header.
+    */
+    static char *face_type_names[5] = { "bottom", "top", "wall",
+                                        "trimmed cell", "hanging node cell"};
+    /*
+    ** Each boundary type is flagged with 1 or 0 depending on
+    ** whether surface results are present or absent (see below).
+    */
+    static int results_flag[5]      =  { 1, 1, 0, 1, 1 };
+    /*
+    ** Each boundary type is flagged with 1 or 0 depending on
+    ** whether surface normals can be calculated from a "right
+    ** hand rule" (see below).
+    */
+    static int normals_flag[5]      =  { 1, 1, 0, 1, 1 };
+
+    /*
+    ** Note that vector variables are specified by a ';' and vector name
+    ** following the first scalar name of 3 scalar components of the
+    ** vector.  If writing 2-D results, the third component must still
+    ** be provided here, and its values must be written in the variables
+    ** section below (typically padded with zeros.)
+    */
+    int num_vars = 4;
+    static char *var_names[4] = { "pressure", "uvel; velocity", "vvel", "wvel" };
+    int num_bvars = 4;
+    static char *bvar_names[4] = { "temperature", "uvel; velocity", "vvel", "wvel" };
+
+    unsigned int elem_header;
+    int grid, i;
+    int ibuf[10];
+
+    int nnodes = 31;	/* Number of nodes in the grid. */
+    const int num_faces_trim_cell = 7;
+    const int num_faces_hang_cell = 6;
+
+    /* Constants. */
+    static float consts[4] = { 1., 0., 0., 0. };
+
+    /* XYZ coordinates of the nodes. */
+    static float x[31] = {-1., -1., 1., 1., -1., -1., 1., 1., -1., -1., 1.,1., 			  	  2., 2., 3., 3., 2.5, 3., 2., 3., 3., 2., 2.5,
+        		   3., 3., 3., 2.5, 2., 2., 2.0, 2.5};
+
+    static float y[31] = {-1., -1., -1., -1., 1., 1., 1., 1., 3., 3., 3., 3.,
+                           0., 0., 0., 0., 0., .5, 1., 1., 1., 1., .5,
+			   2., 2., 1.5, 2., 2., 2., 1.45, 1.5};
+
+    static float z[31] = {-1., 1., -1., 1., -1., 1., -1., 1., -1., 1., -1.,1.,			  	  1., 0., 0., .5, 1., 1., 1., 1., 0., 0., .5,
+			   0., 1., 1., 1., 1., 0., 1., 1.};
+
+    /* hex1 and hex2 are hex elements, defined as an array of node numbers. */
+    static int hex1[8] = {1,2,3,4,5,6,7,8};
+    static int hex2[8] = {5,6,7,8,9,10,11,12};
+
+    /*
+    ** Face definitions for boundary faces.
+    ** All faces have 4 vertices.  If the face is triangular,
+    ** the last vertex should be zero.
+    */
+    static int bot_faces[4] = { 1,2,4,3 };
+    static int top_faces[4] = { 9,10,12,11 };
+    static int wall_faces[8][4] =
+        { {1,2,6,5}, {5,6,10,9}, {3,4,8,7}, {7,8,12,11},
+          {1,3,7,5}, {5,7,11,9}, {2,4,8,6}, {6,8,12,10} };
+
+    /* Arbitrary Polyhedron faces: */
+    static int trim_cell_face[num_faces_trim_cell][6] =
+                                      { {5,13,14,15,16,17}, {3,16,18,17},
+					{5,15,21,20,18,16}, {5,13,17,18,20,19},
+					{4,13,19,22,14},  {4,14,22,21,15},
+					{4,19,20,21,22} };
+
+    static int hang_cell_face[num_faces_hang_cell][8] =
+                                        { {5,20,21,24,25,26},
+					  {5,24,29,28,27,25},
+					  {7,20,26,25,27,28,30,19},
+					  {4,20,19,22,21},
+				          {4,21,22,29,24},
+					  {5,22,19,30,28,29} };
+
+    /* Wall values for element faces. */
+    static int hex1_walls[6] = { A_WALL, A_WALL, NOT_A_WALL,
+	    NOT_A_WALL, A_WALL, A_WALL };
+    static int hex2_walls[6] = { A_WALL, A_WALL, NOT_A_WALL,
+	    NOT_A_WALL, A_WALL, A_WALL };
+
+    /* 4 variables (pressure and velocity values) at the 31 grid nodes. */
+    static float vars[4][31] =
+      { {1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,
+         1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,
+         1.12,1.13,1.14,1.15,1.16,1.17,1.18},
+        {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,
+	 1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,
+	 1.12,1.13,1.14,1.15,1.16,1.17,1.18},
+        {1.2,1.1,1.0,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1,
+	 1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,
+	 1.12,1.13,1.14,1.15,1.16,1.17,1.18},
+        {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,
+	 1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,
+	 1.12,1.13,1.14,1.15,1.16,1.17,1.18} };
+
+    /*
+    ** 4 boundary variables (temperature and velocity values) defined on
+    ** the single top face, and the the single bottom face.
+    */
+    static float top_bvars[4] = { 1.0, 2.0,4.0,2.5 };
+    static float bot_bvars[4] = { 1.0, 4.5,3.0,3.0 };
+
+    /* Arbitrary Polyhedron boundary face variables: */
+    static float trim_cell_bvars[4][num_faces_trim_cell] =
+                                      { {1.0,1.1,1.2,1.3,1.4,1.5,1.6},
+					{1.7,1.8,1.9,1.1,1.11,1.12,1.13},
+					{1.14,1.15,1.16,1.17,1.18,1.19,1.2},
+					{1.21,1.22,1.23,1.24,1.25,1.26,1.27} };
+
+    static float hang_cell_bvars[4][num_faces_hang_cell] =
+                                         { {1.1,1.11,1.12,1.13,1.14,1.15},
+					   {1.16,1.17,1.18,1.19,1.2,1.21},
+					   {1.22,1.23,1.24,1.25,1.26,1.27},
+					   {1.28,1.29,1.30,1.31,1.32,1.33} };
+
+    /* Open the file for binary write access. */
+    if ((outfp = fopen(file_name, "wb")) == NULL)
+    {
+        perror ("Cannot open output file");
+        exit(1);
+    }
+
+    /* Output the magic number. */
+    ibuf[0] = FV_MAGIC;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+
+    /* Output file header and version number. */
+    fwrite_str80("FIELDVIEW", outfp);
+
+    /*
+    ** This version of the FIELDVIEW unstructured file is "3.0".
+    ** This is written as two integers.
+    */
+    ibuf[0] = 3;
+    ibuf[1] = 0;
+    fwrite(ibuf, sizeof(int), 2, outfp);
+
+    /* File type code - new in version 2.7 */
+    ibuf[0] = FV_COMBINED_FILE;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+
+    /* Reserved field, always write a zero - new in version 2.6 */
+    ibuf[0] = 0;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+
+    /* Output constants for time, fsmach, alpha and re. */
+    fwrite(consts, sizeof(float), 4, outfp);
+
+    /* Output the number of grids. */
+    ibuf[0] = num_grids;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+
+    /*
+    ** Output the table of boundary types.
+    ** Each boundary type is preceded by 2 integer flags.
+    ** The first flag is an "surface results flag".
+    ** A value of 1 means surface results will be present for this
+    ** boundary type (if any boundary variables are specified in the
+    ** boundary variable names table below).
+    ** A value of 0 means no surface results will be present.
+    ** The second flag indicates whether boundary faces of this type have
+    ** consistent "clockness" for the purpose of calculating a surface
+    ** normal.  A value of 1 means that all faces of this type are
+    ** written following a "right hand rule" for clockness.  In other
+    ** words, if the vertices are written on counter-clockwise:
+    ** 4 --- 3
+    ** |     |
+    ** 1 --- 2
+    ** then the normal to the face is pointing towards you (not away
+    ** from you).  A value of 0 means that the faces do not have any
+    ** consistent clockness.  The "clockness" of surface normals is
+    ** only used for calculating certain special surface integrals
+    ** that involve surface normals.  If the surface normals flag
+    ** is 0, these special integrals will not be available.
+    */
+    ibuf[0] = num_face_types;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+    for (i = 0; i < num_face_types; i++) {
+	ibuf[0] = results_flag[i];
+	ibuf[1] = normals_flag[i];
+	fwrite(ibuf, sizeof(int), 2, outfp);
+        fwrite_str80(face_type_names[i], outfp);
+    }
+
+    /* Output the table of variable names. */
+    /* The number of variables can be zero. */
+    ibuf[0] = num_vars;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+    for (i = 0; i < num_vars; i++)
+        fwrite_str80(var_names[i], outfp);
+
+    /*
+    ** Output the table of boundary variable names.
+    ** Boundary variables are associated with boundary faces, rather than
+    ** with grid nodes.
+    ** FIELDVIEW will automatically append "[BNDRY]" to each name
+    ** so boundary variables can be easily distinguished from ordinary
+    ** (grid node) variables.
+    ** The number of boundary variables can be different from the number
+    ** of ordinary variables.  The number of boundary variables can be
+    ** zero.
+    */
+    ibuf[0] = num_bvars;
+    fwrite(ibuf, sizeof(int), 1, outfp);
+    for (i = 0; i < num_bvars; i++)
+        fwrite_str80(bvar_names[i], outfp);
+
+    /* Output grid data. */
+    for (grid = 0; grid < num_grids; grid++)
+    {
+	/* Output the node definition section for this grid. */
+        ibuf[0] = FV_NODES;
+        ibuf[1] = nnodes;
+        fwrite(ibuf, sizeof(int), 2, outfp);
+
+	/*
+	** Output the X, then Y, then Z node coordinates.
+	** Note that all of the X coordinates are output before any of
+	** the Y coordinates.
+	*/
+        fwrite(x, sizeof(float), nnodes, outfp);
+        fwrite(y, sizeof(float), nnodes, outfp);
+        fwrite(z, sizeof(float), nnodes, outfp);
+
+	/*
+        ** Output boundary faces of the 3 different types.
+	** All faces have 4 vertices.  If the face is triangular,
+	** the last vertex should be zero.
+	** TIP: A single boundary type can be broken into several sections
+	** if you prefer.  Also, boundary face sections do not have to
+	** be in order.  You may have a section of 10 faces of type 3,
+	** followed by a section of 20 faces of type 2, followed by a
+	** section of 15 more faces of type 3.  Breaking a boundary
+	** type into very many short sections is less efficient.  The
+	** boundaries will require more memory and be somewhat
+	** slower to calculate in FIELDVIEW.
+	**
+	*/
+        ibuf[0] = FV_FACES;
+        ibuf[1] = 1;	/* first boundary type */
+        ibuf[2] = 1;	/* number of faces of this type */
+        fwrite(ibuf, sizeof(int), 3, outfp);
+        fwrite(bot_faces, sizeof(int), 4, outfp);
+
+        ibuf[0] = FV_FACES;
+        ibuf[1] = 2;	/* second boundary type */
+        ibuf[2] = 1;	/* number of faces of this type */
+        fwrite(ibuf, sizeof(int), 3, outfp);
+        fwrite(top_faces, sizeof(int), 4, outfp);
+
+        ibuf[0] = FV_FACES;
+        ibuf[1] = 3;	/* third boundary type */
+        ibuf[2] = 8;	/* number of faces of this type */
+        fwrite(ibuf, sizeof(int), 3, outfp);
+        fwrite(wall_faces, sizeof(int), 8*4, outfp);
+
+	/* Arbitrary Polygon boundary faces:
+	** The format (in psuedocode) is as follows:
+	**   >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+	**   FV_ARB_POLY_FACES (section header)
+	**   BndryFaceType NumBndryFaces
+	**
+	**   [for N = 1, NumBndryFaces]
+	**       NumVertsFaceN Vert1 Vert2 ... Vert{NumVertsFaceN}
+	**
+	**   <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+	** * The above block should be repeated for different boundary face
+	** 	types, as is the case for standard boundary faces.
+	** * These blocks should be after the blocks for standard faces,
+	** 	within the FIELDVIEW-Uns file.
+	** * The node ordering for specifying faces should follow a
+	**	right-handed rule with the normal pointing away from the
+	**	cell center. So nodes should be given by traversing the face
+	** 	in a counter-clockwise manner.
+	** * Hanging nodes are not permitted on boundary faces.
+	*/
+
+	ibuf[0] = FV_ARB_POLY_FACES;
+	ibuf[1] = 4;  /* boundary face type */
+	ibuf[2] = 7;  /* num faces for the trimmed cell */
+
+	fwrite(ibuf, sizeof(int), 3, outfp);
+
+	for (i = 0; i < num_faces_trim_cell; ++i) /* loop over the faces */
+	    fwrite(trim_cell_face[i], sizeof(int), trim_cell_face[i][0] + 1,
+		   outfp);
+
+	ibuf[0] = FV_ARB_POLY_FACES;
+	ibuf[1] = 5;  /* boundary face type */
+	ibuf[2] = 6;  /* num faces for the hanging node cell */
+
+	fwrite(ibuf, sizeof(int), 3, outfp);
+
+	for (i = 0; i < num_faces_hang_cell; ++i) /* loop over the faces */
+	    fwrite(hang_cell_face[i], sizeof(int), hang_cell_face[i][0] + 1,
+		   outfp);
+
+	/*
+	** Start an elements section.
+	** There may be as many elements sections as needed.
+	** Each section may contain a single element type or a
+	** mixture of element types.
+	** For maximum efficiency, each section should contain
+	** a significant percentage of the elements in the grid.
+	** The most efficient case is a single section containing
+	** all elements in the grid.
+	*/
+        ibuf[0] = FV_ELEMENTS;
+        ibuf[1] = 0;  /* tet count */
+        ibuf[2] = 2;  /* hex count */
+        ibuf[3] = 0;  /* prism count */
+        ibuf[4] = 0;  /* pyramid count */
+        fwrite(ibuf, sizeof(int), 5, outfp);
+
+        /* Write header for first element. */
+        elem_header = fv_encode_elem_header(FV_HEX_ELEM_ID, hex1_walls);
+	if (elem_header == 0)
+	{
+	    fprintf (stderr, "fv_encode_elem_header failed for first hex.\n");
+	    exit(1);
+	}
+	fwrite (&elem_header, sizeof(elem_header), 1, outfp);
+
+	/* Write node definition for first element. */
+        fwrite(hex1, sizeof(int), 8, outfp);
+
+        /* Write header for second element. */
+        elem_header = fv_encode_elem_header(FV_HEX_ELEM_ID, hex2_walls);
+	if (elem_header == 0)
+	{
+	    fprintf (stderr, "fv_encode_elem_header failed for second hex.\n");
+	    exit(1);
+	}
+	fwrite (&elem_header, sizeof(elem_header), 1, outfp);
+
+	/* Write node definition for second element. */
+        fwrite(hex2, sizeof(int), 8, outfp);
+
+        /* Arbitrary Polyhedron elements:
+	** The format (in psuedocode) is as follows:
+	** >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+	** FV_ARB_POLY_ELEMENTS (section header)
+	** NumArbPolyElements
+	**
+	** [for elem = 1, NumArbPolyElements]
+	** {
+	**    NumFaces NumNodesElement CenterNode
+	**
+	**    [for face = 1, NumFaces]
+	**        WallFlag NumNodesFace FaceNode1 ... FaceNode{NumNodesFace}
+	**	NumHangNodes HangNode1 ... HangNode{NumHangNodes}
+	** }
+	** <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+	** * These blocks can be after or before the standard element blocks.
+	** 	There can be any number of these for any one grid.
+	** * The WallFlag has the same meaning as for standard elements,
+	** 	i.e., A_WALL or NOT_A_WALL.
+	** * The node ordering for specifying faces should follow a
+	**	right-handed rule with the normal pointing away from the
+	**	cell center. So nodes should be given by traversing the face
+	** 	in a counter-clockwise manner.
+	** * Hanging nodes are associated with a face interior and should
+	** 	not be on an edge. Hanging nodes on an edge should be
+	**	interpretted as a regular face node.
+	*/
+	ibuf[0] = FV_ARB_POLY_ELEMENTS;
+	ibuf[1] = 2; /* have 2 elements here */
+
+	fwrite(ibuf, sizeof(int), 2, outfp);
+
+	/* trimmed face element */
+	ibuf[0] = 7;  /* num faces for the trimmed cell */
+	ibuf[1] = 11; /* number of nodes including a center node */
+	ibuf[2] = 23; /* the center node */
+	fwrite(ibuf, sizeof(int), 3, outfp);
+
+	ibuf[0] = A_WALL; /* wall value */
+	ibuf[1] = 0; /* number of hanging nodes */
+
+	for (i = 0; i < num_faces_trim_cell; ++i) /* write out face info */
+	{
+	    fwrite(ibuf, sizeof(int), 1, outfp); /* write wall value */
+	    fwrite(trim_cell_face[i], sizeof(int), trim_cell_face[i][0] + 1,
+		   outfp); /* write num verts and verts */
+	    fwrite(&ibuf[1], sizeof(int), 1, outfp); /* write num hang nodes */
+	}
+
+        /* hanging node element */
+	ibuf[0] = 6;  /* num faces for the hanging node cell */
+	ibuf[1] = 12; /* number of nodes excluding a center node */
+	ibuf[2] = -1; /* the center node, this indicates that FIELDVIEW
+		     ** should calculate the center node and associated
+		     ** centernode variable values
+		     */
+	fwrite(ibuf, sizeof(int), 3, outfp);
+
+	ibuf[0] = A_WALL; /* wall value */
+	ibuf[1] = 0; /* number of hanging nodes */
+	ibuf[2] = 1; /* number of hanging nodes for face 3 */
+	ibuf[3] = 31; /* the node number for the hanging node on face 3*/
+
+	for (i = 0; i < 2; ++i) /* write out face info for first 2 faces */
+	{
+	    fwrite(ibuf, sizeof(int), 1, outfp); /* write wall value */
+	    fwrite(hang_cell_face[i], sizeof(int), hang_cell_face[i][0] + 1,
+		   outfp); /* write num verts and verts */
+	    fwrite(&ibuf[1], sizeof(int), 1, outfp); /* write num hang nodes */
+	}
+
+	/* this face has a hanging node */
+	fwrite(ibuf, sizeof(int), 1, outfp);
+	fwrite(hang_cell_face[2], sizeof(int), hang_cell_face[2][0] + 1, outfp);
+	fwrite(&ibuf[2], sizeof(int), 2, outfp);
+
+	/* write out face info for last 3 faces */
+	for (i = 3; i < num_faces_hang_cell; ++i)
+	{
+	    fwrite(ibuf, sizeof(int), 1, outfp); /* write wall value */
+	    fwrite(hang_cell_face[i], sizeof(int), hang_cell_face[i][0] + 1,
+		   outfp); /* write num verts and verts */
+	    fwrite(&ibuf[1], sizeof(int), 1, outfp); /* write num hang nodes */
+	}
+
+        /*
+	** Output the variables data.
+	** You must write the section header even if the number
+	** of variables is zero.
+	*/
+	ibuf[0] = FV_VARIABLES;
+	fwrite(ibuf, sizeof(int), 1, outfp);
+
+	/*
+	** Note that all of the data for the first variable is output
+	** before any of the data for the second variable.
+	*/
+	for (i = 0; i < num_vars; i++)
+	    fwrite(vars[i], sizeof(float), nnodes, outfp);
+
+        /*
+	** Output the boundary variables data.
+	** Remember that the Boundary Table above has a "surface results
+	** flag" indicating which boundary types have surface results.
+	** The data should be written in the same order as the faces in
+	** the Boundary Faces section, skipping over faces whose boundary
+	** type has a surface results flag of zero (false).
+	** For each variable, you should write one number per boundary face.
+	** You must write the section header even if the number of boundary
+	** variables is zero.
+	*/
+	ibuf[0] = FV_BNDRY_VARS;
+	fwrite(ibuf, sizeof(int), 1, outfp);
+
+	/*
+	** Note that all of the data for the first variable is output
+	** before any of the data for the second variable.
+	*/
+	for (i = 0; i < num_bvars; i++) {
+	    int num_faces;
+	    /*
+	    ** The data for the bottom face is written first for each
+	    ** variable, because the bottom face was written first in the
+	    ** "Boundary Faces" section.
+	    ** The "wall" faces are skipped, because the surface results
+	    ** flag for the wall boundary type was 0 (false) in the
+	    ** Boundary Table section.
+	    */
+	    num_faces = 1;	/* number of bottom faces */
+	    fwrite(&bot_bvars[i], sizeof(float), num_faces, outfp);
+	    num_faces = 1;	/* number of top faces */
+	    fwrite(&top_bvars[i], sizeof(float), num_faces, outfp);
+	}
+
+	/* Arbitrary Polyhedron boundary face results:
+	** The format is the same as for standard boundary face results.
+	*/
+	ibuf[0] = FV_ARB_POLY_BNDRY_VARS;
+	fwrite(ibuf, sizeof(int), 1, outfp);
+
+	for (i = 0; i < num_bvars; ++i)
+	{
+	    int num_faces;
+
+	    num_faces = 7;  /* num faces for the trimmed cell */
+	    fwrite(trim_cell_bvars[i], sizeof(float), num_faces, outfp);
+
+	    num_faces = 6;  /* num faces for the hanging node cell */
+	    fwrite(hang_cell_bvars[i], sizeof(float), num_faces, outfp);
+	}
+    }
+
+    if (fclose(outfp) != 0)
+    {
+	perror ("Cannot close output file");
+	exit(1);
+    }
+
+    return 0;
+}
+#endif	/* end commenting out the sample program */
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/calcFaceAddressing.C	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/calcFaceAddressing.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,92 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "calcFaceAddressing.H"
+
+using namespace Foam;
+
+// * * * * * * * * * * * * * * * Friend Functions  * * * * * * * * * * * * * //
+
+// Returns the face labels of the shape in an order consistent with the
+// shape.
+labelList calcFaceAddressing
+(
+    const faceList& allFaces,   // faces given faceLabels
+    const cellShape& shape,
+    const labelList& faces,     // faceLabels for given cell
+    const label cellI
+)
+{
+    // return value.
+    labelList shapeToMesh(shape.nFaces(), -1);
+
+    const faceList modelFaces(shape.faces());
+
+    // Loop over all faces of cellShape
+    forAll(modelFaces, cellFaceI)
+    {
+        // face (vertex list)
+        const face& modelFace = modelFaces[cellFaceI];
+
+        // Loop over all face labels
+        forAll(faces, faceI)
+        {
+            const face& vertLabels = allFaces[faces[faceI]];
+
+            if (vertLabels == modelFace)
+            {
+                //Info<< "match:" << modelFace
+                //    << "  to " << vertLabels << endl;
+                shapeToMesh[cellFaceI] = faces[faceI];
+                break;
+            }
+        }
+
+        if (shapeToMesh[cellFaceI] == -1)
+        {
+            FatalErrorIn("foamToFieldview : calcFaceAddressing")
+                << "calcFaceAddressing : can't match face to shape.\n"
+                << "    shape face:" << modelFace << endl
+                << "    face labels:" << faces << endl
+                << "    cellI:" << cellI << endl;
+
+            FatalError
+                << "Faces consist of vertices:" << endl;
+
+            forAll(faces, faceI)
+            {
+                FatalError
+                    << "    face:" << faces[faceI]
+                    << allFaces[faces[faceI]] << endl;
+            }
+            FatalError
+                << exit(FatalError);
+        }
+    }
+    return shapeToMesh;
+}
+
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeSprayHeader.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeSprayHeader.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,26 @@
+{
+    /* Output the magic number. */
+    writeInt(fvParticleFile, FV_MAGIC);
+
+    /* Output file header and version number. */
+    writeStr80(fvParticleFile, "FVPARTICLES");
+
+    /* version */
+    writeInt(fvParticleFile, 1);
+    writeInt(fvParticleFile, 1);
+
+    int nFields = sprayScalarNames.size() + 3*sprayVectorNames.size();
+    writeInt(fvParticleFile, nFields);
+
+    forAll(sprayScalarNames, nameI)
+    {
+        writeStr80(fvParticleFile, sprayScalarNames[nameI]);
+    }
+    forAll(sprayVectorNames, nameI)
+    {
+        const string& name(sprayVectorNames[nameI]);
+        writeStr80(fvParticleFile, name + ("x;" + name));
+        writeStr80(fvParticleFile, name + ("y;" + name));
+        writeStr80(fvParticleFile, name + ("z;" + name));
+    }
+}
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/moveMesh.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/moveMesh.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,34 @@
+
+//
+// Check if new points (so moving mesh)
+//
+{
+    IOobject pointsHeader
+    (
+        "points",
+        runTime.timeName(),
+        polyMesh::defaultRegion,
+        runTime
+    );
+    if (pointsHeader.headerOk())
+    {
+        // points exists for time step, let's read them
+        Info<< "    Points file detected - updating points" << endl;
+
+        // Reading new points
+        pointIOField newPoints
+        (
+            IOobject
+            (
+                "points",
+                runTime.timeName(),
+                polyMesh::defaultRegion,
+                mesh,
+                IOobject::MUST_READ,
+                IOobject::NO_WRITE
+            )
+        );
+
+        mesh.polyMesh::movePoints(newPoints);
+    }
+}
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeFunctions.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/writeFunctions.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,56 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+InClass
+    Foam::writeFunctions
+
+Description
+
+SourceFiles
+    writeFunctions.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef writeFunctions_H
+#define writeFunctions_H
+
+#include "scalar.H"
+#include "string.H"
+#include "labelList.H"
+#include <iostream>
+
+using namespace Foam;
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+bool writeStr80(std::ostream& os, const string& str);
+bool writeInt(std::ostream& os, int val1);
+bool writeFloat(std::ostream& os, scalar val1);
+void writeBytes(char* start, int nBytes);
+void writeWallFlags(Ostream& os, label cellI, const labelList& wallFlags);
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/calcFaceAddressing.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/calcFaceAddressing.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,55 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+InClass
+    Foam::calcFaceAddressing
+
+Description
+
+SourceFiles
+    calcFaceAddressing.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef calcFaceAddressing_H
+#define calcFaceAddressing_H
+
+#include "faceList.H"
+#include "cellShape.H"
+#include "labelList.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+Foam::labelList calcFaceAddressing
+(
+    const Foam::faceList& allFaces,   // faces given faceLabels
+    const Foam::cellShape& shape,
+    const Foam::labelList& faces,     // faceLabels for given cell
+    const Foam::label cellI
+);
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/fieldviewTopology.C	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/fieldviewTopology.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,436 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "fieldviewTopology.H"
+#include "polyMesh.H"
+#include "cellShape.H"
+#include "cellModeller.H"
+#include "wallPolyPatch.H"
+#include "symmetryPolyPatch.H"
+
+
+#include "fv_reader_tags.h"
+
+extern "C"
+{
+    unsigned int fv_encode_elem_header(int elem_type, int wall_info[]);
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+Foam::labelList Foam::fieldviewTopology::calcFaceAddressing
+(
+    const faceList& allFaces,   // faces given faceLabels
+    const cellShape& shape,
+    const labelList& faces,     // faceLabels for given cell
+    const label cellI
+)
+{
+    // return value.
+    labelList shapeToMesh(shape.nFaces(), -1);
+
+    const faceList modelFaces(shape.faces());
+
+    // Loop over all faces of cellShape
+    forAll(modelFaces, cellFaceI)
+    {
+        // face (vertex list)
+        const face& modelFace = modelFaces[cellFaceI];
+
+        // Loop over all face labels
+        forAll(faces, faceI)
+        {
+            const face& vertLabels = allFaces[faces[faceI]];
+
+            if (vertLabels == modelFace)
+            {
+                shapeToMesh[cellFaceI] = faces[faceI];
+                break;
+            }
+        }
+
+        if (shapeToMesh[cellFaceI] == -1)
+        {
+            FatalErrorIn("foamToFieldview : calcFaceAddressing")
+                << "calcFaceAddressing : can't match face to shape.\n"
+                << "    shape face:" << modelFace << endl
+                << "    face labels:" << faces << endl
+                << "    cellI:" << cellI << endl;
+
+            FatalError << "Faces consist of vertices:" << endl;
+            forAll(faces, faceI)
+            {
+                FatalError
+                    << "    face:" << faces[faceI]
+                    << allFaces[faces[faceI]] << endl;
+            }
+            FatalError << exit(FatalError);
+        }
+    }
+    return shapeToMesh;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+// Construct from components
+Foam::fieldviewTopology::fieldviewTopology
+(
+    const polyMesh& mesh,
+    const bool setWallInfo
+)
+:
+    hexLabels_((1+8)*mesh.nCells()),
+    prismLabels_((1+6)*mesh.nCells()),
+    pyrLabels_((1+5)*mesh.nCells()),
+    tetLabels_((1+4)*mesh.nCells()),
+    nPoly_(0),
+    quadFaceLabels_(mesh.boundaryMesh().size()),
+    nPolyFaces_(mesh.boundaryMesh().size())
+{
+    // Mark all faces that are to be seen as wall for particle
+    // tracking and all cells that use one or more of these walls
+
+    List<int> wallFace(mesh.nFaces(), NOT_A_WALL);
+    boolList wallCell(mesh.nCells(), false);
+
+    if (setWallInfo)
+    {
+        forAll(mesh.boundaryMesh(), patchI)
+        {
+            const polyPatch& currPatch = mesh.boundaryMesh()[patchI];
+            if
+            (
+                isA<wallPolyPatch>(currPatch)
+             || isA<symmetryPolyPatch>(currPatch)
+            )
+            {
+                forAll(currPatch, patchFaceI)
+                {
+                    label meshFaceI = currPatch.start() + patchFaceI;
+
+                    wallFace[meshFaceI] = A_WALL;
+                    wallCell[mesh.faceOwner()[meshFaceI]] = true;
+                }
+            }
+        }
+    }
+
+
+
+    const cellModel& tet = *(cellModeller::lookup("tet"));
+    const cellModel& pyr = *(cellModeller::lookup("pyr"));
+    const cellModel& prism = *(cellModeller::lookup("prism"));
+    const cellModel& wedge = *(cellModeller::lookup("wedge"));
+    const cellModel& tetWedge = *(cellModeller::lookup("tetWedge"));
+    const cellModel& hex = *(cellModeller::lookup("hex"));
+
+    // Pre calculate headers for cells not on walls
+    List<int> notWallFlags(6, NOT_A_WALL);
+    unsigned int tetNotWall = fv_encode_elem_header
+    (
+        FV_TET_ELEM_ID, notWallFlags.begin()
+    );
+    unsigned int pyrNotWall = fv_encode_elem_header
+    (
+        FV_PYRA_ELEM_ID, notWallFlags.begin()
+    );
+    unsigned int prismNotWall = fv_encode_elem_header
+    (
+        FV_PRISM_ELEM_ID, notWallFlags.begin()
+    );
+    unsigned int hexNotWall = fv_encode_elem_header
+    (
+        FV_HEX_ELEM_ID, notWallFlags.begin()
+    );
+
+    // Some aliases
+    const cellList& cellFaces = mesh.cells();
+    const cellShapeList& cellShapes = mesh.cellShapes();
+
+
+    label hexi = 0;
+    label prismi = 0;
+    label pyri = 0;
+    label teti = 0;
+
+    const faceList& allFaces = mesh.faces();
+
+    List<int> wallFlags(6);
+    forAll(cellShapes, celli)
+    {
+        const cellShape& cellShape = cellShapes[celli];
+        const cellModel& cellModel = cellShape.model();
+
+        if (cellModel == tet)
+        {
+            if (!wallCell[celli])
+            {
+                tetLabels_[teti++] = tetNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[0]];
+                wallFlags[1] = wallFace[modelToMesh[1]];
+                wallFlags[2] = wallFace[modelToMesh[2]];
+                wallFlags[3] = wallFace[modelToMesh[3]];
+
+                tetLabels_[teti++] = fv_encode_elem_header
+                (
+                    FV_TET_ELEM_ID, wallFlags.begin()
+                );
+            }
+
+            tetLabels_[teti++] = cellShape[0] + 1;
+            tetLabels_[teti++] = cellShape[1] + 1;
+            tetLabels_[teti++] = cellShape[2] + 1;
+            tetLabels_[teti++] = cellShape[3] + 1;
+        }
+        else if (cellModel == pyr)
+        {
+            if (!wallCell[celli])
+            {
+                pyrLabels_[pyri++] = pyrNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[0]];
+                wallFlags[1] = wallFace[modelToMesh[3]];
+                wallFlags[2] = wallFace[modelToMesh[2]];
+                wallFlags[3] = wallFace[modelToMesh[1]];
+                wallFlags[4] = wallFace[modelToMesh[4]];
+
+                pyrLabels_[pyri++] = fv_encode_elem_header
+                (
+                    FV_PYRA_ELEM_ID, wallFlags.begin()
+                );
+            }
+
+            pyrLabels_[pyri++] = cellShape[0] + 1;
+            pyrLabels_[pyri++] = cellShape[1] + 1;
+            pyrLabels_[pyri++] = cellShape[2] + 1;
+            pyrLabels_[pyri++] = cellShape[3] + 1;
+            pyrLabels_[pyri++] = cellShape[4] + 1;
+        }
+        else if (cellModel == prism)
+        {
+            if (!wallCell[celli])
+            {
+                prismLabels_[prismi++] = prismNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[4]];
+                wallFlags[1] = wallFace[modelToMesh[2]];
+                wallFlags[2] = wallFace[modelToMesh[3]];
+                wallFlags[3] = wallFace[modelToMesh[0]];
+                wallFlags[4] = wallFace[modelToMesh[1]];
+
+                prismLabels_[prismi++] = fv_encode_elem_header
+                (
+                    FV_PRISM_ELEM_ID, wallFlags.begin()
+                );
+            }
+
+            prismLabels_[prismi++] = cellShape[0] + 1;
+            prismLabels_[prismi++] = cellShape[3] + 1;
+            prismLabels_[prismi++] = cellShape[4] + 1;
+            prismLabels_[prismi++] = cellShape[1] + 1;
+            prismLabels_[prismi++] = cellShape[5] + 1;
+            prismLabels_[prismi++] = cellShape[2] + 1;
+        }
+        else if (cellModel == tetWedge)
+        {
+            // Treat as prism with collapsed edge
+            if (!wallCell[celli])
+            {
+                prismLabels_[prismi++] = prismNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[1]];
+                wallFlags[1] = wallFace[modelToMesh[2]];
+                wallFlags[2] = wallFace[modelToMesh[3]];
+                wallFlags[3] = wallFace[modelToMesh[0]];
+                wallFlags[4] = wallFace[modelToMesh[3]];
+
+                prismLabels_[prismi++] = fv_encode_elem_header
+                (
+                    FV_PRISM_ELEM_ID, wallFlags.begin()
+                );
+            }
+
+            prismLabels_[prismi++] = cellShape[0] + 1;
+            prismLabels_[prismi++] = cellShape[3] + 1;
+            prismLabels_[prismi++] = cellShape[4] + 1;
+            prismLabels_[prismi++] = cellShape[1] + 1;
+            prismLabels_[prismi++] = cellShape[4] + 1;
+            prismLabels_[prismi++] = cellShape[2] + 1;
+        }
+        else if (cellModel == wedge)
+        {
+            if (!wallCell[celli])
+            {
+                hexLabels_[hexi++] = hexNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[2]];
+                wallFlags[1] = wallFace[modelToMesh[3]];
+                wallFlags[2] = wallFace[modelToMesh[0]];
+                wallFlags[3] = wallFace[modelToMesh[1]];
+                wallFlags[4] = wallFace[modelToMesh[4]];
+                wallFlags[5] = wallFace[modelToMesh[5]];
+
+                hexLabels_[hexi++] = fv_encode_elem_header
+                (
+                    FV_HEX_ELEM_ID, wallFlags.begin()
+                );
+            }
+            hexLabels_[hexi++] = cellShape[0] + 1;
+            hexLabels_[hexi++] = cellShape[1] + 1;
+            hexLabels_[hexi++] = cellShape[0] + 1;
+            hexLabels_[hexi++] = cellShape[2] + 1;
+            hexLabels_[hexi++] = cellShape[3] + 1;
+            hexLabels_[hexi++] = cellShape[4] + 1;
+            hexLabels_[hexi++] = cellShape[6] + 1;
+            hexLabels_[hexi++] = cellShape[5] + 1;
+        }
+        else if (cellModel == hex)
+        {
+            if (!wallCell[celli])
+            {
+                hexLabels_[hexi++] = hexNotWall;
+            }
+            else
+            {
+                labelList modelToMesh = calcFaceAddressing
+                (
+                    allFaces, cellShape, cellFaces[celli], celli
+                );
+
+                wallFlags[0] = wallFace[modelToMesh[0]];
+                wallFlags[1] = wallFace[modelToMesh[1]];
+                wallFlags[2] = wallFace[modelToMesh[4]];
+                wallFlags[3] = wallFace[modelToMesh[5]];
+                wallFlags[4] = wallFace[modelToMesh[2]];
+                wallFlags[5] = wallFace[modelToMesh[3]];
+
+                hexLabels_[hexi++] = fv_encode_elem_header
+                (
+                    FV_HEX_ELEM_ID, wallFlags.begin()
+                );
+            }
+            hexLabels_[hexi++] = cellShape[0] + 1;
+            hexLabels_[hexi++] = cellShape[1] + 1;
+            hexLabels_[hexi++] = cellShape[3] + 1;
+            hexLabels_[hexi++] = cellShape[2] + 1;
+            hexLabels_[hexi++] = cellShape[4] + 1;
+            hexLabels_[hexi++] = cellShape[5] + 1;
+            hexLabels_[hexi++] = cellShape[7] + 1;
+            hexLabels_[hexi++] = cellShape[6] + 1;
+        }
+        else
+        {
+            nPoly_++;
+        }
+    }
+
+    hexLabels_.setSize(hexi);
+    prismLabels_.setSize(prismi);
+    pyrLabels_.setSize(pyri);
+    tetLabels_.setSize(teti);
+
+
+    //
+    // Patches
+    //
+    forAll(mesh.boundaryMesh(), patchI)
+    {
+        const polyPatch& patchFaces = mesh.boundaryMesh()[patchI];
+
+        labelList& faceLabels = quadFaceLabels_[patchI];
+
+        // Faces, each 4 labels. Size big enough
+        faceLabels.setSize(patchFaces.size()*4);
+
+        label labelI = 0;
+
+        forAll(patchFaces, faceI)
+        {
+            const face& patchFace = patchFaces[faceI];
+
+            if (patchFace.size() == 3)
+            {
+                faceLabels[labelI++] = patchFace[0] + 1;
+                faceLabels[labelI++] = patchFace[1] + 1;
+                faceLabels[labelI++] = patchFace[2] + 1;
+                faceLabels[labelI++] = 0;   // Fieldview:triangle definition
+            }
+            else if (patchFace.size() == 4)
+            {
+                faceLabels[labelI++] = patchFace[0] + 1;
+                faceLabels[labelI++] = patchFace[1] + 1;
+                faceLabels[labelI++] = patchFace[2] + 1;
+                faceLabels[labelI++] = patchFace[3] + 1;
+            }
+        }
+
+        faceLabels.setSize(labelI);
+
+        label nFaces = labelI/4;
+
+        nPolyFaces_[patchI] = patchFaces.size() - nFaces;
+    }
+}
+
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,7 @@
+foamToFieldview9.C
+fieldviewTopology.C
+write_binary_uns.c
+calcFaceAddressing.C
+writeFunctions.C
+
+EXE = $(FOAM_APPBIN)/foamToFieldview9
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,10 @@
+EXE_INC = \
+    -I$(LIB_SRC)/finiteVolume/lnInclude \
+    -I$(LIB_SRC)/meshTools/lnInclude \
+    -I$(LIB_SRC)/lagrangian/basic/lnInclude
+
+EXE_LIBS = \
+    -lfiniteVolume \
+    -lmeshTools \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -llagrangian
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/getFieldNames.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/getFieldNames.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,68 @@
+HashSet<word> volScalarHash;
+HashSet<word> volVectorHash;
+HashSet<word> surfScalarHash;
+HashSet<word> surfVectorHash;
+HashSet<word> sprayScalarHash;
+HashSet<word> sprayVectorHash;
+
+forAll(timeDirs, timeI)
+{
+    runTime.setTime(timeDirs[timeI], timeI);
+
+    // Add all fields to hashtable
+    IOobjectList objects(mesh, runTime.timeName());
+    {
+        wordList fieldNames(objects.names(volScalarField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            volScalarHash.insert(fieldNames[fieldI]);
+        }
+    }
+    {
+        wordList fieldNames(objects.names(volVectorField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            volVectorHash.insert(fieldNames[fieldI]);
+        }
+    }
+    {
+        wordList fieldNames(objects.names(surfaceScalarField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            surfScalarHash.insert(fieldNames[fieldI]);
+        }
+    }
+    {
+        wordList fieldNames(objects.names(surfaceVectorField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            surfVectorHash.insert(fieldNames[fieldI]);
+        }
+    }
+
+
+    // Same for spray
+    IOobjectList sprayObjects(mesh, runTime.timeName(), cloud::prefix);
+    {
+        wordList fieldNames(sprayObjects.names(scalarIOField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            sprayScalarHash.insert(fieldNames[fieldI]);
+        }
+    }
+    {
+        wordList fieldNames(sprayObjects.names(vectorIOField::typeName));
+        forAll(fieldNames, fieldI)
+        {
+            sprayVectorHash.insert(fieldNames[fieldI]);
+        }
+    }
+}
+
+
+wordList volScalarNames(volScalarHash.toc());
+wordList volVectorNames(volVectorHash.toc());
+wordList surfScalarNames(surfScalarHash.toc());
+wordList surfVectorNames(surfVectorHash.toc());
+wordList sprayScalarNames(sprayScalarHash.toc());
+wordList sprayVectorNames(sprayVectorHash.toc());
--- applications/utilities/postProcessing/dataConversion/foamToFieldView9/foamToFieldview9.C	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/postProcessing/dataConversion/foamToFieldView9/foamToFieldview9.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,1009 @@
+/*---------------------------------------------------------------------------*\
+  =========                 |
+  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
+   \\    /   O peration     |
+    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
+     \\/     M anipulation  |
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Description
+    Write out the OpenFOAM mesh in Version 3.0 Fieldview-UNS format (binary).
+
+    See Fieldview Release 9 Reference Manual - Appendix D
+    (Unstructured Data Format)
+    Borrows various from uns/write_binary_uns.c from FieldView dist.
+
+\*---------------------------------------------------------------------------*/
+
+#include "argList.H"
+#include "timeSelector.H"
+#include "volFields.H"
+#include "surfaceFields.H"
+#include "pointFields.H"
+#include "scalarIOField.H"
+#include "volPointInterpolation.H"
+#include "wallFvPatch.H"
+#include "symmetryFvPatch.H"
+
+#include "Cloud.H"
+#include "passiveParticle.H"
+
+#include "IOobjectList.H"
+#include "boolList.H"
+#include "stringList.H"
+#include "cellModeller.H"
+
+#include "floatScalar.H"
+#include "calcFaceAddressing.H"
+#include "writeFunctions.H"
+#include "fieldviewTopology.H"
+
+#include <fstream>
+
+#include "fv_reader_tags.h"
+
+extern "C"
+{
+    unsigned int fv_encode_elem_header(int elem_type, int wall_info[]);
+}
+
+using namespace Foam;
+
+typedef Field<floatScalar> floatField;
+
+
+static HashTable<word> FieldviewNames;
+
+
+static word getFieldViewName(const word& foamName)
+{
+    if (FieldviewNames.found(foamName))
+    {
+        return FieldviewNames[foamName];
+    }
+    else
+    {
+        return foamName;
+    }
+}
+
+
+static void printNames(const wordList& names, Ostream& os)
+{
+    forAll(names, fieldI)
+    {
+        Info<< " " << names[fieldI] << '/' << getFieldViewName(names[fieldI]);
+    }
+}
+
+
+// Count number of vertices used by celli
+static label countVerts(const primitiveMesh& mesh, const label celli)
+{
+    const cell& cll = mesh.cells()[celli];
+
+    // Count number of vertices used
+    labelHashSet usedVerts(10*cll.size());
+
+    forAll(cll, cellFacei)
+    {
+        const face& f = mesh.faces()[cll[cellFacei]];
+
+        forAll(f, fp)
+        {
+            if (!usedVerts.found(f[fp]))
+            {
+                usedVerts.insert(f[fp]);
+            }
+        }
+    }
+    return usedVerts.toc().size();
+}
+
+
+static void writeFaceData
+(
+    const polyMesh& mesh,
+    const fieldviewTopology& topo,
+    const label patchI,
+    const scalarField& patchField,
+    const bool writePolyFaces,
+    std::ofstream& fvFile
+)
+{
+    const polyPatch& pp = mesh.boundaryMesh()[patchI];
+
+    // Start off with dummy value.
+    if (writePolyFaces)
+    {
+        floatField fField(topo.nPolyFaces()[patchI], 0.0);
+
+        // Fill selected faces with field values
+        label polyFaceI = 0;
+        forAll(patchField, faceI)
+        {
+            if (pp[faceI].size() > 4)
+            {
+                fField[polyFaceI++] = float(patchField[faceI]);
+            }
+        }
+
+        fvFile.write
+        (
+            reinterpret_cast<char*>(fField.begin()), fField.size()*sizeof(float)
+        );
+    }
+    else
+    {
+        floatField fField(pp.size() - topo.nPolyFaces()[patchI], 0.0);
+
+        // Fill selected faces with field values
+        label quadFaceI = 0;
+        forAll(patchField, faceI)
+        {
+            if (pp[faceI].size() <= 4)
+            {
+                fField[quadFaceI++] = float(patchField[faceI]);
+            }
+        }
+
+        fvFile.write
+        (
+            reinterpret_cast<char*>(fField.begin()), fField.size()*sizeof(float)
+        );
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+// Main program:
+
+int main(int argc, char *argv[])
+{
+    argList::noParallel();
+    argList::addBoolOption
+    (
+        "noWall",
+        "skip setting wall information"
+    );
+    timeSelector::addOptions(true, false);
+
+#   include "addRegionOption.H"
+
+#   include "setRootCase.H"
+#   include "createTime.H"
+
+    instantList timeDirs = timeSelector::select0(runTime, args);
+
+#   include "createNamedMesh.H"
+
+    // Initialize name mapping table
+    FieldviewNames.insert("alpha", "aalpha");
+    FieldviewNames.insert("Alpha", "AAlpha");
+    FieldviewNames.insert("fsmach", "ffsmach");
+    FieldviewNames.insert("FSMach", "FFSMach");
+    FieldviewNames.insert("re", "rre");
+    FieldviewNames.insert("Re", "RRe");
+    FieldviewNames.insert("time", "ttime");
+    FieldviewNames.insert("Time", "TTime");
+    FieldviewNames.insert("pi", "ppi");
+    FieldviewNames.insert("PI", "PPI");
+    FieldviewNames.insert("x", "xx");
+    FieldviewNames.insert("X", "XX");
+    FieldviewNames.insert("y", "yy");
+    FieldviewNames.insert("Y", "YY");
+    FieldviewNames.insert("z", "zz");
+    FieldviewNames.insert("Z", "ZZ");
+    FieldviewNames.insert("rcyl", "rrcyl");
+    FieldviewNames.insert("Rcyl", "RRcyl");
+    FieldviewNames.insert("theta", "ttheta");
+    FieldviewNames.insert("Theta", "TTheta");
+    FieldviewNames.insert("rsphere", "rrsphere");
+    FieldviewNames.insert("Rsphere", "RRsphere");
+    FieldviewNames.insert("k", "kk");
+    FieldviewNames.insert("K", "KK");
+
+
+    // Scan for all available fields, in all timesteps
+    //     volScalarNames  : all scalar fields
+    //     volVectorNames  : ,,  vector ,,
+    //     surfScalarNames : surface fields
+    //     surfVectorNames : ,,
+    //     sprayScalarNames: spray fields
+    //     sprayVectorNames: ,,
+#   include "getFieldNames.H"
+
+    bool hasLagrangian = false;
+    if (sprayScalarNames.size() || sprayVectorNames.size())
+    {
+        hasLagrangian = true;
+    }
+
+    Info<< "All fields:   Foam/Fieldview" << endl;
+    Info<< "    volScalar   :";
+    printNames(volScalarNames, Info);
+    Info<< endl;
+    Info<< "    volVector   :";
+    printNames(volVectorNames, Info);
+    Info<< endl;
+    Info<< "    surfScalar  :";
+    printNames(surfScalarNames, Info);
+    Info<< endl;
+    Info<< "    surfVector  :";
+    printNames(surfVectorNames, Info);
+    Info<< endl;
+    Info<< "    sprayScalar :";
+    printNames(sprayScalarNames, Info);
+    Info<< endl;
+    Info<< "    sprayVector :";
+    printNames(sprayVectorNames, Info);
+    Info<< endl;
+
+
+    //
+    // Start writing
+    //
+
+    // make a directory called FieldView in the case
+    fileName fvPath(runTime.path()/"Fieldview");
+
+    if (regionName != polyMesh::defaultRegion)
+    {
+        fvPath = fvPath/regionName;
+    }
+
+    if (isDir(fvPath))
+    {
+        if (regionName != polyMesh::defaultRegion)
+        {
+            Info<< "Keeping old FieldView files in " << fvPath << nl << endl;
+        }
+        else
+        {
+            Info<< "Deleting old FieldView files in " << fvPath << nl << endl;
+            rmDir(fvPath);
+        }
+    }
+
+    mkDir(fvPath);
+
+    fileName fvParticleFileName(fvPath/runTime.caseName() + ".fvp");
+    if (hasLagrangian)
+    {
+        Info<< "Opening particle file " << fvParticleFileName << endl;
+    }
+    std::ofstream fvParticleFile(fvParticleFileName.c_str());
+
+    // Write spray file header
+    if (hasLagrangian)
+    {
+#       include "writeSprayHeader.H"
+    }
+
+    // Current mesh. Start off from unloaded mesh.
+    autoPtr<fieldviewTopology> topoPtr(NULL);
+
+    label fieldViewTime = 0;
+
+    forAll(timeDirs, timeI)
+    {
+        runTime.setTime(timeDirs[timeI], timeI);
+        Info<< "Time: " << runTime.timeName() << endl;
+
+        fvMesh::readUpdateState state = mesh.readUpdate();
+
+        if
+        (
+            timeI == 0
+         || state == fvMesh::TOPO_CHANGE
+         || state == fvMesh::TOPO_PATCH_CHANGE
+        )
+        {
+            // Mesh topo changed. Update Fieldview topo.
+
+            topoPtr.reset
+            (
+                new fieldviewTopology
+                (
+                    mesh,
+                    !args.optionFound("noWall")
+                )
+            );
+
+            Info<< "    Mesh read:" << endl
+                << "        tet   : " << topoPtr().nTet() << endl
+                << "        hex   : " << topoPtr().nHex() << endl
+                << "        prism : " << topoPtr().nPrism() << endl
+                << "        pyr   : " << topoPtr().nPyr() << endl
+                << "        poly  : " << topoPtr().nPoly() << endl
+                << endl;
+        }
+        else if (state == fvMesh::POINTS_MOVED)
+        {
+            // points exists for time step, let's read them
+            Info<< "    Points file detected - updating points" << endl;
+        }
+
+        const fieldviewTopology& topo = topoPtr();
+
+
+        //
+        // Create file and write header
+        //
+
+        fileName fvFileName
+        (
+            fvPath/runTime.caseName() + "_" + Foam::name(timeI) + ".uns"
+        );
+
+        Info<< "    file:" << fvFileName.c_str() << endl;
+
+
+        std::ofstream fvFile(fvFileName.c_str());
+
+        //Info<< "Writing header ..." << endl;
+
+        // Output the magic number.
+        writeInt(fvFile, FV_MAGIC);
+
+        // Output file header and version number.
+        writeStr80(fvFile, "FIELDVIEW");
+
+        // This version of the FIELDVIEW unstructured file is "3.0".
+        // This is written as two integers.
+        writeInt(fvFile, 3);
+        writeInt(fvFile, 0);
+
+
+        // File type code. Grid and results.
+        writeInt(fvFile, FV_COMBINED_FILE);
+
+        // Reserved field, always zero
+        writeInt(fvFile, 0);
+
+        // Output constants for time, fsmach, alpha and re.
+        float fBuf[4];
+        fBuf[0] = runTime.value();
+        fBuf[1] = 0.0;
+        fBuf[2] = 0.0;
+        fBuf[3] = 1.0;
+        fvFile.write(reinterpret_cast<char*>(fBuf), 4*sizeof(float));
+
+
+        // Output the number of grids
+        writeInt(fvFile, 1);
+
+
+        //
+        //  Boundary table
+        //
+        //Info<< "Writing boundary table ..." << endl;
+
+        // num patches
+        writeInt(fvFile, mesh.boundary().size());
+
+        forAll(mesh.boundary(), patchI)
+        {
+            const fvPatch& currPatch = mesh.boundary()[patchI];
+
+            writeInt(fvFile, 1);   // data present
+            writeInt(fvFile, 1);   // normals ok
+
+            // name
+            writeStr80(fvFile, currPatch.name().c_str());
+        }
+
+
+        //
+        // Create fields:
+        //     volFieldPtrs     : List of ptrs to all volScalar/Vector fields
+        //                        (null if field not present at current time)
+        //     volFieldNames    : FieldView compatible names of volFields
+        //     surfFieldPtrs    : same for surfaceScalar/Vector
+        //     surfFieldNames
+#       include "createFields.H"
+
+
+
+        //
+        // Write Variables table
+        //
+
+        //Info<< "Writing variables table ..." << endl;
+
+        writeInt(fvFile, volFieldNames.size());
+        forAll(volFieldNames, fieldI)
+        {
+            if (volFieldPtrs[fieldI] == NULL)
+            {
+                Info<< "    dummy field for "
+                    << volFieldNames[fieldI].c_str() << endl;
+            }
+
+            writeStr80(fvFile, volFieldNames[fieldI].c_str());
+        }
+
+        //
+        // Write Boundary Variables table = vol + surface fields
+        //
+
+        //Info<< "Writing boundary variables table ..." << endl;
+
+        writeInt
+        (
+            fvFile,
+            volFieldNames.size() + surfFieldNames.size()
+        );
+        forAll(volFieldNames, fieldI)
+        {
+            writeStr80(fvFile, volFieldNames[fieldI].c_str());
+        }
+        forAll(surfFieldNames, fieldI)
+        {
+            if (surfFieldPtrs[fieldI] == NULL)
+            {
+                Info<< "    dummy surface field for "
+                    << surfFieldNames[fieldI].c_str() << endl;
+            }
+
+            writeStr80(fvFile, surfFieldNames[fieldI].c_str());
+        }
+
+
+        // Output grid data.
+
+        //
+        // Nodes
+        //
+
+        //Info<< "Writing points ..." << endl;
+
+        const pointField& points = mesh.points();
+        label nPoints = points.size();
+
+        writeInt(fvFile, FV_NODES);
+        writeInt(fvFile, nPoints);
+
+        for (direction cmpt=0; cmpt<vector::nComponents; cmpt++)
+        {
+            floatField fField(nPoints);
+
+            for (label pointi = 0; pointi<nPoints; pointi++)
+            {
+                fField[pointi] = float(points[pointi][cmpt]);
+            }
+
+            fvFile.write
+            (
+                reinterpret_cast<char*>(fField.begin()),
+                fField.size()*sizeof(float)
+            );
+        }
+
+        //
+        // Boundary Faces - regular
+        //
+
+        //Info<< "Writing regular boundary faces ..." << endl;
+
+        forAll(mesh.boundary(), patchI)
+        {
+            label nQuadFaces = topo.quadFaceLabels()[patchI].size()/4;
+
+            if (nQuadFaces != 0)
+            {
+                writeInt(fvFile, FV_FACES);
+                writeInt(fvFile, patchI + 1);  // patch number
+                writeInt(fvFile, nQuadFaces);  // number of faces in patch
+                fvFile.write
+                (
+                    reinterpret_cast<const char*>
+                        (topo.quadFaceLabels()[patchI].begin()),
+                    nQuadFaces*4*sizeof(int)
+                );
+            }
+        }
+
+        //
+        // Boundary Faces - arbitrary polygon
+        //
+
+        //Info<< "Write polygonal boundary faces ..." << endl;
+
+        forAll(mesh.boundary(), patchI)
+        {
+            if (topo.nPolyFaces()[patchI] > 0)
+            {
+                writeInt(fvFile, FV_ARB_POLY_FACES);
+                writeInt(fvFile, patchI + 1);
+
+                // number of arb faces in patch
+                writeInt(fvFile, topo.nPolyFaces()[patchI]);
+
+                const polyPatch& patchFaces = mesh.boundary()[patchI].patch();
+
+                forAll(patchFaces, faceI)
+                {
+                    const face& f = patchFaces[faceI];
+
+                    if (f.size() > 4)
+                    {
+                        writeInt(fvFile, f.size());
+
+                        forAll(f, fp)
+                        {
+                            writeInt(fvFile, f[fp] + 1);
+                        }
+                    }
+                }
+            }
+        }
+
+
+        //
+        // Write regular topology
+        //
+
+        //Info<< "Writing regular elements ..." << endl;
+
+        writeInt(fvFile, FV_ELEMENTS);
+        writeInt(fvFile, topo.nTet());
+        writeInt(fvFile, topo.nHex());
+        writeInt(fvFile, topo.nPrism());
+        writeInt(fvFile, topo.nPyr());
+        fvFile.write
+        (
+            reinterpret_cast<const char*>(topo.tetLabels().begin()),
+            topo.nTet()*(1+4)*sizeof(int)
+        );
+        fvFile.write
+        (
+            reinterpret_cast<const char*>(topo.hexLabels().begin()),
+            topo.nHex()*(1+8)*sizeof(int)
+        );
+        fvFile.write
+        (
+            reinterpret_cast<const char*>(topo.prismLabels().begin()),
+            topo.nPrism()*(1+6)*sizeof(int)
+        );
+        fvFile.write
+        (
+            reinterpret_cast<const char*>(topo.pyrLabels().begin()),
+            topo.nPyr()*(1+5)*sizeof(int)
+        );
+
+
+        //
+        // Write arbitrary polyhedra
+        //
+
+        //Info<< "Writing polyhedral elements ..." << endl;
+
+
+        const cellShapeList& cellShapes = mesh.cellShapes();
+        const cellModel& unknown = *(cellModeller::lookup("unknown"));
+
+        if (topo.nPoly() > 0)
+        {
+            writeInt(fvFile, FV_ARB_POLY_ELEMENTS);
+            writeInt(fvFile, topo.nPoly());
+
+            forAll(cellShapes, celli)
+            {
+                if (cellShapes[celli].model() == unknown)
+                {
+                    const cell& cll = mesh.cells()[celli];
+
+                    // number of faces
+                    writeInt(fvFile, cll.size());
+                    // number of vertices used (no cell centre)
+                    writeInt(fvFile, countVerts(mesh, celli));
+                    // cell centre node id
+                    writeInt(fvFile, -1);
+
+                    forAll(cll, cellFacei)
+                    {
+                        label faceI = cll[cellFacei];
+
+                        const face& f = mesh.faces()[faceI];
+
+                        // Not a wall for now
+                        writeInt(fvFile, NOT_A_WALL);
+
+                        writeInt(fvFile, f.size());
+
+                        if (mesh.faceOwner()[faceI] == celli)
+                        {
+                            forAll(f, fp)
+                            {
+                                writeInt(fvFile, f[fp]+1);
+                            }
+                        }
+                        else
+                        {
+                            for (label fp = f.size()-1; fp >= 0; fp--)
+                            {
+                                writeInt(fvFile, f[fp]+1);
+                            }
+                        }
+
+                        // Number of hanging nodes
+                        writeInt(fvFile, 0);
+                    }
+                }
+            }
+        }
+
+
+        //
+        // Variables data
+        //
+
+        //Info<< "Writing variables data ..." << endl;
+
+        volPointInterpolation pInterp(mesh);
+
+        writeInt(fvFile, FV_VARIABLES);
+
+
+        forAll(volFieldPtrs, fieldI)
+        {
+            if (volFieldPtrs[fieldI] != NULL)
+            {
+                const volScalarField& vField = *volFieldPtrs[fieldI];
+
+                // Interpolate to points
+                pointScalarField psf(pInterp.interpolate(vField));
+
+                floatField fField(nPoints);
+
+                for (label pointi = 0; pointi<nPoints; pointi++)
+                {
+                    fField[pointi] = float(psf[pointi]);
+                }
+
+                fvFile.write
+                (
+                    reinterpret_cast<char*>(fField.begin()),
+                    fField.size()*sizeof(float)
+                );
+            }
+            else
+            {
+                // Create dummy field
+                floatField dummyField(nPoints, 0.0);
+
+                fvFile.write
+                (
+                    reinterpret_cast<char*>(dummyField.begin()),
+                    dummyField.size()*sizeof(float)
+                );
+            }
+        }
+
+
+        //
+        // Boundary variables data
+        //     1. volFields
+        //     2. surfFields
+
+        //Info<< "Writing regular boundary elements data ..." << endl;
+
+        writeInt(fvFile, FV_BNDRY_VARS);
+
+        forAll(volFieldPtrs, fieldI)
+        {
+            if (volFieldPtrs[fieldI] != NULL)
+            {
+                const volScalarField& vsf = *volFieldPtrs[fieldI];
+
+                forAll(mesh.boundary(), patchI)
+                {
+                    writeFaceData
+                    (
+                        mesh,
+                        topo,
+                        patchI,
+                        vsf.boundaryField()[patchI],
+                        false,
+                        fvFile
+                    );
+                }
+            }
+            else
+            {
+                forAll(mesh.boundaryMesh(), patchI)
+                {
+                    // Dummy value.
+                    floatField fField
+                    (
+                        mesh.boundaryMesh()[patchI].size()
+                      - topo.nPolyFaces()[patchI],
+                        0.0
+                    );
+
+                    fvFile.write
+                    (
+                        reinterpret_cast<char*>(fField.begin()),
+                        fField.size()*sizeof(float)
+                    );
+                }
+            }
+        }
+
+        // surfFields
+        forAll(surfFieldPtrs, fieldI)
+        {
+            if (surfFieldPtrs[fieldI] != NULL)
+            {
+                const surfaceScalarField& ssf = *surfFieldPtrs[fieldI];
+
+                forAll(mesh.boundary(), patchI)
+                {
+                    writeFaceData
+                    (
+                        mesh,
+                        topo,
+                        patchI,
+                        ssf.boundaryField()[patchI],
+                        false,
+                        fvFile
+                    );
+                }
+            }
+            else
+            {
+                forAll(mesh.boundaryMesh(), patchI)
+                {
+                    // Dummy value.
+                    floatField fField
+                    (
+                        mesh.boundaryMesh()[patchI].size()
+                      - topo.nPolyFaces()[patchI],
+                        0.0
+                    );
+
+                    fvFile.write
+                    (
+                        reinterpret_cast<char*>(fField.begin()),
+                        fField.size()*sizeof(float)
+                    );
+                }
+            }
+        }
+
+        //
+        // Polygonal faces boundary data
+        //     1. volFields
+        //     2. surfFields
+
+        //Info<< "Writing polygonal boundary elements data ..." << endl;
+
+        writeInt(fvFile, FV_ARB_POLY_BNDRY_VARS);
+        forAll(volFieldPtrs, fieldI)
+        {
+            if (volFieldPtrs[fieldI] != NULL)
+            {
+                const volScalarField& vsf = *volFieldPtrs[fieldI];
+
+                // All non-empty patches
+                forAll(mesh.boundary(), patchI)
+                {
+                    writeFaceData
+                    (
+                        mesh,
+                        topo,
+                        patchI,
+                        vsf.boundaryField()[patchI],
+                        true,
+                        fvFile
+                    );
+                }
+            }
+            else
+            {
+                forAll(mesh.boundary(), patchI)
+                {
+                    // Dummy value.
+                    floatField fField(topo.nPolyFaces()[patchI], 0.0);
+
+                    fvFile.write
+                    (
+                        reinterpret_cast<char*>(fField.begin()),
+                        fField.size()*sizeof(float)
+                    );
+                }
+            }
+        }
+
+        // surfFields
+        forAll(surfFieldPtrs, fieldI)
+        {
+            if (surfFieldPtrs[fieldI] != NULL)
+            {
+                const surfaceScalarField& ssf = *surfFieldPtrs[fieldI];
+
+                // All non-empty patches
+                forAll(mesh.boundary(), patchI)
+                {
+                    writeFaceData
+                    (
+                        mesh,
+                        topo,
+                        patchI,
+                        ssf.boundaryField()[patchI],
+                        true,
+                        fvFile
+                    );
+                }
+            }
+            else
+            {
+                forAll(mesh.boundaryMesh(), patchI)
+                {
+                    // Dummy value.
+                    floatField fField
+                    (
+                        mesh.boundaryMesh()[patchI].size()
+                      - topo.nPolyFaces()[patchI],
+                        0.0
+                    );
+
+                    fvFile.write
+                    (
+                        reinterpret_cast<char*>(fField.begin()),
+                        fField.size()*sizeof(float)
+                    );
+                }
+            }
+        }
+
+
+        //
+        // Cleanup volume and surface fields
+        //
+        forAll(volFieldPtrs, fieldI)
+        {
+            delete volFieldPtrs[fieldI];
+        }
+        forAll(surfFieldPtrs, fieldI)
+        {
+            delete surfFieldPtrs[fieldI];
+        }
+
+
+
+
+        //
+        // Spray
+        //
+        if (hasLagrangian)
+        {
+            // Read/create fields:
+            //     sprayScalarFieldPtrs: List of ptrs to lagrangian scalfields
+            //     sprayVectorFieldPtrs:               ,,           vec  ,,
+#           include "createSprayFields.H"
+
+
+            // Write time header
+
+            // Time index (FieldView: has to start from 1)
+            writeInt(fvParticleFile, fieldViewTime + 1);
+
+            // Time value
+            writeFloat(fvParticleFile, runTime.value());
+
+            // Read particles
+            Cloud<passiveParticle> parcels(mesh);
+
+            // Num particles
+            writeInt(fvParticleFile, parcels.size());
+
+            Info<< "    Writing " << parcels.size() << " particles." << endl;
+
+
+            //
+            // Output data parcelwise
+            //
+
+            label parcelNo = 0;
+
+
+            for
+            (
+                Cloud<passiveParticle>::iterator elmnt = parcels.begin();
+                elmnt != parcels.end();
+                ++elmnt, parcelNo++
+            )
+            {
+                writeInt(fvParticleFile, parcelNo+1);
+
+                writeFloat(fvParticleFile, elmnt().position().x());
+                writeFloat(fvParticleFile, elmnt().position().y());
+                writeFloat(fvParticleFile, elmnt().position().z());
+
+                forAll(sprayScalarFieldPtrs, fieldI)
+                {
+                    if (sprayScalarFieldPtrs[fieldI] != NULL)
+                    {
+                        const IOField<scalar>& sprayField =
+                            *sprayScalarFieldPtrs[fieldI];
+                        writeFloat
+                        (
+                            fvParticleFile,
+                            sprayField[parcelNo]
+                        );
+                    }
+                    else
+                    {
+                        writeFloat(fvParticleFile, 0.0);
+                    }
+                }
+                forAll(sprayVectorFieldPtrs, fieldI)
+                {
+                    if (sprayVectorFieldPtrs[fieldI] != NULL)
+                    {
+                        const IOField<vector>& sprayVectorField =
+                            *sprayVectorFieldPtrs[fieldI];
+                        const vector& val =
+                            sprayVectorField[parcelNo];
+
+                        writeFloat(fvParticleFile, val.x());
+                        writeFloat(fvParticleFile, val.y());
+                        writeFloat(fvParticleFile, val.z());
+                    }
+                    else
+                    {
+                        writeFloat(fvParticleFile, 0.0);
+                        writeFloat(fvParticleFile, 0.0);
+                        writeFloat(fvParticleFile, 0.0);
+                    }
+                }
+            }
+
+            // increment fieldView particle time
+            fieldViewTime++;
+
+
+            //
+            // Cleanup spray fields
+            //
+            forAll(sprayScalarFieldPtrs, fieldI)
+            {
+                delete sprayScalarFieldPtrs[fieldI];
+            }
+            forAll(sprayVectorFieldPtrs, fieldI)
+            {
+                delete sprayVectorFieldPtrs[fieldI];
+            }
+
+        } // end of hasLagrangian
+    }
+
+    if (!hasLagrangian)
+    {
+        rm(fvParticleFileName);
+    }
+
+    Info<< "End\n" << endl;
+
+    return 0;
+}
+
+
+// ************************************************************************* //
--- applications/utilities/postProcessing/patch/patchIntegrate/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/patch/patchIntegrate/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/patch/patchAverage/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/patch/patchAverage/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/wall/wallHeatFlux/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/wall/wallHeatFlux/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,12 +9,13 @@
 
 EXE_LIBS = \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lLESdeltas \
     -lreactionThermophysicalModels \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lsolidThermo
+
--- applications/utilities/postProcessing/wall/yPlusLES/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/wall/yPlusLES/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,7 +7,8 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 EXE_LIBS = \
-    -lincompressibleLESModels \
+    -lincompressibleLESModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleTurbulenceModel
--- applications/utilities/postProcessing/wall/wallGradU/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/wall/wallGradU/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/wall/yPlusRAS/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/wall/yPlusRAS/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,11 +9,13 @@
 
 EXE_LIBS = \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
-    -lsampling
+    -lsampling \
+    -lincompressibleTurbulenceModel \
+    -lcompressibleTurbulenceModel
--- applications/utilities/postProcessing/wall/wallShearStress/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/wall/wallShearStress/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,9 +6,11 @@
 
 EXE_LIBS = \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleTurbulenceModel \
+    -lcompressibleTurbulenceModel
--- applications/utilities/postProcessing/graphics/ensightFoamReader/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/graphics/ensightFoamReader/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,6 +9,6 @@
     -lOpenFOAM \
     -lfiniteVolume \
     -lmeshTools \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian \
     $(PROJECT_LIBS)
--- applications/utilities/postProcessing/graphics/PV3Readers/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/graphics/PV3Readers/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -16,7 +16,7 @@
     PV3blockMeshReader/Allwmake
     PV3FoamReader/Allwmake
 else
-    echo "ERROR: ParaView not found in $ParaView_DIR"
+    echo "WARNING: ParaView not found in $ParaView_DIR"
 fi
 
 # ----------------------------------------------------------------- end-of-file
--- applications/utilities/postProcessing/graphics/PV3Readers/PV3FoamReader/vtkPV3Foam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/graphics/PV3Readers/PV3FoamReader/vtkPV3Foam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -15,7 +15,7 @@
 LIB_LIBS = \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian \
     -L$(FOAM_LIBBIN) -lvtkPV3Readers \
     $(GLIBS)
--- applications/utilities/postProcessing/velocityField/Q/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/Q/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/Co/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/Co/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/streamFunction/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/streamFunction/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/uprime/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/uprime/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/Lambda2/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/Lambda2/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/Pe/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/Pe/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -10,12 +10,14 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoads \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields \
-    -lmeshTools
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lmeshTools \
+    -lincompressibleTurbulenceModel \
+    -lcompressibleTurbulenceModel
--- applications/utilities/postProcessing/velocityField/Mach/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/Mach/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,6 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lfluidThermophysicalModels \
     -lspecie
--- applications/utilities/postProcessing/velocityField/flowType/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/flowType/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/enstrophy/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/enstrophy/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,4 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/velocityField/vorticity/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/velocityField/vorticity/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,5 +5,5 @@
 EXE_LIBS = \
     $(FOAM_LIBBIN)/postCalc.o \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
 
--- applications/utilities/postProcessing/lagrangian/particleTracks/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/lagrangian/particleTracks/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,5 +8,5 @@
     -lfiniteVolume \
     -lmeshTools \
     -lfileFormats \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian
--- applications/utilities/postProcessing/miscellaneous/ptot/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/miscellaneous/ptot/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/miscellaneous/pdfPlot/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/miscellaneous/pdfPlot/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,5 +4,5 @@
     -I$(LIB_SRC)/sampling/lnInclude
 
 EXE_LIBS = \
-    -ldistributionModels \
+    -ldistributionModels -u distributionModelsLoad \
     -lsampling
--- applications/utilities/postProcessing/miscellaneous/execFlowFunctionObjects/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/miscellaneous/execFlowFunctionObjects/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,11 +7,13 @@
 
 EXE_LIBS = \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleTurbulenceModel \
+    -lcompressibleTurbulenceModel
--- applications/utilities/postProcessing/miscellaneous/wdot/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/miscellaneous/wdot/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/postProcessing/miscellaneous/postChannel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/miscellaneous/postChannel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,5 +6,5 @@
 EXE_LIBS = \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lsampling
--- applications/utilities/postProcessing/foamCalc/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/foamCalc/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,5 +4,5 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lfoamCalcFunctions
--- applications/utilities/postProcessing/stressField/stressComponents/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/stressField/stressComponents/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,6 +5,7 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
-    -lincompressibleRASModels \
-    -lincompressibleTransportModels
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleTransportModels \
+    -lincompressibleTurbulenceModel
--- applications/utilities/postProcessing/turbulence/R/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/turbulence/R/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,11 +9,13 @@
 
 EXE_LIBS = \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
+    -lcompressibleTurbulenceModel \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
+    -lincompressibleTurbulenceModel \
     -lsampling
--- applications/utilities/postProcessing/turbulence/createTurbulenceFields/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/turbulence/createTurbulenceFields/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,7 +5,8 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 EXE_LIBS = \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleTurbulenceModel
--- applications/utilities/postProcessing/scalarField/pPrime2/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/scalarField/pPrime2/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,5 +3,5 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
 
--- applications/utilities/postProcessing/sampling/sample/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/sampling/sample/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,7 +8,7 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
     -lfileFormats \
     -lsampling \
--- applications/utilities/postProcessing/sampling/probeLocations/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/postProcessing/sampling/probeLocations/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,7 +6,7 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
     -lsampling \
     -llagrangian
--- applications/utilities/miscellaneous/foamDebugSwitches/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/miscellaneous/foamDebugSwitches/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,13 +6,13 @@
     -lblockMesh \
     -lchemistryModel \
     -lcoalCombustion \
-    -lcompressibleLESModels \
-    -lcompressibleRASModels \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lcompressibleTurbulenceModel \
     -lconversion \
     -ldecompositionMethods \
     -ldistributed \
-    -ldistributionModels \
+    -ldistributionModels -u distributionModelsLoad \
     -ldsmc \
     -ldynamicFvMesh \
     -ldynamicMesh \
@@ -24,16 +24,16 @@
     -lfoamCalcFunctions \
     -lforces \
     -lfvMotionSolvers \
-    -lgenericPatchFields \
-    -lincompressibleLESModels \
-    -lincompressibleRASModels \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -linterfaceProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lIOFunctionObjects \
     -ljobControl \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -llaminarFlameSpeedModels \
     -lLESdeltas \
     -lLESfilters \
@@ -63,5 +63,5 @@
     -lthermophysicalFunctions \
     -ltopoChangerFvMesh \
     -ltriSurface \
-    -ltwoPhaseProperties \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lutilityFunctionObjects
--- applications/utilities/miscellaneous/foamFormatConvert/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/miscellaneous/foamFormatConvert/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,5 +6,5 @@
 EXE_LIBS = \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian
--- applications/utilities/miscellaneous/patchSummary/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/miscellaneous/patchSummary/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/preProcessing/setFields/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/setFields/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,5 +4,5 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools
--- applications/utilities/preProcessing/engineSwirl/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/engineSwirl/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,5 +3,5 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
 
--- applications/utilities/preProcessing/applyBoundaryLayer/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/applyBoundaryLayer/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,8 +8,9 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleLESModels \
     -lincompressibleTransportModels \
-    -lgenericPatchFields \
-    -lmeshTools
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lmeshTools \
+    -lincompressibleTurbulenceModel
--- applications/utilities/preProcessing/mapFields/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/mapFields/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,4 +9,8 @@
     -lmeshTools \
     -llagrangian \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lincompressibleLESModels -u compressibleLESModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/preProcessing/foamUpgradeCyclics/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/foamUpgradeCyclics/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/preProcessing/applyWallFunctionBoundaryConditions/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/preProcessing/applyWallFunctionBoundaryConditions/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,9 +5,11 @@
     -I$(LIB_SRC)/turbulenceModels/compressible/RAS/lnInclude
 
 EXE_LIBS = \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lcompressibleTurbulenceModel \
+    -lincompressibleTurbulenceModel
--- applications/utilities/preProcessing/mapDualFields/setTimeIndex.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/preProcessing/mapDualFields/setTimeIndex.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,32 @@
+    instantList sourceTimes = runTimeSource.times();
+    label sourceTimeIndex = runTimeSource.timeIndex();
+    if (args.optionFound("sourceTime"))
+    {
+        if (args["sourceTime"] == "latestTime")
+        {
+            sourceTimeIndex = sourceTimes.size() - 1;
+        }
+        else
+        {
+            sourceTimeIndex = Time::findClosestTimeIndex
+            (
+                sourceTimes,
+                args.optionRead<scalar>("sourceTime")
+            );
+        }
+    }
+    else
+    {
+        sourceTimeIndex = Time::findClosestTimeIndex
+        (
+            sourceTimes,
+            runTimeTarget.time().value()
+        );
+    }
+
+    runTimeSource.setTime(sourceTimes[sourceTimeIndex], sourceTimeIndex);
+    runTimeTarget.setTime(sourceTimes[sourceTimeIndex], sourceTimeIndex);
+
+    Info<< "\nSource time: " << runTimeSource.value()
+        << "\nTarget time: " << runTimeTarget.value()
+        << endl;
--- applications/utilities/preProcessing/mapDualFields/createTimes.H	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/preProcessing/mapDualFields/createTimes.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,15 @@
+    Info<< "\nCreate databases as time" << endl;
+
+    Time runTimeSource
+    (
+        Time::controlDictName,
+        rootDirSource,
+        caseDirSource
+    );
+
+    Time runTimeTarget
+    (
+        Time::controlDictName,
+        rootDirTarget,
+        caseDirTarget
+    );
--- applications/utilities/preProcessing/mapDualFields/mapDualFields.C	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/preProcessing/mapDualFields/mapDualFields.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,460 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2013 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Application
+    mapDualFields
+
+Description
+    Maps volume and boundary face fields from one mesh to another, reading and
+    interpolating all fields present in the time directory of the source case.
+    Parallel cases need to be reconstructed.
+    Based on mapFields.
+
+\*---------------------------------------------------------------------------*/
+
+#include "fvCFD.H"
+#include "labelListIOList.H"
+#include "IOobjectList.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+
+class MapDualFields
+{
+public:
+  MapDualFields
+  (
+   fvMesh & sourceMesh,
+   fvMesh & targetMesh,
+   const labelListList & cellMap,
+   const labelListList & faceMap
+   );
+
+  void perform();
+
+private:
+  template<class Type>
+  void mapVolFields(const IOobjectList& objects);
+
+  template<class Type>
+  tmp<GeometricField<Type, fvPatchField, volMesh> > interpolate
+  (
+   const GeometricField<Type, fvPatchField, volMesh>& sourceVf
+   );
+
+  template<class Type>
+  void mapCellField
+  (
+   const Field<Type>& sourceF,
+   Field<Type>& targetF
+   );
+
+  template<class Type>
+  void mapFaceField
+  (
+   const fvPatchField<Type> & sourceF,
+   const label sourceStart,
+   fvPatchField<Type> & targetF,
+   const label targetStart
+   );
+
+private:
+  fvMesh & sourceMesh_;
+  fvMesh & targetMesh_;
+  const labelListList & cellMap_;
+  const labelListList & faceMap_;
+}; // class MapDualFields
+
+
+MapDualFields::MapDualFields
+(
+ fvMesh & sourceMesh,
+ fvMesh & targetMesh,
+ const labelListList & cellMap,
+ const labelListList & faceMap
+ )
+  : sourceMesh_(sourceMesh)
+  , targetMesh_(targetMesh)
+  , cellMap_(cellMap)
+  , faceMap_(faceMap)
+{}
+
+
+template<class Type>
+void
+MapDualFields::mapCellField
+(
+ const Field<Type>& sourceF,
+ Field<Type>& targetF
+ )
+{
+  forAll(targetF, cellI)
+    {      
+      const labelList & sourceCells = cellMap_[cellI];
+      targetF[cellI] = pTraits<Type>::zero;
+
+      forAll(sourceCells, sourceCellI)
+	{
+	  targetF[cellI] += sourceF[sourceCells[sourceCellI]];
+	}
+
+      targetF[cellI] /= scalar(sourceCells.size());
+    }
+}
+
+
+template<class Type>
+void
+MapDualFields::mapFaceField
+(
+ const fvPatchField<Type> & sourceF,
+ const label sourceStart,
+ fvPatchField<Type> & targetF,
+ const label targetStart
+ )
+{
+  forAll(targetF, faceI)
+    {      
+      const labelList & sourceFaces = faceMap_[faceI + targetStart];
+      targetF[faceI] = pTraits<Type>::zero;
+
+      forAll(sourceFaces, sourceFaceI)
+	{
+	  targetF[faceI] += sourceF[sourceFaces[sourceFaceI] - sourceStart];
+	}
+
+      targetF[faceI] /= scalar(sourceFaces.size());
+    }
+}
+
+
+template<class Type>
+tmp<GeometricField<Type, fvPatchField, volMesh> > 
+MapDualFields::interpolate
+(
+ const GeometricField<Type, fvPatchField, volMesh>& sourceVf
+ )
+{
+  Field<Type> internalField(targetMesh_.nCells());
+  mapCellField(sourceVf, internalField);
+
+  PtrList<fvPatchField<Type> > patchFields
+    (
+     sourceVf.boundaryField().size()
+     );
+
+  forAll(sourceVf.boundaryField(), patchI)
+    {
+      const label sourceStart = sourceMesh_.boundaryMesh()[patchI].start();
+      const label targetStart = targetMesh_.boundaryMesh()[patchI].start();
+
+      const fvPatchField<Type> & sourceP = sourceVf.boundaryField()[patchI];
+      tmp<fvPatchField<Type> > targetP = fvPatchField<Type>::New
+      (
+       sourceP.type(),
+       targetMesh_.boundary()[patchI],
+       DimensionedField<Type, volMesh>::null()
+       );
+
+      mapFaceField(sourceP, sourceStart, targetP(), targetStart);
+
+      patchFields.set
+        (
+	 patchI,
+	 targetP
+	 );
+    }
+
+  tmp<GeometricField<Type, fvPatchField, volMesh> > ttoF
+    (
+     new GeometricField<Type, fvPatchField, volMesh>
+     (
+      IOobject
+      (
+       "interpolated(" + sourceVf.name() + ')',
+       targetMesh_.time().timeName(),
+       targetMesh_,
+       IOobject::NO_READ,
+       IOobject::NO_WRITE
+       ),
+      targetMesh_,
+      sourceVf.dimensions(),
+      internalField,
+      patchFields
+      )
+     );
+
+  return ttoF;
+}
+
+
+template<class Type>
+void  
+MapDualFields::mapVolFields(const IOobjectList& objects)
+{
+  word fieldClassName
+    (
+     GeometricField<Type, fvPatchField, volMesh>::typeName
+     );
+
+  IOobjectList fields = objects.lookupClass(fieldClassName);
+
+  forAllIter(IOobjectList, fields, fieldIter)
+    {
+      Info<< "    interpolating " << fieldIter()->name()
+	  << endl;
+
+      // Read field
+      GeometricField<Type, fvPatchField, volMesh> sourceField
+        (
+	 *fieldIter(),
+	 sourceMesh_
+	 );
+
+      IOobject targetFieldIOobject
+        (
+	 fieldIter()->name(),
+	 targetMesh_.time().timeName(),
+	 targetMesh_,
+	 IOobject::NO_READ,
+	 IOobject::AUTO_WRITE
+	 );
+
+      GeometricField<Type, fvPatchField, volMesh> targetField
+	(
+	 targetFieldIOobject,
+	 interpolate(sourceField)
+	 );
+
+      targetField.write();
+    }
+}
+
+
+void 
+MapDualFields::perform()
+{
+  {
+    IOobjectList objects(sourceMesh_, sourceMesh_.time().timeName());
+
+    mapVolFields<scalar>(objects);
+    mapVolFields<vector>(objects);
+    mapVolFields<sphericalTensor>(objects);
+    mapVolFields<symmTensor>(objects);
+    mapVolFields<tensor>(objects);
+  }
+}
+
+
+static
+void
+renumberElements
+(
+ const string & name,
+ labelListList & elementMap,
+ fvMesh & sourceMesh,
+ const label elementCount
+ )
+{
+  labelList oldToNewMap;
+
+  {
+    labelIOList newToOldMap
+      (
+       IOobject
+       (
+	name,
+	sourceMesh.facesInstance(),
+	polyMesh::meshSubDir,
+	sourceMesh,
+	IOobject::READ_IF_PRESENT,
+	IOobject::NO_WRITE,
+	false
+	)
+       );
+
+    if (elementCount != newToOldMap.size()) return;
+
+    Info<< "Renumber elements according to: " << name
+	<< endl;
+
+    oldToNewMap.setSize(newToOldMap.size());
+
+    // Invert to give old -> new
+    forAll(newToOldMap, elementI)
+      {
+	oldToNewMap[newToOldMap[elementI]] = elementI;
+      }
+  }
+
+  forAll(elementMap, elementI)
+    {
+      labelList & sourceElements = elementMap[elementI];
+
+      forAll(sourceElements, sourceElementI)
+	{
+	  sourceElements[sourceElementI] = oldToNewMap[sourceElements[sourceElementI]];
+	}
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+int main(int argc, char *argv[])
+{
+  argList::addNote
+    (
+     "map volume and boundary faces fields from dual mesh to original mesh"
+     );
+  argList::noParallel();
+  argList::validArgs.append("sourceCase");
+
+  argList::addOption
+    (
+     "sourceTime",
+     "scalar",
+     "specify the source time"
+     );
+
+  argList args(argc, argv);
+
+  if (!args.check())
+    {
+      FatalError.exit();
+    }
+
+  fileName rootDirTarget(args.rootPath());
+  fileName caseDirTarget(args.globalCaseName());
+
+  const fileName casePath = args[1];
+  const fileName rootDirSource = casePath.path();
+  const fileName caseDirSource = casePath.name();
+
+  Info<< "Source: " << rootDirSource << " " << caseDirSource << endl;
+  word sourceRegion = fvMesh::defaultRegion;
+
+  Info<< "Target: " << rootDirTarget << " " << caseDirTarget << endl;
+  word targetRegion = fvMesh::defaultRegion;
+
+#include "createTimes.H" 
+#include "setTimeIndex.H"
+
+  Info<< "Create meshes\n" << endl;
+
+  fvMesh sourceMesh
+    (
+     IOobject
+     (
+      sourceRegion,
+      runTimeSource.timeName(),
+      runTimeSource
+      )
+     );
+
+  fvMesh targetMesh
+    (
+     IOobject
+     (
+      targetRegion,
+      runTimeTarget.timeName(),
+      runTimeTarget
+      )
+     );
+
+  if (sourceMesh.boundary().size() != targetMesh.boundary().size())
+    {
+      FatalErrorIn
+        (
+	 "mapDualCells"
+	 ) << "Incompatible meshes: different number of boundaries"
+	   << exit(FatalError);
+    }
+  
+  Info<< "Source mesh size: " << sourceMesh.nCells() << tab
+      << "Target mesh size: " << targetMesh.nCells() << nl << endl;
+
+ labelListCompactIOList cellMap
+   (
+    IOobject
+    (
+     "cellDualMap",
+     sourceMesh.facesInstance(),
+     polyMesh::meshSubDir,
+     sourceMesh,
+     IOobject::MUST_READ,
+     IOobject::NO_WRITE,
+     false
+     )
+    );
+  
+  if (cellMap.size() != targetMesh.nCells()) 
+    {
+      FatalErrorIn
+        (
+	 "mapDualFields"
+	 ) << "cellDualMap does not match target mesh"
+	   << exit(FatalError);     
+    }
+
+  renumberElements("cellMap", cellMap, sourceMesh, sourceMesh.nCells());
+
+  labelListCompactIOList faceMap
+    (
+     IOobject
+     (
+      "faceDualMap",
+      sourceMesh.facesInstance(),
+      polyMesh::meshSubDir,
+      sourceMesh,
+      IOobject::MUST_READ,
+      IOobject::NO_WRITE,
+      false
+      )
+     );
+  
+  if (faceMap.size() != targetMesh.nFaces()) 
+    {
+      FatalErrorIn
+        (
+	 "mapDualFields"
+	 ) << "faceDualMap does not match target mesh"
+	   << exit(FatalError);     
+    }
+
+  renumberElements("faceMap", faceMap, sourceMesh, sourceMesh.nFaces());
+
+  Info<< nl
+      << "Creating and mapping fields for time "
+      << sourceMesh.time().timeName() << nl << endl;
+
+  MapDualFields mapDualFields(sourceMesh, 
+			      targetMesh, 
+			      cellMap, 
+			      faceMap);
+  mapDualFields.perform();
+
+  Info<< "\nEnd\n" << endl;
+
+  return 0;
+}
+
+
+// ************************************************************************* //
--- applications/utilities/preProcessing/mapDualFields/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/preProcessing/mapDualFields/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,3 @@
+mapDualFields.C
+
+EXE = $(FOAM_APPBIN)/mapDualFields
--- applications/utilities/preProcessing/mapDualFields/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/preProcessing/mapDualFields/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,8 @@
+EXE_INC = \
+    -I$(LIB_SRC)/finiteVolume/lnInclude
+
+EXE_LIBS = \
+    -lfiniteVolume \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/parallelProcessing/decomposePar/decomposePar.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/parallelProcessing/decomposePar/decomposePar.C	(.../branches/2.2.x-2)	(revision 831)
@@ -67,6 +67,9 @@
     be used with caution when the underlying (serial) geometry or the
     decomposition method etc. have been changed between decompositions.
 
+    \param -numberOfSubdomains n \n
+    Override dictionary entry decomposeParDict.numberOfSubdomains.
+
 \*---------------------------------------------------------------------------*/
 
 #include "OSspecific.H"
@@ -217,9 +220,10 @@
         }
 
         // get requested numberOfSubdomains
-        const label nDomains = readLabel
-        (
-            IOdictionary
+        label nDomains = 0;
+
+	{
+            IOdictionary decomposeParDict
             (
                 IOobject
                 (
@@ -231,9 +235,22 @@
                     IOobject::NO_WRITE,
                     false
                 )
-            ).lookup("numberOfSubdomains")
-        );
+	     );
 
+	    if (args.optionReadIfPresent("numberOfSubdomains", nDomains))
+	      {
+		// Rewrite dictionary for later use by decomposition, e.g., scotchDecomp
+		Info<< "Overriding decomposeParDict.numberOfSubdomains = " << nDomains << nl << endl;
+		decomposeParDict.set("numberOfSubdomains", nDomains);
+		decomposeParDict.regIOobject::write();
+	      }
+	    else 
+	      {
+		nDomains = readLabel(decomposeParDict.lookup("numberOfSubdomains"));
+	      }
+	}
+
+
         if (decomposeFieldsOnly)
         {
             // Sanity check on previously decomposed case
--- applications/utilities/parallelProcessing/decomposePar/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/parallelProcessing/decomposePar/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,8 +9,9 @@
 EXE_LIBS = \
     -lfiniteVolume \
     -ldecompose \
-    -lgenericPatchFields \
-    -ldecompositionMethods -L$(FOAM_LIBBIN)/dummy -lmetisDecomp -lscotchDecomp \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -ldecompositionMethods \
+    -lscotchDecomp -u scotchDecompLoad \
     -llagrangian \
     -lmeshTools \
     -lregionModels
--- applications/utilities/parallelProcessing/redistributePar/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/parallelProcessing/redistributePar/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,7 +6,7 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -ldecompositionMethods \
     -L$(FOAM_LIBBIN)/dummy -lptscotchDecomp \
     -lmeshTools \
--- applications/utilities/parallelProcessing/Allwmake	(.../tags/2.2.x-2)	(revision 0)
+++ applications/utilities/parallelProcessing/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,11 @@
+#!/bin/sh
+set -x
+
+if [ "NONE" = "$WM_MPLIB" ]; then
+    exit 0
+fi
+
+wmake decomposePar
+wmake reconstructPar
+#wmake reconstructParMesh
+#wmake redistributeParMesh
--- applications/utilities/parallelProcessing/reconstructPar/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/parallelProcessing/reconstructPar/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,7 +6,7 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -llagrangian \
     -lmeshTools \
     -lreconstruct \
--- applications/utilities/mesh/manipulation/subsetMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/subsetMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,4 +8,4 @@
     -lfiniteVolume \
     -ldynamicMesh \
     -lmeshTools \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/manipulation/createBaffles/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/createBaffles/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,4 +8,4 @@
     -ldynamicMesh \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/manipulation/renumberMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/renumberMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,7 +12,7 @@
     -lmeshTools \
     -ldynamicMesh \
     -lfiniteVolume \
-    -lgenericPatchFields \
-    -lrenumberMethods \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
+    -lrenumberMethods -u renumberMethodsLoad\
     $(LINK_FLAGS) \
-    -ldecompositionMethods -L$(FOAM_LIBBIN)/dummy -lmetisDecomp -lscotchDecomp
+    -ldecompositionMethods -lscotchDecomp
--- applications/utilities/mesh/manipulation/renumberMesh/renumberMesh.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/renumberMesh/renumberMesh.C	(.../branches/2.2.x-2)	(revision 831)
@@ -635,7 +635,13 @@
         "calculate the rms of the frontwidth"
     );
 
+    argList::addBoolOption
+    (
+        "writeMaps",
+        "write cellMap, faceMap, pointMap in polyMesh/"
+    );
 
+
 // Force linker to include zoltan symbols. This section is only needed since
 // Zoltan is a static library
 #ifdef FOAM_USE_ZOLTAN
@@ -700,7 +706,7 @@
     Info<< endl;
 
     bool sortCoupledFaceCells = false;
-    bool writeMaps = false;
+    bool writeMaps = args.optionFound("writeMaps");
     bool orderPoints = false;
     label blockSize = 0;
 
--- applications/utilities/mesh/manipulation/singleCellMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/singleCellMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -2,6 +2,6 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 EXE_LIBS = \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad\
     -lfiniteVolume
 
--- applications/utilities/mesh/manipulation/mergeOrSplitBaffles/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/mergeOrSplitBaffles/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,6 +5,6 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lmeshTools \
     -ldynamicMesh
--- applications/utilities/mesh/manipulation/splitMeshRegions/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/splitMeshRegions/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,6 +5,6 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -ldynamicMesh \
     -lmeshTools
--- applications/utilities/mesh/manipulation/polyDualMesh/meshDualiser.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/polyDualMesh/meshDualiser.C	(.../branches/2.2.x-2)	(revision 831)
@@ -31,6 +31,7 @@
 #include "edgeFaceCirculator.H"
 #include "mergePoints.H"
 #include "OFstream.H"
+#include "labelListIOList.H"
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
@@ -360,6 +361,11 @@
         zoneFlip        // zoneFlip
     );
 
+    forAll(verts, ptI)
+      {
+	dualPointToDualBoundaryFaces_(verts[ptI]).append(dualFaceI);
+      }
+
     //pointField dualPoints(meshMod.points());
     //vector n(newFace.normal(dualPoints));
     //n /= mag(n);
@@ -1462,4 +1468,85 @@
 }
 
 
+void Foam::meshDualiser::writeMap(const string & name, labelListList & cellMap)
+{
+  labelListCompactIOList ioList
+    (
+     IOobject
+     (
+      name,
+      mesh_.facesInstance(),
+      polyMesh::meshSubDir,
+      mesh_,
+      IOobject::NO_READ,
+      IOobject::NO_WRITE,
+      false
+      ),
+     cellMap
+     );
+  ioList.write();
+}
+
+
+void Foam::meshDualiser::createCellMap(labelListList & cellMap)
+{
+  label pCell;
+  const labelListList & pointCells = mesh_.pointCells();
+
+  forAll(pointCells, ptI)
+    {
+      const labelList & pCells = pointCells[ptI];
+      
+      forAll(pCells, pCellI) 
+	{
+	  pCell = pCells[pCellI];
+	  cellMap[pCell].append(findDualCell(pCell, ptI));
+	}
+    }
+}
+
+
+void Foam::meshDualiser::writeCellMap()
+{
+  labelListList cellMap(mesh_.nCells());
+  createCellMap(cellMap);
+  writeMap("cellDualMap", cellMap);
+}
+
+
+
+void Foam::meshDualiser::createFaceMap(labelListList & faceMap)
+{
+  label face, start;
+  const polyBoundaryMesh & patches = mesh_.boundaryMesh();
+
+  forAll(patches, patchI)
+    {
+      const polyPatch & pp = patches[patchI];
+      start = pp.start();
+
+      forAll(pp, faceI)
+	{
+	  face = start + faceI;
+	  faceMap[face] = dualPointToDualBoundaryFaces_[faceToDualPoint_[face]];
+	}
+    }
+}
+
+
+void Foam::meshDualiser::writeFaceMap()
+{
+  labelListList faceMap(mesh_.nFaces());
+  createFaceMap(faceMap);
+  writeMap("faceDualMap", faceMap);
+}
+
+
+void Foam::meshDualiser::writeMaps()
+{
+  writeCellMap();
+  writeFaceMap();
+}
+
+
 // ************************************************************************* //
--- applications/utilities/mesh/manipulation/polyDualMesh/polyDualMeshApp.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/polyDualMesh/polyDualMeshApp.C	(.../branches/2.2.x-2)	(revision 831)
@@ -73,6 +73,19 @@
 
 using namespace Foam;
 
+namespace Foam
+{
+class polyDualMeshApp
+{
+public: 
+  //- Runtime type information
+  ClassName("polyDualMeshApp");
+}; // class polyDualMeshApp
+
+defineTypeNameAndDebug(polyDualMeshApp, 0);
+}
+
+
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
 // Naive feature detection. All boundary edges with angle > featureAngle become
@@ -374,6 +387,11 @@
         "disable the default behaviour of preserving faceZones by having"
         " multiple faces inbetween cells"
     );
+    argList::addBoolOption
+    (
+        "writeMaps",
+        "write cellMap, faceMap in polyMesh/"
+    );
 
 #   include "setRootCase.H"
 #   include "createTime.H"
@@ -423,6 +441,7 @@
             << nl << endl;
     }
 
+    const bool writeMaps = args.optionFound("writeMaps");
 
     // Face(centre)s that need inclusion in the dual mesh
     labelList featureFaces;
@@ -459,6 +478,8 @@
     }
 
     // Write obj files for debugging
+    if (polyDualMeshApp::debug) 
+      {
     dumpFeatures
     (
         mesh,
@@ -467,9 +488,9 @@
         singleCellFeaturePoints,
         multiCellFeaturePoints
     );
+      }
 
 
-
     // Read objects in time directory
     IOobjectList objects(mesh, runTime.timeName());
 
@@ -524,6 +545,13 @@
         meshMod
     );
 
+    if (writeMaps)
+      {
+        Info<< "Writing cell and face maps (old to new) to polyMesh." << nl
+            << endl;
+        dualMaker.writeMaps();
+      }
+
     // Create mesh, return map from old to new mesh.
     autoPtr<mapPolyMesh> map = meshMod.changeMesh(mesh, false);
 
--- applications/utilities/mesh/manipulation/polyDualMesh/meshDualiser.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/polyDualMesh/meshDualiser.H	(.../branches/2.2.x-2)	(revision 831)
@@ -51,6 +51,7 @@
 #include "PackedBoolList.H"
 #include "boolList.H"
 #include "typeInfo.H"
+#include "Map.H"
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
@@ -86,7 +87,10 @@
         //- From edge to dual point (or -1 if not feature edge)
         labelList edgeToDualPoint_;
 
+  //- Dual point to dual boundary faces
+  mutable Map<labelList> dualPointToDualBoundaryFaces_;
 
+
     // Private Member Functions
 
         static void checkPolyTopoChange(const polyTopoChange&);
@@ -174,7 +178,21 @@
         //- Disallow default bitwise assignment
         void operator=(const meshDualiser&);
 
+  //- Write either cell or face map
+  void writeMap(const string & name, labelListList & cellMap);
 
+  //- Create cell map
+  void createCellMap(labelListList & cellMap);
+
+  //- Create and write cell map
+  void writeCellMap();
+
+  //- Create face map
+  void createFaceMap(labelListList & cellMap);
+
+  //- Create and write face map
+  void writeFaceMap();
+
 public:
 
     //- Runtime type information
@@ -248,6 +266,9 @@
                 const labelList& multiCellFeaturePoints,
                 polyTopoChange& meshMod
             );
+
+  // Write cell and face mappings old -> new, call after setRefinement
+  void writeMaps();
 };
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/utilities/mesh/manipulation/polyDualMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/polyDualMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,6 +5,6 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -ldynamicMesh \
     -lmeshTools
--- applications/utilities/mesh/manipulation/transformPoints/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/transformPoints/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,4 @@
 
 EXE_LIBS = \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/manipulation/stitchMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/manipulation/stitchMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,4 +7,4 @@
     -ldynamicMesh \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/advanced/removeFaces/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/advanced/removeFaces/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,4 +7,4 @@
     -lmeshTools \
     -ldynamicMesh \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/advanced/PDRMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/advanced/PDRMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,4 +7,5 @@
     -lmeshTools \
     -ldynamicMesh \
     -lfiniteVolume \
-    -lcompressibleRASModels
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleTurbulenceModel
--- applications/utilities/mesh/advanced/refineHexMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/advanced/refineHexMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,4 +8,4 @@
     -ldynamicMesh \
     -lmeshTools \
     -lfiniteVolume \
-    -lgenericPatchFields
+    -lgenericPatchFields -u genericPatchFieldsLoad
--- applications/utilities/mesh/conversion/fluentMeshToFoam/fluentMeshToFoam.L	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/conversion/fluentMeshToFoam/fluentMeshToFoam.L	(.../branches/2.2.x-2)	(revision 831)
@@ -114,6 +114,7 @@
 one_space                  [ \t\f]
 space                      {one_space}*
 some_space                 {one_space}+
+comma                      ","
 cspace                     ","{space}
 spaceNl                    ({space}|\n|\r)*
 
@@ -127,7 +128,7 @@
 rbrac                      ")"
 quote                      \"
 dash                       "-"
-dotColonDash               [.:-]
+dotColonPlusDash           [.:+-]
 
 schemeSpecialInitial       [!$%&*/:<=>?~_^#.]
 schemeSpecialSubsequent    [.+-]
@@ -140,7 +141,7 @@
 hexLabel                   {hexDigit}+
 zeroLabel                  {digit}*
 
-word                       ({alpha}|{digit}|{dotColonDash})*
+word                       ({alpha}|{digit}|{dotColonPlusDash})*
 
 exponent_part              [eE][-+]?{digit}+
 fractional_constant        [-+]?(({digit}*"."{digit}+)|({digit}+".")|({digit}))
@@ -816,7 +817,11 @@
 <unknownBlock,embeddedUnknownBlock>{spaceNl}{text} {
     }
 
+ /* ------              Ignore commas.                               ------  */
 
+<*>{comma} {
+    }
+
  /* ------ Ignore remaining space and \n s.  Any other characters are errors. */
 
 <readPoints2D,readPoints3D>.|\n {
--- applications/utilities/mesh/conversion/fluent3DMeshToFoam/fluent3DMeshToFoam.L	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/conversion/fluent3DMeshToFoam/fluent3DMeshToFoam.L	(.../branches/2.2.x-2)	(revision 831)
@@ -137,6 +137,7 @@
 one_space                  [ \t\f]
 space                      {one_space}*
 some_space                 {one_space}+
+comma                      ","
 cspace                     ","{space}
 
 alpha                      [_[:alpha:]]
@@ -149,7 +150,7 @@
 rbrac                      ")"
 quote                      \"
 dash                       "-"
-dotColonDash               [.:-]
+dotColonPlusDash           [.:+-]
 
 schemeSpecialInitial       [!$%&*/\\:<=>?~_^#.@']
 schemeSpecialSubsequent    [.+-]
@@ -162,7 +163,7 @@
 hexLabel                   {hexDigit}+
 zeroLabel                  {digit}*
 signedInteger              [-+]?{integer}
-word                       ({alpha}|{digit}|{dotColonDash})*
+word                       ({alpha}|{digit}|{dotColonPlusDash})*
 wordBraces                 ({word}|{lbrac}|{rbrac})*
 
 exponent_part              [eE][-+]?{digit}+
@@ -740,7 +741,11 @@
 <*>{some_space}|\r {
     }
 
+ /* ------              Ignore commas.                               ------  */
 
+<*>{comma} {
+    }
+
  /* ------              Any other characters are errors.              ------ */
 
 <*>. {
--- applications/utilities/mesh/generation/extrude2DMesh/extrude2DMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/generation/extrude2DMesh/extrude2DMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,7 @@
     -I$(LIB_SRC)/mesh/extrudeModel/lnInclude
 
 LIB_LIBS = \
+    -lextrudeModel \
     -lmeshTools \
     -ldynamicMesh \
     -lsurfMesh \
--- applications/utilities/mesh/generation/snappyHexMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/utilities/mesh/generation/snappyHexMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,7 +12,6 @@
 EXE_LIBS = \
     -lfiniteVolume \
     -ldecompositionMethods \
-    -L$(FOAM_LIBBIN)/dummy -lptscotchDecomp \
     -lmeshTools \
     -lfileFormats \
     -ldynamicMesh \
--- applications/solvers/combustion/chemFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/chemFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -13,10 +13,11 @@
 EXE_LIBS = \
     -lfiniteVolume \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lreactionThermophysicalModels \
     -lfluidThermophysicalModels \
     -lchemistryModel \
     -lODE \
     -lthermophysicalFunctions \
-    -lspecie
+    -lspecie \
+    -lcompressibleTurbulenceModel
--- applications/solvers/combustion/reactingFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/reactingFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -17,8 +17,8 @@
     -lmeshTools \
     -lsampling \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lreactionThermophysicalModels \
     -lspecie \
     -lfluidThermophysicalModels \
--- applications/solvers/combustion/XiFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/XiFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -17,8 +17,8 @@
     -lmeshTools \
     -lengine \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lreactionThermophysicalModels \
     -lspecie \
--- applications/solvers/combustion/PDRFoam/createFields.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/PDRFoam/createFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -1,3 +1,7 @@
+#ifdef MSWIN
+    // Rename B to B_ to prevent name clashes on Windows with B
+    IOobject::replaceFileName("B", "B_");
+#endif
     Info<< "Reading thermophysical properties\n" << endl;
 
     autoPtr<psiuReactionThermo> pThermo
--- applications/solvers/combustion/PDRFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/PDRFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -21,7 +21,7 @@
     -lengine \
     -lmeshTools \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfluidThermophysicalModels \
     -lreactionThermophysicalModels \
     -lspecie \
--- applications/solvers/combustion/engineFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/engineFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -18,8 +18,8 @@
     -lmeshTools \
     -lengine \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lreactionThermophysicalModels \
     -lspecie \
--- applications/solvers/combustion/fireFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/fireFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -34,8 +34,8 @@
     -lfvOptions \
     -lmeshTools \
     -lsampling \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lsolidProperties \
@@ -51,5 +51,7 @@
     -lsurfaceFilmModels \
     -lpyrolysisModels \
     -lregionCoupling \
-    -llagrangianIntermediate \
-    -lODE
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
+    -lODE \
+    -lcompressibleTurbulenceModel \
+    -llagrangian
--- applications/solvers/combustion/coldEngineFoam/coldEngineFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/coldEngineFoam/coldEngineFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -35,6 +35,7 @@
 #include "psiThermo.H"
 #include "turbulenceModel.H"
 #include "OFstream.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 #include "pimpleControl.H"
 
@@ -48,6 +49,7 @@
     #include "createEngineMesh.H"
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
     #include "readEngineTimeControls.H"
     #include "compressibleCourantNo.H"
--- applications/solvers/combustion/coldEngineFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/combustion/coldEngineFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,6 +7,7 @@
     -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
     -I$(LIB_SRC)/thermophysicalModels/reactionThermo/lnInclude \
     -I$(LIB_SRC)/turbulenceModels/compressible/turbulenceModel \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/finiteVolume/lnInclude \
     -I$(LIB_SRC)/sampling/lnInclude \
     -I$(LIB_SRC)/meshTools/lnInclude \
@@ -15,10 +16,11 @@
 EXE_LIBS = \
     -lengine \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
     -lfiniteVolume \
     -lmeshTools \
+    -lradiationModels \
     -lfvOptions
--- applications/solvers/lagrangian/sprayFoam/sprayEngineFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/sprayFoam/sprayEngineFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -33,10 +33,10 @@
     -lmeshTools \
     -lsampling \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -llagrangianSpray \
     -lspecie \
     -lfluidThermophysicalModels \
--- applications/solvers/lagrangian/sprayFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/sprayFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -31,10 +31,10 @@
     -lmeshTools \
     -lsampling \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -llagrangianSpray \
     -lspecie \
     -lfluidThermophysicalModels \
--- applications/solvers/lagrangian/DPMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/DPMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -21,8 +21,9 @@
     -lthermophysicalFunctions \
     -lspecie \
     -lradiationModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleTurbulenceModel \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lincompressibleTransportModels \
     -lregionModels \
     -lsurfaceFilmModels \
--- applications/solvers/lagrangian/reactingParcelFoam/simpleReactingParcelFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/reactingParcelFoam/simpleReactingParcelFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -30,10 +30,10 @@
     -lfiniteVolume \
     -lmeshTools \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lliquidProperties \
--- applications/solvers/lagrangian/reactingParcelFoam/LTSReactingParcelFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/reactingParcelFoam/LTSReactingParcelFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -30,10 +30,10 @@
     -lfiniteVolume \
     -lmeshTools \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lliquidProperties \
--- applications/solvers/lagrangian/reactingParcelFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/reactingParcelFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -30,10 +30,10 @@
     -lfiniteVolume \
     -lmeshTools \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lliquidProperties \
--- applications/solvers/lagrangian/icoUncoupledKinematicParcelFoam/icoUncoupledKinematicParcelDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/icoUncoupledKinematicParcelFoam/icoUncoupledKinematicParcelDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -19,13 +19,14 @@
 
 EXE_LIBS = \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lthermophysicalFunctions \
     -lfluidThermophysicalModels \
     -lspecie \
     -lradiationModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleTurbulenceModel \
+    -lincompressibleRASModels -u compressibleRASModelsLoad \
+    -lincompressibleLESModels -u compressibleLESModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
--- applications/solvers/lagrangian/icoUncoupledKinematicParcelFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/icoUncoupledKinematicParcelFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -15,15 +15,17 @@
 
 EXE_LIBS = \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lthermophysicalFunctions \
     -lfluidThermophysicalModels \
     -lspecie \
     -lradiationModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
     -lregionModels \
-    -lsurfaceFilmModels
+    -lsurfaceFilmModels \
+    -lsampling \
+    -lincompressibleTurbulenceModel
--- applications/solvers/lagrangian/coalChemistryFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/coalChemistryFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -31,10 +31,10 @@
     -lfiniteVolume \
     -lmeshTools \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lcoalCombustion\
     -lspecie \
     -lfluidThermophysicalModels \
--- applications/solvers/lagrangian/uncoupledKinematicParcelFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/uncoupledKinematicParcelFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -13,14 +13,14 @@
 
 EXE_LIBS = \
     -llagrangian \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lthermophysicalFunctions \
     -lfluidThermophysicalModels \
     -lspecie \
     -lradiationModels \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lregionModels \
--- applications/solvers/lagrangian/reactingParcelFilmFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/lagrangian/reactingParcelFilmFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -30,8 +30,8 @@
     -lfvOptions \
     -lsampling \
     -lmeshTools \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lspecie \
     -lfluidThermophysicalModels \
     -lsolidProperties \
@@ -43,6 +43,9 @@
     -lregionModels \
     -lradiationModels \
     -lsurfaceFilmModels \
-    -llagrangianIntermediate \
+    -llagrangianIntermediate -u lagrangianIntermediateLoad \
     -lODE \
-    -lcombustionModels
+    -lcombustionModels \
+    -lsampling \
+    -lcompressibleTurbulenceModel \
+    -llagrangian
--- applications/solvers/heatTransfer/chtMultiRegionFoam/fluid/createFluidFields.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/chtMultiRegionFoam/fluid/createFluidFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -1,3 +1,8 @@
+#ifdef MSWIN
+    // Rename K to k_ to prevent name clashes on Windows with k
+    IOobject::replaceFileName("K", "K_");
+#endif
+
     // Initialise fluid field pointer lists
     PtrList<rhoThermo> thermoFluid(fluidRegions.size());
     PtrList<volScalarField> rhoFluid(fluidRegions.size());
--- applications/solvers/heatTransfer/chtMultiRegionFoam/chtMultiRegionSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/chtMultiRegionFoam/chtMultiRegionSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -22,8 +22,8 @@
     -lsolidThermo \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lradiationModels \
     -lfvOptions \
     -lregionModels \
--- applications/solvers/heatTransfer/chtMultiRegionFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/chtMultiRegionFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -22,8 +22,8 @@
     -lsolidThermo \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lmeshTools \
     -lfiniteVolume \
     -lradiationModels \
--- applications/solvers/heatTransfer/buoyantBoussinesqPimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantBoussinesqPimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -16,6 +16,6 @@
     -lsampling \
     -lmeshTools \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lradiationModels
--- applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/buoyantBoussinesqSimpleFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/buoyantBoussinesqSimpleFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -48,6 +48,7 @@
 #include "fvCFD.H"
 #include "singlePhaseTransportModel.H"
 #include "RASModel.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 #include "simpleControl.H"
 
@@ -60,6 +61,7 @@
     #include "createMesh.H"
     #include "readGravitationalAcceleration.H"
     #include "createFields.H"
+    #include "createIncompressibleRadiationModel.H"
     #include "createFvOptions.H"
     #include "initContinuityErrs.H"
 
--- applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,7 +6,8 @@
     -I$(LIB_SRC)/turbulenceModels \
     -I$(LIB_SRC)/turbulenceModels/incompressible/RAS/lnInclude \
     -I$(LIB_SRC)/transportModels \
-    -I$(LIB_SRC)/transportModels/incompressible/singlePhaseTransportModel
+    -I$(LIB_SRC)/transportModels/incompressible/singlePhaseTransportModel \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude
 
 EXE_LIBS = \
     -lfiniteVolume \
@@ -14,5 +15,6 @@
     -lmeshTools \
     -lfvOptions \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleTransportModels
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleTransportModels \
+    -lradiationModels
--- applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/TEqn.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/TEqn.H	(.../branches/2.2.x-2)	(revision 831)
@@ -9,6 +9,7 @@
         fvm::div(phi, T)
       - fvm::laplacian(alphaEff, T)
      ==
+        radiation->ST(rhoCpRef, T) +
         fvOptions(T)
     );
 
@@ -18,6 +19,8 @@
 
     TEqn.solve();
 
+    radiation->correct();
+
     fvOptions.correct(T);
 
     rhok = 1.0 - beta*(T - TRef);
--- applications/solvers/heatTransfer/buoyantPimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantPimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -16,6 +16,5 @@
     -lradiationModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels
-
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad
--- applications/solvers/heatTransfer/buoyantSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/heatTransfer/buoyantSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -18,5 +18,5 @@
     -lspecie \
     -lradiationModels \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lmeshTools
--- applications/solvers/compressible/rhoPimpleFoam/rhoPimpleFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoPimpleFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -38,6 +38,7 @@
 #include "turbulenceModel.H"
 #include "bound.H"
 #include "pimpleControl.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
@@ -52,6 +53,7 @@
 
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
 
     // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/solvers/compressible/rhoPimpleFoam/rhoLTSPimpleFoam/rhoLTSPimpleFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoLTSPimpleFoam/rhoLTSPimpleFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -40,6 +40,7 @@
 #include "turbulenceModel.H"
 #include "fvIOoptionList.H"
 #include "fvcSmooth.H"
+#include "radiationModel.H"
 #include "pimpleControl.H"
 #include "bound.H"
 
@@ -56,6 +57,7 @@
     #include "setInitialrDeltaT.H"
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
 
     // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/solvers/compressible/rhoPimpleFoam/rhoLTSPimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoLTSPimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,15 +6,17 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude \
     -I$(LIB_SRC)/meshTools/lnInclude \
     -I$(LIB_SRC)/sampling/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/fvOptions/lnInclude
 
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lsampling \
+    -lradiationModels \
     -lfvOptions
--- applications/solvers/compressible/rhoPimpleFoam/rhoPimplecFoam/rhoPimplecFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoPimplecFoam/rhoPimplecFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -38,6 +38,7 @@
 #include "turbulenceModel.H"
 #include "bound.H"
 #include "pimpleControl.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
@@ -52,6 +53,7 @@
 
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
 
     // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/solvers/compressible/rhoPimpleFoam/rhoPimplecFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoPimplecFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,15 +6,17 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude \
     -I$(LIB_SRC)/meshTools/lnInclude \
     -I$(LIB_SRC)/sampling/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/fvOptions/lnInclude
 
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lsampling \
+    -lradiationModels \
     -lfvOptions
--- applications/solvers/compressible/rhoPimpleFoam/rhoPimpleDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoPimpleDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,14 +9,15 @@
     -I$(LIB_SRC)/fvOptions/lnInclude \
     -I$(LIB_SRC)/dynamicFvMesh/lnInclude \
     -I$(LIB_SRC)/dynamicMesh/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/meshTools/lnInclude \
 
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lsampling \
@@ -24,4 +25,5 @@
     -ldynamicFvMesh \
     -ltopoChangerFvMesh \
     -ldynamicMesh \
+    -lradiationModels \
     -lmeshTools
--- applications/solvers/compressible/rhoPimpleFoam/rhoPimpleDyMFoam/rhoPimpleDyMFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/rhoPimpleDyMFoam/rhoPimpleDyMFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -39,6 +39,7 @@
 #include "turbulenceModel.H"
 #include "bound.H"
 #include "pimpleControl.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
@@ -55,6 +56,7 @@
     #include "readControls.H"
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "createPcorrTypes.H"
     #include "CourantNo.H"
     #include "setInitialDeltaT.H"
--- applications/solvers/compressible/rhoPimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,15 +5,17 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude \
     -I$(LIB_SRC)/meshTools/lnInclude \
     -I$(LIB_SRC)/sampling/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/fvOptions/lnInclude
 
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
-    -lsampling \
+    -lsampling  \
+    -lradiationModels \
     -lfvOptions
--- applications/solvers/compressible/rhoPimpleFoam/EEqn.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoPimpleFoam/EEqn.H	(.../branches/2.2.x-2)	(revision 831)
@@ -17,6 +17,7 @@
         )
       - fvm::laplacian(turbulence->alphaEff(), he)
      ==
+        radiation->Sh(thermo) +
         fvOptions(rho, he)
     );
 
@@ -29,4 +30,5 @@
     fvOptions.correct(he);
 
     thermo.correct();
+    radiation->correct();
 }
--- applications/solvers/compressible/rhoCentralFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoCentralFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -13,6 +13,6 @@
     -lspecie \
     -lrhoCentralFoam \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lmeshTools
--- applications/solvers/compressible/rhoCentralFoam/rhoCentralDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoCentralFoam/rhoCentralDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -14,7 +14,7 @@
     -lspecie \
     -lrhoCentralFoam \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -ldynamicMesh \
     -lmeshTools
--- applications/solvers/compressible/rhoSimpleFoam/rhoSimpleFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/rhoSimpleFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -33,6 +33,7 @@
 #include "fvCFD.H"
 #include "psiThermo.H"
 #include "RASModel.H"
+#include "radiationModel.H"
 #include "simpleControl.H"
 #include "fvIOoptionList.H"
 
@@ -48,6 +49,7 @@
 
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
 
     // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/solvers/compressible/rhoSimpleFoam/rhoSimplecFoam/rhoSimplecFoam.C	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/rhoSimplecFoam/rhoSimplecFoam.C	(.../branches/2.2.x-2)	(revision 831)
@@ -36,6 +36,7 @@
 #include "mixedFvPatchFields.H"
 #include "bound.H"
 #include "simpleControl.H"
+#include "radiationModel.H"
 #include "fvIOoptionList.H"
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
@@ -50,6 +51,7 @@
 
     #include "createFields.H"
     #include "createFvOptions.H"
+    #include "createRadiationModel.H"
     #include "initContinuityErrs.H"
 
     // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
--- applications/solvers/compressible/rhoSimpleFoam/rhoSimplecFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/rhoSimplecFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,7 @@
 EXE_INC = \
     -I.. \
     -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/turbulenceModels \
     -I$(LIB_SRC)/turbulenceModels/compressible/RAS/RASModel \
     -I$(LIB_SRC)/finiteVolume/cfdTools \
@@ -12,8 +13,10 @@
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
+    -lcompressibleTurbulenceModel \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
     -lsampling \
     -lmeshTools \
+    -lradiationModels \
     -lfvOptions
--- applications/solvers/compressible/rhoSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -1,5 +1,6 @@
 EXE_INC = \
     -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/radiationModels/lnInclude \
     -I$(LIB_SRC)/turbulenceModels \
     -I$(LIB_SRC)/turbulenceModels/compressible/RAS/RASModel \
     -I$(LIB_SRC)/finiteVolume/cfdTools \
@@ -11,8 +12,9 @@
 EXE_LIBS = \
     -lfluidThermophysicalModels \
     -lspecie \
+    -lradiationModels \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
     -lsampling \
     -lmeshTools \
--- applications/solvers/compressible/rhoSimpleFoam/rhoPorousSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/rhoPorousSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -13,7 +13,7 @@
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lfiniteVolume \
     -lsampling \
     -lmeshTools \
--- applications/solvers/compressible/rhoSimpleFoam/EEqn.H	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/rhoSimpleFoam/EEqn.H	(.../branches/2.2.x-2)	(revision 831)
@@ -11,6 +11,7 @@
         )
       - fvm::laplacian(turbulence->alphaEff(), he)
      ==
+        radiation->Sh(thermo) +
         fvOptions(rho, he)
     );
 
@@ -23,4 +24,5 @@
     fvOptions.correct(he);
 
     thermo.correct();
+    radiation->correct();
 }
--- applications/solvers/compressible/sonicFoam/sonicDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/sonicFoam/sonicDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -10,8 +10,8 @@
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -ldynamicMesh \
     -lmeshTools
--- applications/solvers/compressible/sonicFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/compressible/sonicFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,7 +7,7 @@
     -lfluidThermophysicalModels \
     -lspecie \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools
--- applications/solvers/multiphase/multiphaseInterFoam/MRFMultiphaseInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseInterFoam/MRFMultiphaseInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,9 +11,9 @@
 
 EXE_LIBS = \
     -lmultiphaseInterFoam \
-    -linterfaceProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume
--- applications/solvers/multiphase/multiphaseInterFoam/multiphaseMixture/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseInterFoam/multiphaseMixture/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,6 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 LIB_LIBS = \
-    -linterfaceProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume
--- applications/solvers/multiphase/multiphaseInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,9 +9,9 @@
 
 EXE_LIBS = \
     -lmultiphaseInterFoam \
-    -linterfaceProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume
--- applications/solvers/multiphase/twoLiquidMixingFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/twoLiquidMixingFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,6 +11,6 @@
     -ltwoPhaseMixture \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume
--- applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/phaseModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/phaseModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,4 +6,5 @@
 LIB_LIBS = \
     -lincompressibleTransportModels \
     -lfluidThermophysicalModels \
-    -lspecie
+    -lspecie \
+    -lfiniteVolume
--- applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/kineticTheoryModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/kineticTheoryModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,3 +4,8 @@
     -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
     -I../phaseModel/lnInclude \
     -I../interfacialModels/lnInclude
+
+LIB_LIBS = \
+    -lcompressiblePhaseModel \
+    -lcompressibleEulerianInterfacialModels \
+    -lfiniteVolume
--- applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/interfacialModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/compressibleTwoPhaseEulerFoam/interfacialModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,4 +6,6 @@
 LIB_LIBS = \
     -lcompressiblePhaseModel \
     -lfluidThermophysicalModels \
-    -lspecie
+    -lspecie \
+    -lfiniteVolume
+
--- applications/solvers/multiphase/interFoam/MRFInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/MRFInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,12 +12,12 @@
 
 EXE_LIBS = \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/interFoam/porousInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/porousInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,12 +12,12 @@
 
 EXE_LIBS = \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/interFoam/interDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/interDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -14,12 +14,12 @@
 
 EXE_LIBS = \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -ldynamicMesh \
     -ldynamicFvMesh \
--- applications/solvers/multiphase/interFoam/interMixingFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/interMixingFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -14,11 +14,11 @@
 
 EXE_LIBS = \
     -ltwoPhaseMixture \
-    -ltwoPhaseProperties \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/interFoam/LTSInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/LTSInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,13 +11,13 @@
     -I$(LIB_SRC)/sampling/lnInclude
 
 EXE_LIBS = \
-    -linterfaceProperties \
     -ltwoPhaseMixture \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/interFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,12 +11,12 @@
 
 EXE_LIBS = \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/twoPhaseEulerFoam/phaseModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/twoPhaseEulerFoam/phaseModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,5 @@
     -I$(LIB_SRC)/transportModels/incompressible/lnInclude
 
 LIB_LIBS = \
+    -lfiniteVolume \
     -lincompressibleTransportModels
--- applications/solvers/multiphase/twoPhaseEulerFoam/kineticTheoryModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/twoPhaseEulerFoam/kineticTheoryModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,3 +3,8 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude \
     -I../phaseModel/lnInclude \
     -I../interfacialModels/lnInclude
+
+LIB_LIBS = \
+    -lfiniteVolume \
+    -lphaseModel \
+    -lEulerianInterfacialModels
--- applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,5 @@
     -I../phaseModel/lnInclude
 
 LIB_LIBS = \
+    -lfiniteVolume \
     -lphaseModel
--- applications/solvers/multiphase/interPhaseChangeFoam/phaseChangeTwoPhaseMixtures/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interPhaseChangeFoam/phaseChangeTwoPhaseMixtures/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,6 @@
 
 LIB_LIBS = \
     -ltwoPhaseMixture \
-    -ltwoPhaseProperties \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume
--- applications/solvers/multiphase/interPhaseChangeFoam/interPhaseChangeDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interPhaseChangeFoam/interPhaseChangeDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -16,12 +16,12 @@
 EXE_LIBS = \
     -lphaseChangeTwoPhaseMixtures \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -ldynamicMesh \
     -ldynamicFvMesh \
--- applications/solvers/multiphase/interPhaseChangeFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/interPhaseChangeFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -13,12 +13,12 @@
 EXE_LIBS = \
     -lphaseChangeTwoPhaseMixtures \
     -ltwoPhaseMixture \
-    -linterfaceProperties \
-    -ltwoPhaseProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/multiphase/multiphaseEulerFoam/phaseModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseEulerFoam/phaseModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,6 @@
     -I$(LIB_SRC)/transportModels/incompressible/lnInclude
 
 LIB_LIBS = \
-    -lincompressibleTransportModels
+    -lincompressibleTransportModels \
+    -lfiniteVolume
+
--- applications/solvers/multiphase/multiphaseEulerFoam/interfacialModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseEulerFoam/interfacialModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,5 @@
     -I../phaseModel/lnInclude
 
 LIB_LIBS = \
-    -lcompressibleMultiPhaseModel
+    -lcompressibleMultiPhaseModel \
+    -lfiniteVolume
--- applications/solvers/multiphase/multiphaseEulerFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/multiphaseEulerFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -16,9 +16,11 @@
 EXE_LIBS = \
     -lmultiphaseSystem \
     -lcompressibleMultiPhaseModel \
-    -linterfaceProperties \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lincompressibleTransportModels \
     -lcompressibleMultiphaseEulerianInterfacialModels \
-    -lincompressibleLESModels \
-    -lincompressibleRASModels \
-    -lfiniteVolume
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lfiniteVolume \
+    -lincompressibleTurbulenceModel
+
--- applications/solvers/multiphase/cavitatingFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/cavitatingFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -10,7 +10,7 @@
 EXE_LIBS = \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lbarotropicCompressibilityModel
--- applications/solvers/multiphase/compressibleInterFoam/compressibleInterDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/compressibleInterFoam/compressibleInterDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -16,11 +16,12 @@
     -lfluidThermophysicalModels \
     -lspecie \
     -ltwoPhaseMixture \
-    -ltwoPhaseProperties \
-    -linterfaceProperties \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
+    -linterfaceProperties -u interfacePropertiesLoad \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -lfiniteVolume \
     -ldynamicMesh \
     -lmeshTools \
     -ldynamicFvMesh \
--- applications/solvers/multiphase/compressibleInterFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/multiphase/compressibleInterFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,9 +12,10 @@
     -lfluidThermophysicalModels \
     -lspecie \
     -ltwoPhaseMixture \
-    -ltwoPhaseProperties \
-    -linterfaceProperties \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -ltwoPhaseProperties -u twoPhasePropertiesLoad \
+    -linterfaceProperties -u interfacePropertiesLoad \
+    -lincompressibleTransportModels \
     -lfiniteVolume
--- applications/solvers/incompressible/adjointShapeOptimizationFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/adjointShapeOptimizationFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,7 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 EXE_LIBS = \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
-    -lfiniteVolume
+    -lfiniteVolume \
+    -lincompressibleTurbulenceModel
--- applications/solvers/incompressible/boundaryFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/boundaryFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -8,7 +8,7 @@
 
 EXE_LIBS = \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
--- applications/solvers/incompressible/pimpleFoam/pimpleDyMFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/pimpleFoam/pimpleDyMFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -18,8 +18,9 @@
     -lmeshTools \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
     -lfiniteVolume \
     -lfvOptions \
-    -lsampling
+    -lsampling \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
+    -lfiniteVolume
--- applications/solvers/incompressible/pimpleFoam/SRFPimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/pimpleFoam/SRFPimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -10,8 +10,8 @@
 EXE_LIBS = \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/incompressible/pimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/pimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,8 +11,8 @@
 EXE_LIBS = \
     -lincompressibleTransportModels \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
--- applications/solvers/incompressible/simpleFoam/porousSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/simpleFoam/porousSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,7 +12,7 @@
 
 EXE_LIBS = \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
--- applications/solvers/incompressible/simpleFoam/SRFSimpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/simpleFoam/SRFSimpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,9 +11,10 @@
 
 
 EXE_LIBS = \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
     -lfvOptions \
-    -lsampling
+    -lsampling \
+    -lincompressibleTurbulenceModel
--- applications/solvers/incompressible/simpleFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/simpleFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,7 +11,7 @@
 
 EXE_LIBS = \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools \
--- applications/solvers/incompressible/pisoFoam/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ applications/solvers/incompressible/pisoFoam/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,8 +6,8 @@
 
 EXE_LIBS = \
     -lincompressibleTurbulenceModel \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lincompressibleTransportModels \
     -lfiniteVolume \
     -lmeshTools
--- src/genericPatchFields/genericFvPatchField/genericFvPatchFields.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/genericPatchFields/genericFvPatchField/genericFvPatchFields.C	(.../branches/2.2.x-2)	(revision 831)
@@ -29,6 +29,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void genericPatchFieldsLoad()
+{}
+
+
 namespace Foam
 {
 
--- src/conversion/meshReader/createPolyBoundary.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/conversion/meshReader/createPolyBoundary.C	(.../branches/2.2.x-2)	(revision 831)
@@ -376,8 +376,9 @@
     label nPatches = patchStarts_.size();
 
     // avoid empty patches - move to the end of the lists and truncate
+    // Size loop according to patchStarts_ can be smaller than patchSizes_
     labelList oldToNew = identity(nPatches);
-    forAll(patchSizes_, patchI)
+    forAll(patchStarts_, patchI)
     {
         if (patchSizes_[patchI] > 0)
         {
--- src/conversion/ensight/part/ensightPartIO.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/conversion/ensight/part/ensightPartIO.C	(.../branches/2.2.x-2)	(revision 831)
@@ -63,7 +63,7 @@
     {
         forAll(idList, i)
         {
-            if (idList[i] >= field.size() || isnan(field[idList[i]]))
+	    if (idList[i] >= field.size() || std::isnan(field[idList[i]]))
             {
                 os.writeUndef();
             }
@@ -80,7 +80,7 @@
         // no idList => perNode
         forAll(field, i)
         {
-            if (isnan(field[i]))
+	    if (std::isnan(field[i]))
             {
                 os.writeUndef();
             }
--- src/conversion/ensight/part/ensightPart.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/conversion/ensight/part/ensightPart.C	(.../branches/2.2.x-2)	(revision 831)
@@ -51,7 +51,7 @@
         {
             const label id = idList[i];
 
-            if (id >= field.size() || isnan(field[id]))
+            if (id >= field.size() || std::isnan(field[id]))
             {
                 return false;
             }
--- src/combustionModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/combustionModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -12,5 +12,10 @@
 
 LIB_LIBS = \
     -lfiniteVolume \
-    -lcompressibleLESModels \
-    -lchemistryModel
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -lchemistryModel \
+    -lcompressibleTurbulenceModel \
+    -lLESdeltas \
+    -lspecie \
+    -lfluidThermophysicalModels \
+    -lreactionThermophysicalModels
--- src/regionModels/thermalBaffleModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/regionModels/thermalBaffleModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -20,4 +20,6 @@
     -lmeshTools \
     -lOpenFOAM \
     -lradiationModels \
+    -lspecie \
+    -lfluidThermophysicalModels \
     -ldynamicMesh
--- src/regionModels/pyrolysisModels/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/regionModels/pyrolysisModels/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -24,9 +24,9 @@
     -lsolidChemistryModel \
     -lsolidThermo \
     -lcompressibleTurbulenceModel \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lLESdeltas \
-    -lregionModels \
     -lradiationModels \
-    -lreactionThermophysicalModels
+    -lreactionThermophysicalModels \
+    -lregionModels
--- src/regionModels/regionCoupling/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/regionModels/regionCoupling/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -34,5 +34,7 @@
     -lSLGThermo \
     -lfiniteVolume \
     -lmeshTools \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels
+    -lspecie \
+    -lcompressibleTurbulenceModel \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad
--- src/OSspecific/POSIX/POSIX.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OSspecific/POSIX/POSIX.C	(.../branches/2.2.x-2)	(revision 831)
@@ -53,7 +53,6 @@
 #include <sys/socket.h>
 #include <netdb.h>
 #include <dlfcn.h>
-#include <link.h>
 
 #include <netinet/in.h>
 
@@ -75,19 +74,19 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
-pid_t Foam::pid()
+Foam::PID_T Foam::pid()
 {
     return ::getpid();
 }
 
 
-pid_t Foam::ppid()
+Foam::PID_T Foam::ppid()
 {
     return ::getppid();
 }
 
 
-pid_t Foam::pgid()
+Foam::PID_T Foam::pgid()
 {
     return ::getpgrp();
 }
@@ -1165,15 +1164,38 @@
 }
 
 
-void* Foam::dlOpen(const fileName& lib, const bool check)
+void* Foam::dlOpen(const fileName& libName, const bool check)
 {
     if (POSIX::debug)
     {
         std::cout<< "dlOpen(const fileName&)"
-            << " : dlopen of " << lib << std::endl;
+            << " : dlopen of " << libName << std::endl;
     }
-    void* handle = ::dlopen(lib.c_str(), RTLD_LAZY|RTLD_GLOBAL);
 
+    Foam::string unixLibName(libName);
+    char const * const soExt = ".so";
+  
+#ifdef DARWIN
+    char const * const unixExt = ".dylib";
+    unixLibName.replace(soExt, unixExt);
+#else
+    char const * const unixExt = soExt;
+#endif
+  
+    // Assume libName is of the form, lib<name>.so
+    void* handle = ::dlopen(unixLibName.c_str(), RTLD_LAZY|RTLD_GLOBAL);
+
+    if (NULL == handle)
+    {
+        // Try assuming libName = name
+        unixLibName = "lib";
+        unixLibName += libName;
+        unixLibName += unixExt;
+      
+        handle = 
+          ::dlopen(unixLibName.c_str(), RTLD_LAZY|RTLD_GLOBAL);
+    }
+
     if (!handle && check)
     {
         WarningIn("dlOpen(const fileName&, const bool)")
@@ -1185,7 +1207,7 @@
     {
         std::cout
             << "dlOpen(const fileName&)"
-            << " : dlopen of " << lib
+            << " : dlopen of " << libName
             << " handle " << handle << std::endl;
     }
 
@@ -1260,6 +1282,18 @@
 }
 
 
+#ifdef DARWIN
+
+Foam::fileNameList Foam::dlLoaded()
+{
+  DynamicList<fileName> libs;
+  return libs;
+}
+
+#else
+
+#include <link.h>
+
 static int collectLibsCallback
 (
     struct dl_phdr_info *info,
@@ -1287,7 +1321,9 @@
     return libs;
 }
 
+#endif // not DARWIN
 
+
 void Foam::osRandomSeed(const label seed)
 {
 #ifdef USE_RANDOM
@@ -1318,4 +1354,10 @@
 }
 
 
+std::string Foam::toUnixPath(const std::string & path)
+{
+  return path;
+}
+
+
 // ************************************************************************* //
--- src/OSspecific/POSIX/fileStat.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OSspecific/POSIX/fileStat.C	(.../branches/2.2.x-2)	(revision 831)
@@ -29,7 +29,10 @@
 
 #include <signal.h>
 #include <unistd.h>
+
+#ifndef DARWIN
 #include <sys/sysmacros.h>
+#endif
 
 // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
 
--- src/OSspecific/POSIX/clockTime/clockTime.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OSspecific/POSIX/clockTime/clockTime.H	(.../branches/2.2.x-2)	(revision 831)
@@ -38,6 +38,10 @@
 
 #include <sys/types.h>
 
+#ifdef DARWIN
+#include <sys/time.h>
+#endif
+
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
 namespace Foam
--- src/OSspecific/POSIX/Make/files	(.../tags/2.2.x-2)	(revision 831)
+++ src/OSspecific/POSIX/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -18,10 +18,10 @@
  */
 fileMonitor.C
 
-#ifdef SunOS64
+#ifdef linux
+printStack.C
+#else
 dummyPrintStack.C
-#else
-printStack.C
 #endif
 
 LIB = $(FOAM_LIBBIN)/libOSspecific
--- src/OSspecific/MSwindows/regExp.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/regExp.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,174 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::regExp
+
+SourceFiles
+    regExp.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef regExp_H
+#define regExp_H
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#include <string>
+
+template <class T> class CRegexpT;
+
+namespace Foam
+{
+
+// Forward declaration of classes
+class string;
+template<class T> class List;
+
+/*---------------------------------------------------------------------------*\
+                           Class regExp Declaration
+\*---------------------------------------------------------------------------*/
+
+class regExp
+{
+    // Private data
+
+        //- Precompiled regular expression
+        mutable CRegexpT<char>* preg_;
+
+    // Private member functions
+
+        //- Disallow default bitwise copy construct
+        regExp(const regExp&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const regExp&);
+
+public:
+
+        //- Is character a regular expression meta-character?
+        //  any character: '.' \n
+        //  quantifiers: '*', '+', '?' \n
+        //  grouping: '(', '|', ')' \n
+        //  range: '[', ']' \n
+        //
+        //  Don't bother checking for '{digit}' bounds
+        inline static bool meta(char c)
+        {
+            return
+            (
+                (c == '.')                           // any character
+             || (c == '*' || c == '+' || c == '?')   // quantifiers
+             || (c == '(' || c == ')' || c == '|')   // grouping/branching
+             || (c == '[' || c == ']')               // range
+            );
+        }
+
+
+    // Constructors
+
+        //- Construct null
+        regExp();
+
+        //- Construct from character array, optionally ignoring case
+        regExp(const char*, const bool ignoreCase=false);
+
+        //- Construct from std::string (or string), optionally ignoring case
+        regExp(const std::string&, const bool ignoreCase=false);
+
+    // Destructor
+
+        ~regExp();
+
+
+    // Member functions
+
+    //- Access
+
+        //- Return true if a precompiled expression does not exist
+        inline bool empty() const
+        {
+            return !preg_;
+        }
+
+        //- Does a precompiled expression exist?
+        inline bool exists() const
+        {
+            return preg_ ? true : false;
+        }
+
+
+    //- Editing
+
+        //- Compile pattern into a regular expression, optionally ignoring case
+        void set(const char*, const bool ignoreCase=false) const;
+
+        //- Compile pattern into a regular expression, optionally ignoring case
+        void set(const std::string&, const bool ignoreCase=false) const;
+
+
+        //- Release precompiled expression.
+        //  Returns true if precompiled expression existed before clear
+        bool clear() const;
+
+
+    //- Searching
+
+        //- Find position within string.
+        //  Returns the index where it begins or string::npos if not found
+        std::string::size_type find(const std::string& str) const;
+
+        //- Return true if it matches the entire string
+        //  The begin-of-line (^) and end-of-line ($) anchors are implicit
+        bool match(const std::string&) const;
+
+        //- Return true if it matches and sets the sub-groups matched
+        //  The begin-of-line (^) and end-of-line ($) anchors are implicit
+        bool match(const string&, List<string>& groups) const;
+
+        //- Return true if the regex was found in within string
+        bool search(const std::string& str) const
+        {
+            return std::string::npos != find(str);
+        }
+
+    // Member Operators
+
+        //- Assign and compile pattern from a character array
+        //  Always case sensitive
+        void operator=(const char*);
+
+        //- Assign and compile pattern from string
+        //  Always case sensitive
+        void operator=(const std::string&);
+
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/MSwindows.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/MSwindows.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,63 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    MSwindows
+
+Description
+
+SourceFiles
+    MSwindows.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef MSwindows_H
+#define MSwindows_H
+
+#include <string>
+
+#include "className.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace MSwindows
+{
+    //- Declare name of the class and it's debug switch
+    NamespaceName("MSwindows");
+
+    //- Get last windows api error from GetLastError
+    std::string getLastError();
+}
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/deelx.h	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/deelx.h	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,4342 @@
+// deelx.h
+//
+// DEELX Regular Expression Engine (v1.2)
+//
+// Copyright 2006 (c) RegExLab.com
+// All Rights Reserved.
+//
+// http://www.regexlab.com/deelx/
+//
+// Author:  (sswater shi)
+// sswater@gmail.com
+//
+// $Revision: 1.1.2.39 $
+//
+
+#ifndef __DEELX_REGEXP__H__
+#define __DEELX_REGEXP__H__
+
+#include <memory.h>
+#include <ctype.h>
+#include <limits.h>
+#include <string.h>
+#include <stdlib.h>
+
+//
+// Data Reference
+//
+template <class ELT> class CBufferRefT
+{
+public:
+	CBufferRefT(const ELT * pcsz, int length);
+	CBufferRefT(const ELT * pcsz);
+
+public:
+	int nCompare      (const ELT * pcsz) const;
+	int nCompareNoCase(const ELT * pcsz) const;
+	int  Compare      (const ELT * pcsz) const;
+	int  CompareNoCase(const ELT * pcsz) const;
+	int  Compare      (const CBufferRefT <ELT> &) const;
+	int  CompareNoCase(const CBufferRefT <ELT> &) const;
+
+	ELT At          (int nIndex, ELT def = 0) const;
+	ELT operator [] (int nIndex) const;
+
+	const ELT * GetBuffer() const;
+	int GetSize() const;
+
+public:
+	virtual ~CBufferRefT();
+
+// Content
+protected:
+	const ELT * m_pRef;
+	int         m_nSize;
+};
+
+//
+// Implemenation
+//
+template <class ELT> CBufferRefT <ELT> :: CBufferRefT(const ELT * pcsz, int length)
+{
+	m_pRef  = pcsz;
+	m_nSize = length;
+}
+
+template <class ELT> CBufferRefT <ELT> :: CBufferRefT(const ELT * pcsz)
+{
+	m_pRef  = pcsz;
+	m_nSize = 0;
+
+	if(pcsz != 0) while(m_pRef[m_nSize] != 0) m_nSize ++;
+}
+
+template <class ELT> int CBufferRefT <ELT> :: nCompare(const ELT * pcsz) const
+{
+	for(int i=0; i<m_nSize; i++)
+	{
+		if(m_pRef[i] != pcsz[i])
+			return m_pRef[i] - pcsz[i];
+	}
+
+	return 0;
+}
+
+template <class ELT> int CBufferRefT <ELT> :: nCompareNoCase(const ELT * pcsz) const
+{
+	for(int i=0; i<m_nSize; i++)
+	{
+		if(m_pRef[i] != pcsz[i])
+		{
+			if(toupper((int)m_pRef[i]) != toupper((int)pcsz[i]))
+				return m_pRef[i] - pcsz[i];
+		}
+	}
+
+	return 0;
+}
+
+template <class ELT> inline int CBufferRefT <ELT> :: Compare(const ELT * pcsz) const
+{
+	return nCompare(pcsz) ? 1 : (int)pcsz[m_nSize];
+}
+
+template <class ELT> inline int CBufferRefT <ELT> :: CompareNoCase(const ELT * pcsz) const
+{
+	return nCompareNoCase(pcsz) ? 1 : (int)pcsz[m_nSize];
+}
+
+template <class ELT> inline int CBufferRefT <ELT> :: Compare(const CBufferRefT <ELT> & cref) const
+{
+	return m_nSize == cref.m_nSize ? nCompare(cref.GetBuffer()) : 1;
+}
+
+template <class ELT> inline int CBufferRefT <ELT> :: CompareNoCase(const CBufferRefT <ELT> & cref) const
+{
+	return m_nSize == cref.m_nSize ? nCompareNoCase(cref.GetBuffer()) : 1;
+}
+
+template <class ELT> inline ELT CBufferRefT <ELT> :: At(int nIndex, ELT def) const
+{
+	return nIndex >= m_nSize ? def : m_pRef[nIndex];
+}
+
+template <class ELT> inline ELT CBufferRefT <ELT> :: operator [] (int nIndex) const
+{
+	return nIndex >= m_nSize ? 0 : m_pRef[nIndex];
+}
+
+template <class ELT> const ELT * CBufferRefT <ELT> :: GetBuffer() const
+{
+	static const ELT _def[] = {0}; return m_pRef ? m_pRef : _def;
+}
+
+template <class ELT> inline int CBufferRefT <ELT> :: GetSize() const
+{
+	return m_nSize;
+}
+
+template <class ELT> CBufferRefT <ELT> :: ~CBufferRefT()
+{
+}
+
+//
+// Data Buffer
+//
+template <class ELT> class CBufferT : public CBufferRefT <ELT>
+{
+public:
+	CBufferT(const ELT * pcsz, int length);
+	CBufferT(const ELT * pcsz);
+	CBufferT();
+
+public:
+	ELT & operator [] (int nIndex);
+	const ELT & operator [] (int nIndex) const;
+	void  Append(const ELT * pcsz, int length, int eol = 0);
+	void  Append(ELT el, int eol = 0);
+
+public:
+	void  Push(ELT   el);
+	int   Pop (ELT & el);
+	int   Peek(ELT & el) const;
+
+public:
+	const ELT * GetBuffer() const;
+	ELT * GetBuffer();
+	ELT * Detach();
+	void  Release();
+	void  Prepare(int index, int fill = 0);
+	void  Restore(int size);
+
+public:
+	virtual ~CBufferT();
+
+// Content
+protected:
+	ELT * m_pBuffer;
+	int   m_nMaxLength;
+};
+
+//
+// Implemenation
+//
+template <class ELT> CBufferT <ELT> :: CBufferT(const ELT * pcsz, int length) : CBufferRefT <ELT> (0, length)
+{
+	m_nMaxLength = CBufferRefT <ELT> :: m_nSize + 1;
+
+	CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) malloc(sizeof(ELT) * m_nMaxLength);
+	memcpy(m_pBuffer, pcsz, sizeof(ELT) * CBufferRefT <ELT> :: m_nSize);
+	m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
+}
+
+template <class ELT> CBufferT <ELT> :: CBufferT(const ELT * pcsz) : CBufferRefT <ELT> (pcsz)
+{
+	m_nMaxLength = CBufferRefT <ELT> :: m_nSize + 1;
+
+	CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) malloc(sizeof(ELT) * m_nMaxLength);
+	memcpy(m_pBuffer, pcsz, sizeof(ELT) * CBufferRefT <ELT> :: m_nSize);
+	m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
+}
+
+template <class ELT> CBufferT <ELT> :: CBufferT() : CBufferRefT <ELT> (0, 0)
+{
+	m_nMaxLength = 0;
+	m_pBuffer    = 0;
+}
+
+template <class ELT> inline ELT & CBufferT <ELT> :: operator [] (int nIndex)
+{
+	return m_pBuffer[nIndex];
+}
+
+template <class ELT> inline const ELT & CBufferT <ELT> :: operator [] (int nIndex) const
+{
+	return m_pBuffer[nIndex];
+}
+
+template <class ELT> void CBufferT <ELT> :: Append(const ELT * pcsz, int length, int eol)
+{
+	int nNewLength = m_nMaxLength;
+
+	// Check length
+	if(nNewLength < 8)
+		nNewLength = 8;
+
+	if(CBufferRefT <ELT> :: m_nSize + length + eol > nNewLength)
+		nNewLength *= 2;
+
+	if(CBufferRefT <ELT> :: m_nSize + length + eol > nNewLength)
+	{
+		nNewLength  = CBufferRefT <ELT> :: m_nSize + length + eol + 11;
+		nNewLength -= nNewLength % 8;
+	}
+
+	// Realloc
+	if(nNewLength > m_nMaxLength)
+	{
+		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
+		m_nMaxLength = nNewLength;
+	}
+
+	// Append
+	memcpy(m_pBuffer + CBufferRefT <ELT> :: m_nSize, pcsz, sizeof(ELT) * length);
+	CBufferRefT <ELT> :: m_nSize += length;
+
+	if(eol > 0) m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
+}
+
+template <class ELT> inline void CBufferT <ELT> :: Append(ELT el, int eol)
+{
+	Append(&el, 1, eol);
+}
+
+template <class ELT> void CBufferT <ELT> :: Push(ELT el)
+{
+	// Realloc
+	if(CBufferRefT <ELT> :: m_nSize >= m_nMaxLength)
+	{
+		int nNewLength = m_nMaxLength * 2;
+		if( nNewLength < 8 ) nNewLength = 8;
+
+		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
+		m_nMaxLength = nNewLength;
+	}
+
+	// Append
+	m_pBuffer[CBufferRefT <ELT> :: m_nSize++] = el;
+}
+
+template <class ELT> inline int CBufferT <ELT> :: Pop(ELT & el)
+{
+	if(CBufferRefT <ELT> :: m_nSize > 0)
+	{
+		el = m_pBuffer[--CBufferRefT <ELT> :: m_nSize];
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+template <class ELT> inline int CBufferT <ELT> :: Peek(ELT & el) const
+{
+	if(CBufferRefT <ELT> :: m_nSize > 0)
+	{
+		el = m_pBuffer[CBufferRefT <ELT> :: m_nSize - 1];
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+template <class ELT> const ELT * CBufferT <ELT> :: GetBuffer() const
+{
+	static const ELT _def[] = {0}; return m_pBuffer ? m_pBuffer : _def;
+}
+
+template <class ELT> ELT * CBufferT <ELT> :: GetBuffer()
+{
+	static const ELT _def[] = {0}; return m_pBuffer ? m_pBuffer : (ELT *)_def;
+}
+
+template <class ELT> ELT * CBufferT <ELT> :: Detach()
+{
+	ELT * pBuffer = m_pBuffer;
+
+	CBufferRefT <ELT> :: m_pRef  = m_pBuffer    = 0;
+	CBufferRefT <ELT> :: m_nSize = m_nMaxLength = 0;
+
+	return pBuffer;
+}
+
+template <class ELT> void CBufferT <ELT> :: Release()
+{
+	ELT * pBuffer = Detach();
+
+	if(pBuffer != 0) free(pBuffer);
+}
+
+template <class ELT> void CBufferT <ELT> :: Prepare(int index, int fill)
+{
+	int nNewSize = index + 1;
+
+	// Realloc
+	if(nNewSize > m_nMaxLength)
+	{
+		int nNewLength = m_nMaxLength;
+
+		if( nNewLength < 8 )
+			nNewLength = 8;
+
+		if( nNewSize > nNewLength )
+			nNewLength *= 2;
+
+		if( nNewSize > nNewLength )
+		{
+			nNewLength  = nNewSize + 11;
+			nNewLength -= nNewLength % 8;
+		}
+
+		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
+		m_nMaxLength = nNewLength;
+	}
+
+	// size
+	if( CBufferRefT <ELT> :: m_nSize < nNewSize )
+	{
+		memset(m_pBuffer + CBufferRefT <ELT> :: m_nSize, fill, sizeof(ELT) * (nNewSize - CBufferRefT <ELT> :: m_nSize));
+		CBufferRefT <ELT> :: m_nSize = nNewSize;
+	}
+}
+
+template <class ELT> inline void CBufferT <ELT> :: Restore(int size)
+{
+	CBufferRefT <ELT> :: m_nSize = size;
+}
+
+template <class ELT> CBufferT <ELT> :: ~CBufferT()
+{
+	if(m_pBuffer != 0) free(m_pBuffer);
+}
+
+//
+// Context
+//
+class CContext
+{
+public:
+	CBufferT <int> m_stack;
+	CBufferT <int> m_capturestack, m_captureindex;
+
+public:
+	int    m_nCurrentPos;
+	int    m_nBeginPos;
+	int    m_nLastBeginPos;
+	int    m_nParenZindex;
+
+	void * m_pMatchString;
+	int    m_pMatchStringLength;
+};
+
+//
+// Interface
+//
+class ElxInterface
+{
+public:
+	virtual int Match    (CContext * pContext) const = 0;
+	virtual int MatchNext(CContext * pContext) const = 0;
+
+public:
+	virtual ~ElxInterface() {};
+};
+
+//
+// Alternative
+//
+template <int x> class CAlternativeElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CAlternativeElxT();
+
+public:
+	CBufferT <ElxInterface *> m_elxlist;
+};
+
+typedef CAlternativeElxT <0> CAlternativeElx;
+
+//
+// Assert
+//
+template <int x> class CAssertElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CAssertElxT(ElxInterface * pelx, int byes = 1);
+
+public:
+	ElxInterface * m_pelx;
+	int m_byes;
+};
+
+typedef CAssertElxT <0> CAssertElx;
+
+//
+// Back reference elx
+//
+template <class CHART> class CBackrefElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CBackrefElxT(int nnumber, int brightleft, int bignorecase);
+
+public:
+	int m_nnumber;
+	int m_brightleft;
+	int m_bignorecase;
+
+	CBufferT <CHART> m_szNamed;
+};
+
+//
+// Implementation
+//
+template <class CHART> CBackrefElxT <CHART> :: CBackrefElxT(int nnumber, int brightleft, int bignorecase)
+{
+	m_nnumber     = nnumber;
+	m_brightleft  = brightleft;
+	m_bignorecase = bignorecase;
+}
+
+template <class CHART> int CBackrefElxT <CHART> :: Match(CContext * pContext) const
+{
+	// check number, for named
+	if( m_nnumber < 0 || m_nnumber >= pContext->m_captureindex.GetSize() ) return 0;
+
+	int index = pContext->m_captureindex[m_nnumber];
+	if( index < 0 ) return 0;
+
+	// check enclosed
+	int pos1 = pContext->m_capturestack[index + 1];
+	int pos2 = pContext->m_capturestack[index + 2];
+
+	if( pos2 < 0 ) pos2 = pContext->m_nCurrentPos;
+
+	// info
+	int lpos = pos1 < pos2 ? pos1 : pos2;
+	int rpos = pos1 < pos2 ? pos2 : pos1;
+	int slen = rpos - lpos;
+
+	const CHART * pcsz = (const CHART *)pContext->m_pMatchString;
+	int npos = pContext->m_nCurrentPos;
+	int tlen = pContext->m_pMatchStringLength;
+
+	// compare
+	int bsucc;
+	CBufferRefT <CHART> refstr(pcsz + lpos, slen);
+
+	if( m_brightleft )
+	{
+		if(npos < slen)
+			return 0;
+
+		if(m_bignorecase)
+			bsucc = ! refstr.nCompareNoCase(pcsz + (npos - slen));
+		else
+			bsucc = ! refstr.nCompare      (pcsz + (npos - slen));
+
+		if( bsucc )
+		{
+			pContext->m_stack.Push(npos);
+			pContext->m_nCurrentPos -= slen;
+		}
+	}
+	else
+	{
+		if(npos + slen > tlen)
+			return 0;
+
+		if(m_bignorecase)
+			bsucc = ! refstr.nCompareNoCase(pcsz + npos);
+		else
+			bsucc = ! refstr.nCompare      (pcsz + npos);
+
+		if( bsucc )
+		{
+			pContext->m_stack.Push(npos);
+			pContext->m_nCurrentPos += slen;
+		}
+	}
+
+	return bsucc;
+}
+
+template <class CHART> int CBackrefElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	int npos = 0;
+
+	pContext->m_stack.Pop(npos);
+	pContext->m_nCurrentPos = npos;
+
+	return 0;
+}
+
+// RCHART
+#ifndef RCHART
+	#define RCHART(ch) ((CHART)ch)
+#endif
+
+// BOUNDARY_TYPE
+enum BOUNDARY_TYPE
+{
+	BOUNDARY_FILE_BEGIN, // begin of whole text
+	BOUNDARY_FILE_END  , // end of whole text
+	BOUNDARY_FILE_END_N, // end of whole text, or before newline at the end
+	BOUNDARY_LINE_BEGIN, // begin of line
+	BOUNDARY_LINE_END  , // end of line
+	BOUNDARY_WORD_BEGIN, // begin of word
+	BOUNDARY_WORD_END  , // end of word
+	BOUNDARY_WORD_EDGE ,
+};
+
+//
+// Boundary Elx
+//
+template <class CHART> class CBoundaryElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CBoundaryElxT(int ntype, int byes = 1);
+
+protected:
+	static int IsWordChar(CHART ch);
+
+public:
+	int m_ntype;
+	int m_byes;
+};
+
+//
+// Implementation
+//
+template <class CHART> CBoundaryElxT <CHART> :: CBoundaryElxT(int ntype, int byes)
+{
+	m_ntype = ntype;
+	m_byes  = byes;
+}
+
+template <class CHART> int CBoundaryElxT <CHART> :: Match(CContext * pContext) const
+{
+	const CHART * pcsz  = (const CHART *)pContext->m_pMatchString;
+	int npos = pContext->m_nCurrentPos;
+	int tlen = pContext->m_pMatchStringLength;
+
+	CHART chL = npos > 0    ? pcsz[npos - 1] : 0;
+	CHART chR = npos < tlen ? pcsz[npos    ] : 0;
+
+	int bsucc = 0;
+
+	switch(m_ntype)
+	{
+	case BOUNDARY_FILE_BEGIN:
+		bsucc = (npos <= 0);
+		break;
+
+	case BOUNDARY_FILE_END:
+		bsucc = (npos >= tlen);
+		break;
+
+	case BOUNDARY_FILE_END_N:
+		bsucc = (npos >= tlen) || (pcsz[tlen-1] == RCHART('\n') && (npos == tlen-1 || (pcsz[tlen-2] == RCHART('\r') && npos == tlen-2)));
+		break;
+
+	case BOUNDARY_LINE_BEGIN:
+		bsucc = (npos <= 0   ) || (chL == RCHART('\n')) || ((chL == RCHART('\r')) && (chR != RCHART('\n')));
+		break;
+
+	case BOUNDARY_LINE_END:
+		bsucc = (npos >= tlen) || (chR == RCHART('\r')) || ((chR == RCHART('\n')) && (chL != RCHART('\r')));
+		break;
+
+	case BOUNDARY_WORD_BEGIN:
+		bsucc = ! IsWordChar(chL) &&   IsWordChar(chR);
+		break;
+
+	case BOUNDARY_WORD_END:
+		bsucc =   IsWordChar(chL) && ! IsWordChar(chR);
+		break;
+
+	case BOUNDARY_WORD_EDGE:
+		bsucc =   IsWordChar(chL) ?  ! IsWordChar(chR) : IsWordChar(chR);
+		break;
+	}
+
+	return m_byes ? bsucc : ! bsucc;
+}
+
+template <class CHART> int CBoundaryElxT <CHART> :: MatchNext(CContext *) const
+{
+	return 0;
+}
+
+template <class CHART> inline int CBoundaryElxT <CHART> :: IsWordChar(CHART ch)
+{
+	return (ch >= RCHART('A') && ch <= RCHART('Z')) || (ch >= RCHART('a') && ch <= RCHART('z')) || (ch >= RCHART('0') && ch <= RCHART('9')) || (ch == RCHART('_'));
+}
+
+//
+// Bracket
+//
+template <class CHART> class CBracketElxT : public ElxInterface  
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CBracketElxT(int nnumber, int bright);
+	int CheckCaptureIndex(int & index, CContext * pContext) const;
+
+public:
+	int m_nnumber;
+	int m_bright;
+
+	CBufferT <CHART> m_szNamed;
+};
+
+template <class CHART> CBracketElxT <CHART> :: CBracketElxT(int nnumber, int bright)
+{
+	m_nnumber = nnumber;
+	m_bright  = bright;
+}
+
+template <class CHART> inline int CBracketElxT <CHART> :: CheckCaptureIndex(int & index, CContext * pContext) const
+{
+	if( index >= pContext->m_capturestack.GetSize() )
+		index  = pContext->m_capturestack.GetSize() - 4;
+
+	while(index >= 0)
+	{
+		if(pContext->m_capturestack[index] == m_nnumber)
+		{
+			return 1;
+		}
+
+		index -= 4;
+	}
+
+
+	return 0;
+}
+
+//
+// capturestack[index+0] => Group number
+// capturestack[index+1] => Capture start pos
+// capturestack[index+2] => Capture end pos
+// capturestack[index+3] => Capture enclose z-index, zindex<0 means inner group with same name
+//
+template <class CHART> int CBracketElxT <CHART> :: Match(CContext * pContext) const
+{
+	// check, for named
+	if(m_nnumber < 0) return 0;
+
+	if( ! m_bright )
+	{
+		pContext->m_captureindex.Prepare(m_nnumber, -1);
+		int index = pContext->m_captureindex[m_nnumber];
+
+		// check
+		if(CheckCaptureIndex(index, pContext) && pContext->m_capturestack[index+2] < 0)
+		{
+			pContext->m_capturestack[index+3] --;
+			return 1;
+		}
+
+		// save
+		pContext->m_captureindex[m_nnumber] = pContext->m_capturestack.GetSize();
+
+		pContext->m_capturestack.Push(m_nnumber);
+		pContext->m_capturestack.Push(pContext->m_nCurrentPos);
+		pContext->m_capturestack.Push(-1);
+		pContext->m_capturestack.Push( 0); // z-index
+	}
+	else
+	{
+		// check
+		int index = pContext->m_captureindex[m_nnumber];
+
+		if(CheckCaptureIndex(index, pContext))
+		{
+			if(pContext->m_capturestack[index + 3] < 0) // check inner group with same name
+			{
+				pContext->m_capturestack[index + 3] ++;
+				return 1;
+			}
+
+			// save
+			pContext->m_capturestack[index + 2] = pContext->m_nCurrentPos;
+			pContext->m_capturestack[index + 3] = pContext->m_nParenZindex ++;
+		}
+	}
+
+	return 1;
+}
+
+template <class CHART> int CBracketElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	int index = pContext->m_captureindex[m_nnumber];
+	if( ! CheckCaptureIndex(index, pContext) )
+	{
+		return 0;
+	}
+
+	if( ! m_bright )
+	{
+		if(pContext->m_capturestack[index + 3] < 0)
+		{
+			pContext->m_capturestack[index + 3] ++;
+			return 0;
+		}
+
+		pContext->m_capturestack.Restore(pContext->m_capturestack.GetSize() - 4);
+
+		// to find
+		CheckCaptureIndex(index, pContext);
+
+		// new index
+		pContext->m_captureindex[m_nnumber] = index;
+	}
+	else
+	{
+		if( pContext->m_capturestack[index + 2] >= 0 )
+		{
+			pContext->m_capturestack[index + 2] = -1;
+			pContext->m_capturestack[index + 3] =  0;
+		}
+		else
+		{
+			pContext->m_capturestack[index + 3] --;
+		}
+	}
+
+	return 0;
+}
+
+//
+// Deletage
+//
+template <class CHART> class CDelegateElxT : public ElxInterface  
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CDelegateElxT(int ndata = 0);
+
+public:
+	ElxInterface * m_pelx;
+	int m_ndata; // +0 : recursive to
+	             // -3 : named recursive
+
+	CBufferT <CHART> m_szNamed;
+};
+
+template <class CHART> CDelegateElxT <CHART> :: CDelegateElxT(int ndata)
+{
+	m_pelx  = 0;
+	m_ndata = ndata;
+}
+
+template <class CHART> int CDelegateElxT <CHART> :: Match(CContext * pContext) const
+{
+	if(m_pelx != 0)
+		return m_pelx->Match(pContext);
+	else
+		return 1;
+}
+
+template <class CHART> int CDelegateElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	if(m_pelx != 0)
+		return m_pelx->MatchNext(pContext);
+	else
+		return 0;
+}
+
+//
+// Empty
+//
+template <int x> class CEmptyElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CEmptyElxT();
+};
+
+typedef CEmptyElxT <0> CEmptyElx;
+
+//
+// Global
+//
+template <int x> class CGlobalElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CGlobalElxT();
+};
+
+typedef CGlobalElxT <0> CGlobalElx;
+
+//
+// Repeat
+//
+template <int x> class CRepeatElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CRepeatElxT(ElxInterface * pelx, int ntimes);
+
+protected:
+	int MatchFixed    (CContext * pContext) const;
+	int MatchNextFixed(CContext * pContext) const;
+
+public:
+	ElxInterface * m_pelx;
+	int m_nfixed;
+};
+
+typedef CRepeatElxT <0> CRepeatElx;
+
+//
+// Greedy
+//
+template <int x> class CGreedyElxT : public CRepeatElxT <x>
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CGreedyElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);
+
+protected:
+	int MatchVart    (CContext * pContext) const;
+	int MatchNextVart(CContext * pContext) const;
+
+public:
+	int m_nvart;
+};
+
+typedef CGreedyElxT <0> CGreedyElx;
+
+//
+// Independent
+//
+template <int x> class CIndependentElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CIndependentElxT(ElxInterface * pelx);
+
+public:
+	ElxInterface * m_pelx;
+};
+
+typedef CIndependentElxT <0> CIndependentElx;
+
+//
+// List
+//
+template <int x> class CListElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CListElxT(int brightleft);
+
+public:
+	CBufferT <ElxInterface *> m_elxlist;
+	int m_brightleft;
+};
+
+typedef CListElxT <0> CListElx;
+
+//
+// Posix Elx
+//
+template <class CHART> class CPosixElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CPosixElxT(const char * posix, int brightleft);
+
+protected:
+	static int m_isblank(int c);
+
+public:
+	int (*m_posixfun)(int);
+	int m_brightleft;
+	int m_byes;
+};
+
+//
+// Implementation
+//
+template <class CHART> CPosixElxT <CHART> :: CPosixElxT(const char * posix, int brightleft)
+{
+	m_brightleft = brightleft;
+
+	if(posix[1] == '^')
+	{
+		m_byes = 0;
+		posix += 2;
+	}
+	else
+	{
+		m_byes = 1;
+		posix += 1;
+	}
+
+	if     (!strncmp(posix, "alnum:", 6)) m_posixfun = ::isalnum ;
+	else if(!strncmp(posix, "alpha:", 6)) m_posixfun = ::isalpha ;
+	else if(!strncmp(posix, "ascii:", 6)) m_posixfun = ::isascii ;
+	else if(!strncmp(posix, "cntrl:", 6)) m_posixfun = ::iscntrl ;
+	else if(!strncmp(posix, "digit:", 6)) m_posixfun = ::isdigit ;
+	else if(!strncmp(posix, "graph:", 6)) m_posixfun = ::isgraph ;
+	else if(!strncmp(posix, "lower:", 6)) m_posixfun = ::islower ;
+	else if(!strncmp(posix, "print:", 6)) m_posixfun = ::isprint ;
+	else if(!strncmp(posix, "punct:", 6)) m_posixfun = ::ispunct ;
+	else if(!strncmp(posix, "space:", 6)) m_posixfun = ::isspace ;
+	else if(!strncmp(posix, "upper:", 6)) m_posixfun = ::isupper ;
+	else if(!strncmp(posix, "xdigit:",7)) m_posixfun = ::isxdigit;
+	else if(!strncmp(posix, "blank:", 6)) m_posixfun = m_isblank ;
+	else                                  m_posixfun = 0         ;
+}
+
+template <class CHART> int CPosixElxT <CHART> :: m_isblank(int c)
+{
+	return c == 0x20 || c == '\t';
+}
+
+template <class CHART> int CPosixElxT <CHART> :: Match(CContext * pContext) const
+{
+	if(m_posixfun == 0) return 0;
+
+	int tlen = pContext->m_pMatchStringLength;
+	int npos = pContext->m_nCurrentPos;
+
+	// check
+	int at   = m_brightleft ? npos - 1 : npos;
+	if( at < 0 || at >= tlen )
+		return 0;
+
+	CHART ch = ((const CHART *)pContext->m_pMatchString)[at];
+
+	int bsucc = (*m_posixfun)(ch);
+
+	if( ! m_byes )
+		bsucc = ! bsucc;
+
+	if( bsucc )
+		pContext->m_nCurrentPos += m_brightleft ? -1 : 1;
+
+	return bsucc;
+}
+
+template <class CHART> int CPosixElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	pContext->m_nCurrentPos -= m_brightleft ? -1 : 1;
+	return 0;
+}
+
+//
+// Possessive
+//
+template <int x> class CPossessiveElxT : public CGreedyElxT <x>
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CPossessiveElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);
+};
+
+typedef CPossessiveElxT <0> CPossessiveElx;
+
+//
+// Range Elx
+//
+template <class CHART> class CRangeElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CRangeElxT(int brightleft, int byes);
+
+public:
+	int IsContainChar(CHART ch) const;
+
+public:
+	CBufferT <CHART> m_ranges;
+	CBufferT <CHART> m_chars;
+	CBufferT <ElxInterface *> m_embeds;
+
+public:
+	int m_brightleft;
+	int m_byes;
+};
+
+//
+// Implementation
+//
+template <class CHART> CRangeElxT <CHART> :: CRangeElxT(int brightleft, int byes)
+{
+	m_brightleft = brightleft;
+	m_byes       = byes;
+}
+
+template <class CHART> int CRangeElxT <CHART> :: Match(CContext * pContext) const
+{
+	int tlen = pContext->m_pMatchStringLength;
+	int npos = pContext->m_nCurrentPos;
+
+	// check
+	int at   = m_brightleft ? npos - 1 : npos;
+	if( at < 0 || at >= tlen )
+		return 0;
+
+	CHART ch = ((const CHART *)pContext->m_pMatchString)[at];
+	int bsucc = 0, i;
+
+	// compare
+	for(i=0; !bsucc && i<m_ranges.GetSize(); i+=2)
+	{
+		if(m_ranges[i] <= ch && ch <= m_ranges[i+1]) bsucc = 1;
+	}
+
+	for(i=0; !bsucc && i<m_chars.GetSize(); i++)
+	{
+		if(m_chars[i] == ch) bsucc = 1;
+	}
+
+	for(i=0; !bsucc && i<m_embeds.GetSize(); i++)
+	{
+		if(m_embeds[i]->Match(pContext))
+		{
+			pContext->m_nCurrentPos = npos;
+			bsucc = 1;
+		}
+	}
+
+	if( ! m_byes )
+		bsucc = ! bsucc;
+
+	if( bsucc )
+		pContext->m_nCurrentPos += m_brightleft ? -1 : 1;
+
+	return bsucc;
+}
+
+template <class CHART> int CRangeElxT <CHART> :: IsContainChar(CHART ch) const
+{
+	int bsucc = 0, i;
+
+	// compare
+	for(i=0; !bsucc && i<m_ranges.GetSize(); i+=2)
+	{
+		if(m_ranges[i] <= ch && ch <= m_ranges[i+1]) bsucc = 1;
+	}
+
+	for(i=0; !bsucc && i<m_chars.GetSize(); i++)
+	{
+		if(m_chars[i] == ch) bsucc = 1;
+	}
+
+	return bsucc;
+}
+
+template <class CHART> int CRangeElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	pContext->m_nCurrentPos -= m_brightleft ? -1 : 1;
+	return 0;
+}
+
+//
+// Reluctant
+//
+template <int x> class CReluctantElxT : public CRepeatElxT <x>
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CReluctantElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);
+
+protected:
+	int MatchVart    (CContext * pContext) const;
+	int MatchNextVart(CContext * pContext) const;
+
+public:
+	int m_nvart;
+};
+
+typedef CReluctantElxT <0> CReluctantElx;
+
+//
+// String Elx
+//
+template <class CHART> class CStringElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CStringElxT(const CHART * fixed, int nlength, int brightleft, int bignorecase);
+
+public:
+	CBufferT <CHART> m_szPattern;
+	int m_brightleft;
+	int m_bignorecase;
+};
+
+//
+// Implementation
+//
+template <class CHART> CStringElxT <CHART> :: CStringElxT(const CHART * fixed, int nlength, int brightleft, int bignorecase) : m_szPattern(fixed, nlength)
+{
+	m_brightleft  = brightleft;
+	m_bignorecase = bignorecase;
+}
+
+template <class CHART> int CStringElxT <CHART> :: Match(CContext * pContext) const
+{
+	const CHART * pcsz  = (const CHART *)pContext->m_pMatchString;
+	int npos = pContext->m_nCurrentPos;
+	int tlen = pContext->m_pMatchStringLength;
+	int slen = m_szPattern.GetSize();
+
+	int bsucc;
+
+	if(m_brightleft)
+	{
+		if(npos < slen)
+			return 0;
+
+		if(m_bignorecase)
+			bsucc = ! m_szPattern.nCompareNoCase(pcsz + (npos - slen));
+		else
+			bsucc = ! m_szPattern.nCompare      (pcsz + (npos - slen));
+
+		if( bsucc )
+			pContext->m_nCurrentPos -= slen;
+	}
+	else
+	{
+		if(npos + slen > tlen)
+			return 0;
+
+		if(m_bignorecase)
+			bsucc = ! m_szPattern.nCompareNoCase(pcsz + npos);
+		else
+			bsucc = ! m_szPattern.nCompare      (pcsz + npos);
+
+		if( bsucc )
+			pContext->m_nCurrentPos += slen;
+	}
+
+	return bsucc;
+}
+
+template <class CHART> int CStringElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	int slen = m_szPattern.GetSize();
+
+	if(m_brightleft)
+		pContext->m_nCurrentPos += slen;
+	else
+		pContext->m_nCurrentPos -= slen;
+
+	return 0;
+}
+
+//
+// CConditionElx
+//
+template <class CHART> class CConditionElxT : public ElxInterface
+{
+public:
+	int Match    (CContext * pContext) const;
+	int MatchNext(CContext * pContext) const;
+
+public:
+	CConditionElxT();
+
+public:
+	// backref condition
+	int m_nnumber;
+	CBufferT <CHART> m_szNamed;
+
+	// elx condition
+	ElxInterface * m_pelxask;
+
+	// selection
+	ElxInterface * m_pelxyes, * m_pelxno;
+};
+
+template <class CHART> CConditionElxT <CHART> :: CConditionElxT()
+{
+	m_nnumber = -1;
+}
+
+template <class CHART> int CConditionElxT <CHART> :: Match(CContext * pContext) const
+{
+	// status
+	int nbegin = pContext->m_nCurrentPos;
+	int nsize  = pContext->m_stack.GetSize();
+	int ncsize = pContext->m_capturestack.GetSize();
+
+	// condition result
+	int condition_yes = 0;
+
+	// backref type
+	if( m_nnumber >= 0 )
+	{
+		do
+		{
+			if(m_nnumber >= pContext->m_captureindex.GetSize()) break;
+
+			int index = pContext->m_captureindex[m_nnumber];
+			if( index < 0) break;
+
+			// else valid
+			condition_yes = 1;
+		}
+		while(0);
+	}
+	else
+	{
+		if( m_pelxask == 0 )
+			condition_yes = 1;
+		else
+			condition_yes = m_pelxask->Match(pContext);
+
+		pContext->m_stack.Restore(nsize);
+		pContext->m_nCurrentPos = nbegin;
+	}
+
+	// elx result
+	int bsucc;
+	if( condition_yes )
+		bsucc = m_pelxyes == 0 ? 1 : m_pelxyes->Match(pContext);
+	else
+		bsucc = m_pelxno  == 0 ? 1 : m_pelxno ->Match(pContext);
+
+	if( bsucc )
+	{
+		pContext->m_stack.Push(ncsize);
+		pContext->m_stack.Push(condition_yes);
+	}
+	else
+	{
+		pContext->m_capturestack.Restore(ncsize);
+	}
+
+	return bsucc;
+}
+
+template <class CHART> int CConditionElxT <CHART> :: MatchNext(CContext * pContext) const
+{
+	// pop
+	int ncsize = 0, condition_yes = 0;
+
+	pContext->m_stack.Pop(condition_yes);
+	pContext->m_stack.Pop(ncsize);
+
+	// elx result
+	int bsucc;
+	if( condition_yes )
+		bsucc = m_pelxyes == 0 ? 0 : m_pelxyes->MatchNext(pContext);
+	else
+		bsucc = m_pelxno  == 0 ? 0 : m_pelxno ->MatchNext(pContext);
+
+	if( bsucc )
+	{
+		pContext->m_stack.Push(ncsize);
+		pContext->m_stack.Push(condition_yes);
+	}
+	else
+	{
+		pContext->m_capturestack.Restore(ncsize);
+	}
+
+	return bsucc;
+}
+
+//
+// MatchResult
+//
+template <int x> class MatchResultT
+{
+public:
+	int IsMatched() const;
+
+public:
+	int GetStart() const;
+	int GetEnd  () const;
+
+public:
+	int MaxGroupNumber() const;
+	int GetGroupStart(int nGroupNumber) const;
+	int GetGroupEnd  (int nGroupNumber) const;
+
+public:
+	MatchResultT(CContext * pContext = 0, int nMaxNumber = -1);
+	MatchResultT <x> & operator = (const MatchResultT <x> &);
+	inline operator int() const { return IsMatched(); }
+
+public:
+	CBufferT <int> m_result;
+};
+
+typedef MatchResultT <0> MatchResult;
+
+// Stocked Elx IDs
+enum STOCKELX_ID_DEFINES
+{
+	STOCKELX_EMPTY = 0,
+
+	///////////////////////
+
+	STOCKELX_DOT_ALL,
+	STOCKELX_DOT_NOT_ALL,
+
+	STOCKELX_WORD,
+	STOCKELX_WORD_NOT,
+
+	STOCKELX_SPACE,
+	STOCKELX_SPACE_NOT,
+
+	STOCKELX_DIGITAL,
+	STOCKELX_DIGITAL_NOT,
+
+	//////////////////////
+
+	STOCKELX_DOT_ALL_RIGHTLEFT,
+	STOCKELX_DOT_NOT_ALL_RIGHTLEFT,
+
+	STOCKELX_WORD_RIGHTLEFT,
+	STOCKELX_WORD_RIGHTLEFT_NOT,
+
+	STOCKELX_SPACE_RIGHTLEFT,
+	STOCKELX_SPACE_RIGHTLEFT_NOT,
+
+	STOCKELX_DIGITAL_RIGHTLEFT,
+	STOCKELX_DIGITAL_RIGHTLEFT_NOT,
+
+	/////////////////////
+
+	STOCKELX_COUNT
+};
+
+// REGEX_FLAGS
+#ifndef _REGEX_FLAGS_DEFINED
+	enum REGEX_FLAGS
+	{
+		NO_FLAG        = 0,
+		SINGLELINE     = 0x01,
+		MULTILINE      = 0x02,
+		GLOBAL         = 0x04,
+		IGNORECASE     = 0x08,
+		RIGHTTOLEFT    = 0x10,
+		EXTENDED       = 0x20,
+	};
+	#define _REGEX_FLAGS_DEFINED
+#endif
+
+//
+// Builder T
+//
+template <class CHART> class CBuilderT
+{
+public:
+	typedef CDelegateElxT  <CHART> CDelegateElx;
+	typedef CBracketElxT   <CHART> CBracketElx;
+	typedef CBackrefElxT   <CHART> CBackrefElx;
+	typedef CConditionElxT <CHART> CConditionElx;
+
+// Methods
+public:
+	ElxInterface * Build(const CBufferRefT <CHART> & pattern, int flags);
+	int GetNamedNumber(const CBufferRefT <CHART> & named) const;
+	void Clear();
+
+public:
+	 CBuilderT();
+	~CBuilderT();
+
+// Public Attributes
+public:
+	ElxInterface * m_pTopElx;
+	int            m_nFlags;
+	int            m_nMaxNumber;
+	int            m_nNextNamed;
+	int            m_nGroupCount;
+
+	CBufferT <ElxInterface  *> m_objlist;
+	CBufferT <ElxInterface  *> m_grouplist;
+	CBufferT <CDelegateElx  *> m_recursivelist;
+	CBufferT <CListElx      *> m_namedlist;
+	CBufferT <CBackrefElx   *> m_namedbackreflist;
+	CBufferT <CConditionElx *> m_namedconditionlist;
+
+// CHART_INFO
+protected:
+	struct CHART_INFO
+	{
+	public:
+		CHART ch;
+		int   type;
+		int   pos;
+		int   len;
+
+	public:
+		CHART_INFO(CHART c, int t, int p = 0, int l = 0) { ch = c; type = t; pos = p; len = l;    }
+		inline int operator == (const CHART_INFO & ci)   { return ch == ci.ch && type == ci.type; }
+		inline int operator != (const CHART_INFO & ci)   { return ! operator == (ci);             }
+	};
+
+protected:
+	static unsigned int Hex2Int(const CHART * pcsz, int length, int & used);
+	static int ReadDec(char * & str, unsigned int & dec);
+	void MoveNext();
+	int  GetNext2();
+
+	ElxInterface * BuildAlternative(int vaflags);
+	ElxInterface * BuildList       (int & flags);
+	ElxInterface * BuildRepeat     (int & flags);
+	ElxInterface * BuildSimple     (int & flags);
+	ElxInterface * BuildCharset    (int & flags);
+	ElxInterface * BuildRecursive  (int & flags);
+	ElxInterface * BuildBoundary   (int & flags);
+	ElxInterface * BuildBackref    (int & flags);
+
+	ElxInterface * GetStockElx     (int nStockId);
+	ElxInterface * Keep(ElxInterface * pElx);
+
+// Private Attributes
+protected:
+	CBufferRefT <CHART> m_pattern;
+	CHART_INFO prev, curr, next, nex2;
+	int m_nNextPos;
+	int m_nCharsetDepth;
+	int m_bQuoted;
+	int (*m_quote_fun)(int);
+
+	ElxInterface * m_pStockElxs[STOCKELX_COUNT];
+};
+
+//
+// Implementation
+//
+template <class CHART> CBuilderT <CHART> :: CBuilderT() : m_pattern(0, 0), prev(0, 0), curr(0, 0), next(0, 0), nex2(0, 0)
+{
+	Clear();
+}
+
+template <class CHART> CBuilderT <CHART> :: ~CBuilderT()
+{
+	Clear();
+}
+
+template <class CHART> int CBuilderT <CHART> :: GetNamedNumber(const CBufferRefT <CHART> & named) const
+{
+	for(int i=0; i<m_namedlist.GetSize(); i++)
+	{
+		if( ! ((CBracketElx *)m_namedlist[i]->m_elxlist[0])->m_szNamed.CompareNoCase(named) )
+			return ((CBracketElx *)m_namedlist[i]->m_elxlist[0])->m_nnumber;
+	}
+
+	return -3;
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: Build(const CBufferRefT <CHART> & pattern, int flags)
+{
+	// init
+	m_pattern       = pattern;
+	m_nNextPos      = 0;
+	m_nCharsetDepth = 0;
+	m_nMaxNumber    = 0;
+	m_nNextNamed    = 0;
+	m_nFlags        = flags;
+	m_bQuoted       = 0;
+	m_quote_fun     = 0;
+
+	m_grouplist         .Restore(0);
+	m_recursivelist     .Restore(0);
+	m_namedlist         .Restore(0);
+	m_namedbackreflist  .Restore(0);
+	m_namedconditionlist.Restore(0);
+
+	int i;
+	for(i=0; i<3; i++) MoveNext();
+
+	// build
+	m_pTopElx = BuildAlternative(flags);
+
+	// group 0
+	m_grouplist.Prepare(0);
+	m_grouplist[0] = m_pTopElx;
+
+	// append named to unnamed
+	m_nGroupCount = m_grouplist.GetSize();
+
+	m_grouplist.Prepare(m_nMaxNumber + m_namedlist.GetSize());
+
+	for(i=0; i<m_namedlist.GetSize(); i++)
+	{
+		CBracketElx * pleft  = (CBracketElx *)m_namedlist[i]->m_elxlist[0];
+		CBracketElx * pright = (CBracketElx *)m_namedlist[i]->m_elxlist[2];
+
+		// append
+		m_grouplist[m_nGroupCount ++] = m_namedlist[i];
+
+		if( pleft->m_nnumber > 0 )
+			continue;
+
+		// same name
+		int find_same_name = GetNamedNumber(pleft->m_szNamed);
+		if( find_same_name >= 0 )
+		{
+			pleft ->m_nnumber = find_same_name;
+			pright->m_nnumber = find_same_name;
+		}
+		else
+		{
+			m_nMaxNumber ++;
+
+			pleft ->m_nnumber = m_nMaxNumber;
+			pright->m_nnumber = m_nMaxNumber;
+		}
+	}
+
+	for(i=1; i<m_nGroupCount; i++)
+	{
+		CBracketElx * pleft = (CBracketElx *)((CListElx*)m_grouplist[i])->m_elxlist[0];
+
+		if( pleft->m_nnumber > m_nMaxNumber )
+			m_nMaxNumber = pleft->m_nnumber;
+	}
+
+	// connect recursive
+	for(i=0; i<m_recursivelist.GetSize(); i++)
+	{
+		if( m_recursivelist[i]->m_ndata == -3 )
+			m_recursivelist[i]->m_ndata = GetNamedNumber(m_recursivelist[i]->m_szNamed);
+
+		if( m_recursivelist[i]->m_ndata >= 0 && m_recursivelist[i]->m_ndata <= m_nMaxNumber )
+		{
+			if( m_recursivelist[i]->m_ndata == 0 )
+				m_recursivelist[i]->m_pelx = m_pTopElx;
+			else for(int j=1; j<m_grouplist.GetSize(); j++)
+			{
+				if(m_recursivelist[i]->m_ndata == ((CBracketElx *)((CListElx*)m_grouplist[j])->m_elxlist[0])->m_nnumber)
+				{
+					m_recursivelist[i]->m_pelx = m_grouplist[j];
+					break;
+				}
+			}
+		}
+	}
+
+	// named backref
+	for(i=0; i<m_namedbackreflist.GetSize(); i++)
+	{
+		m_namedbackreflist[i]->m_nnumber = GetNamedNumber(m_namedbackreflist[i]->m_szNamed);
+	}
+
+	// named condition
+	for(i=0; i<m_namedconditionlist.GetSize(); i++)
+	{
+		int nn = GetNamedNumber(m_namedconditionlist[i]->m_szNamed);
+		if( nn >= 0 )
+		{
+			m_namedconditionlist[i]->m_nnumber = nn;
+			m_namedconditionlist[i]->m_pelxask = 0;
+		}
+	}
+
+	return m_pTopElx;
+}
+
+template <class CHART> void CBuilderT <CHART> :: Clear()
+{
+	for(int i=0; i<m_objlist.GetSize(); i++)
+	{
+		delete m_objlist[i];
+	}
+
+	m_objlist.Restore(0);
+	m_pTopElx = 0;
+	m_nMaxNumber = 0;
+
+	memset(m_pStockElxs, 0, sizeof(m_pStockElxs));
+}
+
+//
+// hex to int
+//
+template <class CHART> unsigned int CBuilderT <CHART> :: Hex2Int(const CHART * pcsz, int length, int & used)
+{
+	unsigned int result = 0;
+	int & i = used;
+
+	for(i=0; i<length; i++)
+	{
+		if(pcsz[i] >= RCHART('0') && pcsz[i] <= RCHART('9'))
+			result = (result << 4) + (pcsz[i] - RCHART('0'));
+		else if(pcsz[i] >= RCHART('A') && pcsz[i] <= RCHART('F'))
+			result = (result << 4) + (0x0A + (pcsz[i] - RCHART('A')));
+		else if(pcsz[i] >= RCHART('a') && pcsz[i] <= RCHART('f'))
+			result = (result << 4) + (0x0A + (pcsz[i] - RCHART('a')));
+		else
+			break;
+	}
+
+	return result;
+}
+
+template <class CHART> inline ElxInterface * CBuilderT <CHART> :: Keep(ElxInterface * pelx)
+{
+	m_objlist.Push(pelx);
+	return pelx;
+}
+
+template <class CHART> void CBuilderT <CHART> :: MoveNext()
+{
+	// forwards
+	prev = curr;
+	curr = next;
+	next = nex2;
+
+	// get nex2
+	while( ! GetNext2() ) {};
+}
+
+template <class CHART> int CBuilderT <CHART> :: GetNext2()
+{
+	// check length
+	if(m_nNextPos >= m_pattern.GetSize())
+	{
+		nex2 = CHART_INFO(0, 1, m_nNextPos, 0);
+		return 1;
+	}
+
+	int   delta = 1;
+	CHART ch    = m_pattern[m_nNextPos];
+
+	// if quoted
+	if(m_bQuoted)
+	{
+		if(ch == RCHART('\\'))
+		{
+			if(m_pattern[m_nNextPos + 1] == RCHART('E'))
+			{
+				m_quote_fun = 0;
+				m_bQuoted   = 0;
+				m_nNextPos += 2;
+				return 0;
+			}
+		}
+
+		if(m_quote_fun != 0)
+			nex2 = CHART_INFO((CHART)(*m_quote_fun)((int)ch), 0, m_nNextPos, delta);
+		else
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+
+		m_nNextPos += delta;
+
+		return 1;
+	}
+
+	// common
+	switch(ch)
+	{
+	case RCHART('\\'):
+		{
+			CHART ch1 = m_pattern[m_nNextPos+1];
+
+			// backref
+			if(ch1 >= RCHART('0') && ch1 <= RCHART('9'))
+			{
+				nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+				break;
+			}
+
+			// escape
+			delta     = 2;
+
+			switch(ch1)
+			{
+			case RCHART('A'):
+			case RCHART('Z'):
+			case RCHART('z'):
+			case RCHART('w'):
+			case RCHART('W'):
+			case RCHART('s'):
+			case RCHART('S'):
+			case RCHART('B'):
+			case RCHART('d'):
+			case RCHART('D'):
+			case RCHART('k'):
+			case RCHART('g'):
+				nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
+				break;
+
+			case RCHART('b'):
+				if(m_nCharsetDepth > 0)
+					nex2 = CHART_INFO('\b', 0, m_nNextPos, delta);
+				else
+					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
+				break;
+
+			/*
+			case RCHART('<'):
+			case RCHART('>'):
+				if(m_nCharsetDepth > 0)
+					nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
+				else
+					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
+				break;
+			*/
+
+			case RCHART('x'):
+				if(m_pattern[m_nNextPos+2] != '{')
+				{
+					int red = 0;
+					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 2, 2, red);
+
+					delta += red;
+
+					if(red > 0)
+						nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
+					else
+						nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
+
+					break;
+				}
+
+			case RCHART('u'):
+				if(m_pattern[m_nNextPos+2] != '{')
+				{
+					int red = 0;
+					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 2, 4, red);
+
+					delta += red;
+
+					if(red > 0)
+						nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
+					else
+						nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
+				}
+				else
+				{
+					int red = 0;
+					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 3, sizeof(int) * 2, red);
+
+					delta += red;
+
+					while(m_nNextPos + delta < m_pattern.GetSize() && m_pattern.At(m_nNextPos + delta) != RCHART('}'))
+						delta ++;
+
+					delta ++; // skip '}'
+
+					nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
+				}
+				break;
+
+			case RCHART('a'): nex2 = CHART_INFO(RCHART('\a'), 0, m_nNextPos, delta); break;
+			case RCHART('f'): nex2 = CHART_INFO(RCHART('\f'), 0, m_nNextPos, delta); break;
+			case RCHART('n'): nex2 = CHART_INFO(RCHART('\n'), 0, m_nNextPos, delta); break;
+			case RCHART('r'): nex2 = CHART_INFO(RCHART('\r'), 0, m_nNextPos, delta); break;
+			case RCHART('t'): nex2 = CHART_INFO(RCHART('\t'), 0, m_nNextPos, delta); break;
+			case RCHART('v'): nex2 = CHART_INFO(RCHART('\v'), 0, m_nNextPos, delta); break;
+			case RCHART('e'): nex2 = CHART_INFO(RCHART( 27 ), 0, m_nNextPos, delta); break;
+
+			case RCHART('G'):  // skip '\G'
+				if(m_nCharsetDepth > 0)
+				{
+					m_nNextPos += 2;
+					return 0;
+				}
+				else
+				{
+					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
+					break;
+				}
+
+			case RCHART('L'):
+				if( ! m_quote_fun ) m_quote_fun = ::tolower;
+
+			case RCHART('U'):
+				if( ! m_quote_fun ) m_quote_fun = ::toupper;
+
+			case RCHART('Q'):
+				{
+					m_bQuoted   = 1;
+					m_nNextPos += 2;
+					return 0;
+				}
+
+			case RCHART('E'):
+				{
+					m_quote_fun = 0;
+					m_bQuoted   = 0;
+					m_nNextPos += 2;
+					return 0;
+				}
+
+			case 0:
+				if(m_nNextPos+1 >= m_pattern.GetSize())
+				{
+					delta = 1;
+					nex2 = CHART_INFO(ch , 0, m_nNextPos, delta);
+				}
+				else
+					nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta); // common '\0' char
+				break;
+
+			default:
+				nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
+				break;
+			}
+		}
+		break;
+
+	case RCHART('*'):
+	case RCHART('+'):
+	case RCHART('?'):
+	case RCHART('.'):
+	case RCHART('{'):
+	case RCHART('}'):
+	case RCHART(')'):
+	case RCHART('|'):
+	case RCHART('$'):
+		if(m_nCharsetDepth > 0)
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		else
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		break;
+
+	case RCHART('-'):
+		if(m_nCharsetDepth > 0)
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		else
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		break;
+
+	case RCHART('('):
+		{
+			CHART ch1 = m_pattern[m_nNextPos+1];
+			CHART ch2 = m_pattern[m_nNextPos+2];
+
+			// skip remark
+			if(ch1 == RCHART('?') && ch2 == RCHART('#'))
+			{
+				m_nNextPos += 2;
+				while(m_nNextPos < m_pattern.GetSize())
+				{
+					if(m_pattern[m_nNextPos] == RCHART(')'))
+						break;
+
+					m_nNextPos ++;
+				}
+
+				if(m_pattern[m_nNextPos] == RCHART(')'))
+				{
+					m_nNextPos ++;
+
+					// get next nex2
+					return 0;
+				}
+			}
+			else
+			{
+				if(m_nCharsetDepth > 0)
+					nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+				else
+					nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+			}
+		}
+		break;
+
+	case RCHART('#'):
+		if(m_nFlags & EXTENDED)
+		{
+			// skip remark
+			m_nNextPos ++;
+
+			while(m_nNextPos < m_pattern.GetSize())
+			{
+				if(m_pattern[m_nNextPos] == RCHART('\n') || m_pattern[m_nNextPos] == RCHART('\r'))
+					break;
+
+				m_nNextPos ++;
+			}
+
+			// get next nex2
+			return 0;
+		}
+		else
+		{
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		}
+		break;
+
+	case RCHART(' '):
+	case RCHART('\f'):
+	case RCHART('\n'):
+	case RCHART('\r'):
+	case RCHART('\t'):
+	case RCHART('\v'):
+		if(m_nFlags & EXTENDED)
+		{
+			m_nNextPos ++;
+
+			// get next nex2
+			return 0;
+		}
+		else
+		{
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		}
+		break;
+
+	case RCHART('['):
+		if( m_nCharsetDepth == 0 || m_pattern.At(m_nNextPos + 1, 0) == RCHART(':') )
+		{
+			m_nCharsetDepth ++;
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		}
+		else
+		{
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		}
+		break;
+
+	case RCHART(']'):
+		if(m_nCharsetDepth > 0)
+		{
+			m_nCharsetDepth --;
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		}
+		else
+		{
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		}
+		break;
+
+	case RCHART(':'):
+		if(next == CHART_INFO(RCHART('['), 1))
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		else
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		break;
+
+	case RCHART('^'):
+		if(m_nCharsetDepth == 0 || next == CHART_INFO(RCHART('['), 1) || (curr == CHART_INFO(RCHART('['), 1) && next == CHART_INFO(RCHART(':'), 1)))
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
+		else
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		break;
+
+	case 0:
+		if(m_nNextPos >= m_pattern.GetSize())
+			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta); // end of string
+		else
+			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta); // common '\0' char
+		break;
+
+	default:
+		nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
+		break;
+	}
+
+	m_nNextPos += delta;
+
+	return 1;
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: GetStockElx(int nStockId)
+{
+	ElxInterface ** pStockElxs = m_pStockElxs;
+
+	// check
+	if(nStockId < 0 || nStockId >= STOCKELX_COUNT)
+		return GetStockElx(0);
+
+	// create if no
+	if(pStockElxs[nStockId] == 0)
+	{
+		switch(nStockId)
+		{
+		case STOCKELX_EMPTY:
+			pStockElxs[nStockId] = Keep(new CEmptyElx());
+			break;
+
+		case STOCKELX_WORD:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));
+
+				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
+				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+				pRange->m_chars .Push(RCHART('_'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_WORD_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));
+
+				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
+				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+				pRange->m_chars .Push(RCHART('_'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DOT_ALL:
+			pStockElxs[nStockId] = Keep(new CRangeElxT <CHART> (0, 0));
+			break;
+
+		case STOCKELX_DOT_NOT_ALL:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));
+
+				pRange->m_chars .Push(RCHART('\n'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_SPACE:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));
+
+				pRange->m_chars .Push(RCHART(' '));
+				pRange->m_chars .Push(RCHART('\t'));
+				pRange->m_chars .Push(RCHART('\r'));
+				pRange->m_chars .Push(RCHART('\n'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_SPACE_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));
+
+				pRange->m_chars .Push(RCHART(' '));
+				pRange->m_chars .Push(RCHART('\t'));
+				pRange->m_chars .Push(RCHART('\r'));
+				pRange->m_chars .Push(RCHART('\n'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DIGITAL:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));
+
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DIGITAL_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));
+
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_WORD_RIGHTLEFT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));
+
+				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
+				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+				pRange->m_chars .Push(RCHART('_'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_WORD_RIGHTLEFT_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));
+
+				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
+				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+				pRange->m_chars .Push(RCHART('_'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DOT_ALL_RIGHTLEFT:
+			pStockElxs[nStockId] = Keep(new CRangeElxT <CHART> (1, 0));
+			break;
+
+		case STOCKELX_DOT_NOT_ALL_RIGHTLEFT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));
+
+				pRange->m_chars .Push(RCHART('\n'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_SPACE_RIGHTLEFT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));
+
+				pRange->m_chars .Push(RCHART(' '));
+				pRange->m_chars .Push(RCHART('\t'));
+				pRange->m_chars .Push(RCHART('\r'));
+				pRange->m_chars .Push(RCHART('\n'));
+				pRange->m_chars .Push(RCHART('\f'));
+				pRange->m_chars .Push(RCHART('\v'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_SPACE_RIGHTLEFT_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));
+
+				pRange->m_chars .Push(RCHART(' '));
+				pRange->m_chars .Push(RCHART('\t'));
+				pRange->m_chars .Push(RCHART('\r'));
+				pRange->m_chars .Push(RCHART('\n'));
+				pRange->m_chars .Push(RCHART('\f'));
+				pRange->m_chars .Push(RCHART('\v'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DIGITAL_RIGHTLEFT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));
+
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+
+		case STOCKELX_DIGITAL_RIGHTLEFT_NOT:
+			{
+				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));
+
+				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
+
+				pStockElxs[nStockId] = pRange;
+			}
+			break;
+		}
+	}
+
+	// return
+	return pStockElxs[nStockId];
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildAlternative(int vaflags)
+{
+	if(curr == CHART_INFO(0, 1))
+		return GetStockElx(STOCKELX_EMPTY);
+
+	// flag instance
+	int flags = vaflags;
+
+	// first part
+	ElxInterface * pAlternativeOne = BuildList(flags);
+
+	// check alternative
+	if(curr == CHART_INFO(RCHART('|'), 1))
+	{
+		CAlternativeElx * pAlternative = (CAlternativeElx *)Keep(new CAlternativeElx());
+		pAlternative->m_elxlist.Push(pAlternativeOne);
+
+		// loop
+		while(curr == CHART_INFO(RCHART('|'), 1))
+		{
+			// skip '|' itself
+			MoveNext();
+
+			pAlternativeOne = BuildList(flags);
+			pAlternative->m_elxlist.Push(pAlternativeOne);
+		}
+
+		return pAlternative;
+	}
+
+	return pAlternativeOne;
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildList(int & flags)
+{
+	if(curr == CHART_INFO(0, 1) || curr == CHART_INFO(RCHART('|'), 1) || curr == CHART_INFO(RCHART(')'), 1))
+		return GetStockElx(STOCKELX_EMPTY);
+
+	// first
+	ElxInterface * pListOne = BuildRepeat(flags);
+
+	if(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('|'), 1) && curr != CHART_INFO(RCHART(')'), 1))
+	{
+		CListElx * pList = (CListElx *)Keep(new CListElx(flags & RIGHTTOLEFT));
+		pList->m_elxlist.Push(pListOne);
+
+		while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('|'), 1) && curr != CHART_INFO(RCHART(')'), 1))
+		{
+			pListOne = BuildRepeat(flags);
+
+			// add
+			pList->m_elxlist.Push(pListOne);
+		}
+
+		return pList;
+	}
+
+	return pListOne;
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildRepeat(int & flags)
+{
+	// simple
+	ElxInterface * pSimple = BuildSimple(flags);
+
+	if(curr.type == 0) return pSimple;
+
+	// is quantifier or not
+	int bIsQuantifier = 1;
+
+	// quantifier range
+	unsigned int nMin = 0, nMax = 0;
+
+	switch(curr.ch)
+	{
+	case RCHART('{'):
+		{
+			CBufferT <char> re;
+
+			// skip '{'
+			MoveNext();
+
+			// copy
+			while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('}'), 1))
+			{
+				re.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+				MoveNext();
+			}
+
+			// skip '}'
+			MoveNext();
+
+			// read
+			int red;
+			char * str = re.GetBuffer();
+
+			if( ! ReadDec(str, nMin) )
+				red = 0;
+			else if( *str != ',' )
+				red = 1;
+			else
+			{
+				str ++;
+
+				if( ! ReadDec(str, nMax) )
+					red = 2;
+				else
+					red = 3;
+			}
+
+			// check
+			if(red  <=  1 ) nMax = nMin;
+			if(red  ==  2 ) nMax = INT_MAX;
+			if(nMax < nMin) nMax = nMin;
+		}
+		break;
+
+	case RCHART('?'):
+		nMin = 0;
+		nMax = 1;
+
+		// skip '?'
+		MoveNext();
+		break;
+
+	case RCHART('*'):
+		nMin = 0;
+		nMax = INT_MAX;
+
+		// skip '*'
+		MoveNext();
+		break;
+
+	case RCHART('+'):
+		nMin = 1;
+		nMax = INT_MAX;
+
+		// skip '+'
+		MoveNext();
+		break;
+
+	default:
+		bIsQuantifier = 0;
+		break;
+	}
+
+	// do quantify
+	if(bIsQuantifier)
+	{
+		// 0 times
+		if(nMax == 0)
+			return GetStockElx(STOCKELX_EMPTY);
+
+		// fixed times
+		if(nMin == nMax)
+		{
+			if(curr == CHART_INFO(RCHART('?'), 1) || curr == CHART_INFO(RCHART('+'), 1))
+				MoveNext();
+
+			return Keep(new CRepeatElx(pSimple, nMin));
+		}
+
+		// range times
+		if(curr == CHART_INFO(RCHART('?'), 1))
+		{
+			MoveNext();
+			return Keep(new CReluctantElx(pSimple, nMin, nMax));
+		}
+		else if(curr == CHART_INFO(RCHART('+'), 1))
+		{
+			MoveNext();
+			return Keep(new CPossessiveElx(pSimple, nMin, nMax));
+		}
+		else
+		{
+			return Keep(new CGreedyElx(pSimple, nMin, nMax));
+		}
+	}
+
+	return pSimple;
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildSimple(int & flags)
+{
+	CBufferT <CHART> fixed;
+
+	while(curr != CHART_INFO(0, 1))
+	{
+		if(curr.type == 0)
+		{
+			if(next == CHART_INFO(RCHART('{'), 1) || next == CHART_INFO(RCHART('?'), 1) || next == CHART_INFO(RCHART('*'), 1) || next == CHART_INFO(RCHART('+'), 1))
+			{
+				if(fixed.GetSize() == 0)
+				{
+					fixed.Append(curr.ch, 1);
+					MoveNext();
+				}
+
+				break;
+			}
+			else
+			{
+				fixed.Append(curr.ch, 1);
+				MoveNext();
+			}
+		}
+		else if(curr.type == 1)
+		{
+			CHART vch = curr.ch;
+
+			// end of simple
+			if(vch == RCHART(')') || vch == RCHART('|'))
+				break;
+
+			// has fixed already
+			if(fixed.GetSize() > 0)
+				break;
+
+			// left parentheses
+			if(vch == RCHART('('))
+			{
+				return BuildRecursive(flags);
+			}
+
+			// char set
+			if( vch == RCHART('[') || vch == RCHART('.') || vch == RCHART('w') || vch == RCHART('W') ||
+				vch == RCHART('s') || vch == RCHART('S') || vch == RCHART('d') || vch == RCHART('D')
+			)
+			{
+				return BuildCharset(flags);
+			}
+
+			// boundary
+			if( vch == RCHART('^') || vch == RCHART('$') || vch == RCHART('A') || vch == RCHART('Z') || vch == RCHART('z') ||
+				vch == RCHART('b') || vch == RCHART('B') || vch == RCHART('G') // vch == RCHART('<') || vch == RCHART('>')
+			)
+			{
+				return BuildBoundary(flags);
+			}
+
+			// backref
+			if(vch == RCHART('\\') || vch == RCHART('k') || vch == RCHART('g'))
+			{
+				return BuildBackref(flags);
+			}
+
+			// treat vchar as char
+			fixed.Append(curr.ch, 1);
+			MoveNext();
+		}
+	}
+
+	if(fixed.GetSize() > 0)
+		return Keep(new CStringElxT <CHART> (fixed.GetBuffer(), fixed.GetSize(), flags & RIGHTTOLEFT, flags & IGNORECASE));
+	else
+		return GetStockElx(STOCKELX_EMPTY);
+}
+
+#define max(a, b)  (((a) > (b)) ? (a) : (b))
+#define min(a, b)  (((a) < (b)) ? (a) : (b))
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildCharset(int & flags)
+{
+	// char
+	CHART ch = curr.ch;
+
+	// skip
+	MoveNext();
+
+	switch(ch)
+	{
+	case RCHART('.'):
+		return GetStockElx(
+			flags & RIGHTTOLEFT ?
+			((flags & SINGLELINE) ? STOCKELX_DOT_ALL_RIGHTLEFT : STOCKELX_DOT_NOT_ALL_RIGHTLEFT) :
+			((flags & SINGLELINE) ? STOCKELX_DOT_ALL : STOCKELX_DOT_NOT_ALL)
+		);
+
+	case RCHART('w'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_WORD_RIGHTLEFT : STOCKELX_WORD);
+
+	case RCHART('W'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_WORD_RIGHTLEFT_NOT : STOCKELX_WORD_NOT);
+
+	case RCHART('s'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_SPACE_RIGHTLEFT : STOCKELX_SPACE);
+
+	case RCHART('S'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_SPACE_RIGHTLEFT_NOT : STOCKELX_SPACE_NOT);
+
+	case RCHART('d'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_DIGITAL_RIGHTLEFT : STOCKELX_DIGITAL);
+
+	case RCHART('D'):
+		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_DIGITAL_RIGHTLEFT_NOT : STOCKELX_DIGITAL_NOT);
+
+	case RCHART('['):
+		{
+			CRangeElxT <CHART> * pRange;
+
+			// create
+			if(curr == CHART_INFO(RCHART(':'), 1))
+			{
+				CBufferT <char> posix;
+
+				do {
+					posix.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+					MoveNext();
+				}
+				while(curr.ch != RCHART(0) && curr != CHART_INFO(RCHART(']'), 1));
+
+				MoveNext(); // skip ']'
+
+				// posix
+				return Keep(new CPosixElxT <CHART> (posix.GetBuffer(), flags & RIGHTTOLEFT));
+			}
+			else if(curr == CHART_INFO(RCHART('^'), 1))
+			{
+				MoveNext(); // skip '^'
+				pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (flags & RIGHTTOLEFT, 0));
+			}
+			else
+			{
+				pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (flags & RIGHTTOLEFT, 1));
+			}
+
+			// parse
+			while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART(']'), 1))
+			{
+				ch = curr.ch;
+
+				if(curr.type == 1 && (
+					ch == RCHART('.') || ch == RCHART('w') || ch == RCHART('W') || ch == RCHART('s') || ch == RCHART('S') || ch == RCHART('d') || ch == RCHART('D') ||
+					(ch == RCHART('[') && next == CHART_INFO(RCHART(':'), 1))
+				))
+				{
+					pRange->m_embeds.Push(BuildCharset(flags));
+				}
+				else if(next == CHART_INFO(RCHART('-'), 1) && nex2.type == 0)
+				{
+					pRange->m_ranges.Push(ch); pRange->m_ranges.Push(nex2.ch);
+
+					// next
+					MoveNext();
+					MoveNext();
+					MoveNext();
+				}
+				else
+				{
+					pRange->m_chars.Push(ch);
+
+					// next
+					MoveNext();
+				}
+			}
+
+			// skip ']'
+			MoveNext();
+
+			if( flags & IGNORECASE )
+			{
+				CBufferT <CHART> & ranges = pRange->m_ranges;
+				int i, oldcount = ranges.GetSize() / 2;
+
+				for(i=0; i<oldcount; i++)
+				{
+					CHART newmin, newmax;
+
+					if( ranges[i*2] <= RCHART('Z') && ranges[i*2+1] >= RCHART('A') )
+					{
+						newmin = tolower( max(RCHART('A'), ranges[i*2  ]) );
+						newmax = tolower( min(RCHART('Z'), ranges[i*2+1]) );
+
+						if( newmin < ranges[i*2] || newmax > ranges[i*2+1] )
+						{
+							ranges.Push(newmin);
+							ranges.Push(newmax);
+						}
+					}
+
+					if( ranges[i*2] <= RCHART('z') && ranges[i*2+1] >= RCHART('a') )
+					{
+						newmin = toupper( max(RCHART('a'), ranges[i*2  ]) );
+						newmax = toupper( min(RCHART('z'), ranges[i*2+1]) );
+
+						if( newmin < ranges[i*2] || newmax > ranges[i*2+1] )
+						{
+							ranges.Push(newmin);
+							ranges.Push(newmax);
+						}
+					}
+				}
+
+				CBufferT <CHART> & chars = pRange->m_chars;
+				oldcount = chars.GetSize();
+				for(i=0; i<oldcount; i++)
+				{
+					if( isupper(chars[i]) && ! pRange->IsContainChar(tolower(chars[i])) )
+						chars.Push(tolower(chars[i]));
+
+					if( islower(chars[i]) && ! pRange->IsContainChar(toupper(chars[i])) )
+						chars.Push(toupper(chars[i]));
+				}
+			}
+
+			return pRange;
+		}
+	}
+
+	return GetStockElx(STOCKELX_EMPTY);
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildRecursive(int & flags)
+{
+	// skip '('
+	MoveNext();
+
+	if(curr == CHART_INFO(RCHART('?'), 1))
+	{
+		ElxInterface * pElx = 0;
+
+		// skip '?'
+		MoveNext();
+
+		int bNegative = 0;
+		CHART named_end = RCHART('>');
+
+		switch(curr.ch)
+		{
+		case RCHART('!'):
+			bNegative = 1;
+
+		case RCHART('='):
+			{
+				MoveNext(); // skip '!' or '='
+				pElx = Keep(new CAssertElx(BuildAlternative(flags & ~RIGHTTOLEFT), !bNegative));
+			}
+			break;
+
+		case RCHART('<'):
+			switch(next.ch)
+			{
+			case RCHART('!'):
+				bNegative = 1;
+
+			case RCHART('='):
+				MoveNext(); // skip '<'
+				MoveNext(); // skip '!' or '='
+				{
+					pElx = Keep(new CAssertElx(BuildAlternative(flags | RIGHTTOLEFT), !bNegative));
+				}
+				break;
+
+			default: // named group
+				break;
+			}
+			// break if assertion // else named
+			if(pElx != 0) break;
+
+		case RCHART('P'):
+			if(curr.ch == RCHART('P')) MoveNext(); // skip 'P'
+
+		case RCHART('\''):
+			if     (curr.ch == RCHART('<' )) named_end = RCHART('>' );
+			else if(curr.ch == RCHART('\'')) named_end = RCHART('\'');
+			MoveNext(); // skip '<' or '\''
+			{
+				// named number
+				int nThisBackref = m_nNextNamed ++;
+
+				CListElx    * pList  = (CListElx    *)Keep(new CListElx(flags & RIGHTTOLEFT));
+				CBracketElx * pleft  = (CBracketElx *)Keep(new CBracketElx(-1, flags & RIGHTTOLEFT ? 1 : 0));
+				CBracketElx * pright = (CBracketElx *)Keep(new CBracketElx(-1, flags & RIGHTTOLEFT ? 0 : 1));
+
+				// save name
+				CBufferT <CHART> & name = pleft->m_szNamed;
+				CBufferT <char> num;
+
+				while(curr.ch != RCHART(0) && curr.ch != named_end)
+				{
+					name.Append(curr.ch, 1);
+					num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+					MoveNext();
+				}
+				MoveNext(); // skip '>' or '\''
+
+				// check <num>
+				unsigned int number;
+				char * str = num.GetBuffer();
+
+				if( ReadDec(str, number) ? ( *str == '\0') : 0 )
+				{
+					pleft ->m_nnumber = number;
+					pright->m_nnumber = number;
+
+					name.Release();
+				}
+
+				// left, center, right
+				pList->m_elxlist.Push(pleft);
+				pList->m_elxlist.Push(BuildAlternative(flags));
+				pList->m_elxlist.Push(pright);
+
+				// for recursive
+				m_namedlist.Prepare(nThisBackref);
+				m_namedlist[nThisBackref] = pList;
+
+				pElx = pList;
+			}
+			break;
+
+		case RCHART('>'):
+			{
+				MoveNext(); // skip '>'
+				pElx = Keep(new CIndependentElx(BuildAlternative(flags)));
+			}
+			break;
+
+		case RCHART('R'):
+			MoveNext(); // skip 'R'
+			while(curr.ch != RCHART(0) && isspace(curr.ch)) MoveNext(); // skip space
+
+			if(curr.ch == RCHART('<') || curr.ch == RCHART('\''))
+			{
+				named_end = curr.ch == RCHART('<') ? RCHART('>') : RCHART('\'');
+				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(-3));
+
+				MoveNext(); // skip '<' or '\\'
+
+				// save name
+				CBufferT <CHART> & name = pDelegate->m_szNamed;
+				CBufferT <char> num;
+
+				while(curr.ch != RCHART(0) && curr.ch != named_end)
+				{
+					name.Append(curr.ch, 1);
+					num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+					MoveNext();
+				}
+				MoveNext(); // skip '>' or '\''
+
+				// check <num>
+				unsigned int number;
+				char * str = num.GetBuffer();
+
+				if( ReadDec(str, number) ? ( *str == '\0') : 0 )
+				{
+					pDelegate->m_ndata = number;
+					name.Release();
+				}
+
+				m_recursivelist.Push(pDelegate);
+				pElx = pDelegate;
+			}
+			else
+			{
+				CBufferT <char> rto;
+				while(curr.ch != RCHART(0) && curr.ch != RCHART(')'))
+				{
+					rto.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+					MoveNext();
+				}
+
+				unsigned int rtono = 0;
+				char * str = rto.GetBuffer();
+				ReadDec(str, rtono);
+
+				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(rtono));
+
+				m_recursivelist.Push(pDelegate);
+				pElx = pDelegate;
+			}
+			break;
+
+		case RCHART('('):
+			{
+				CConditionElx * pConditionElx = (CConditionElx *)Keep(new CConditionElx());
+
+				// condition
+				ElxInterface * & pCondition = pConditionElx->m_pelxask;
+
+				if(next == CHART_INFO(RCHART('?'), 1))
+				{
+					pCondition = BuildRecursive(flags);
+				}
+				else // named, assert or number
+				{
+					MoveNext(); // skip '('
+					int pos0 = curr.pos;
+
+					// save elx condition
+					pCondition = Keep(new CAssertElx(BuildAlternative(flags), 1));
+
+					// save name
+					pConditionElx->m_szNamed.Append(m_pattern.GetBuffer() + pos0, curr.pos - pos0, 1);
+
+					// save number
+					CBufferT <char> numstr;
+					while(pos0 < curr.pos)
+					{
+						CHART ch = m_pattern[pos0];
+						numstr.Append(((ch & (CHART)0xff) == ch) ? (char)ch : 0, 1);
+						pos0 ++;
+					}
+
+					unsigned int number;
+					char * str = numstr.GetBuffer();
+
+					// valid group number
+					if( ReadDec(str, number) ? ( *str == '\0') : 0 )
+					{
+						pConditionElx->m_nnumber = number;
+						pCondition = 0;
+					}
+					else // maybe elx, maybe named
+					{
+						pConditionElx->m_nnumber = -1;
+						m_namedconditionlist.Push(pConditionElx);
+					}
+
+					MoveNext(); // skip ')'
+				}
+
+				// alternative
+				{
+					int newflags = flags;
+
+					pConditionElx->m_pelxyes = BuildList(newflags);
+				}
+
+				if(curr.ch == RCHART('|'))
+				{
+					MoveNext(); // skip '|'
+
+					pConditionElx->m_pelxno = BuildAlternative(flags);
+				}
+				else
+				{
+					pConditionElx->m_pelxno = 0;
+				}
+
+				pElx = pConditionElx;
+			}
+			break;
+
+		default:
+			while(curr.ch != RCHART(0) && isspace(curr.ch)) MoveNext(); // skip space
+
+			if(curr.ch >= RCHART('0') && curr.ch <= RCHART('9')) // recursive (?1) => (?R1)
+			{
+				CBufferT <char> rto;
+				while(curr.ch != RCHART(0) && curr.ch != RCHART(')'))
+				{
+					rto.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+					MoveNext();
+				}
+
+				unsigned int rtono = 0;
+				char * str = rto.GetBuffer();
+				ReadDec(str, rtono);
+
+				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(rtono));
+
+				m_recursivelist.Push(pDelegate);
+				pElx = pDelegate;
+			}
+			else
+			{
+				// flag
+				int newflags = flags;
+				while(curr != CHART_INFO(0, 1) && curr.ch != RCHART(':') && curr.ch != RCHART(')') && curr != CHART_INFO(RCHART('('), 1))
+				{
+					int tochange = 0;
+
+					switch(curr.ch)
+					{
+					case RCHART('i'):
+					case RCHART('I'):
+						tochange = IGNORECASE;
+						break;
+
+					case RCHART('s'):
+					case RCHART('S'):
+						tochange = SINGLELINE;
+						break;
+
+					case RCHART('m'):
+					case RCHART('M'):
+						tochange = MULTILINE;
+						break;
+
+					case RCHART('g'):
+					case RCHART('G'):
+						tochange = GLOBAL;
+						break;
+
+					case RCHART('-'):
+						bNegative = 1;
+						break;
+					}
+
+					if(bNegative)
+						newflags &= ~tochange;
+					else
+						newflags |=  tochange;
+
+					// move to next char
+					MoveNext();
+				}
+
+				if(curr.ch == RCHART(':') || curr == CHART_INFO(RCHART('('), 1))
+				{
+					// skip ':'
+					if(curr.ch == RCHART(':')) MoveNext();
+
+					pElx = BuildAlternative(newflags);
+				}
+				else
+				{
+					// change parent flags
+					flags = newflags;
+
+					pElx = GetStockElx(STOCKELX_EMPTY);
+				}
+			}
+			break;
+		}
+
+		MoveNext(); // skip ')'
+
+		return pElx;
+	}
+	else
+	{
+		// group and number
+		CListElx * pList = (CListElx *)Keep(new CListElx(flags & RIGHTTOLEFT));
+		int nThisBackref = ++ m_nMaxNumber;
+
+		// left, center, right
+		pList->m_elxlist.Push(Keep(new CBracketElx(nThisBackref, flags & RIGHTTOLEFT ? 1 : 0)));
+		pList->m_elxlist.Push(BuildAlternative(flags));
+		pList->m_elxlist.Push(Keep(new CBracketElx(nThisBackref, flags & RIGHTTOLEFT ? 0 : 1)));
+
+		// for recursive
+		m_grouplist.Prepare(nThisBackref);
+		m_grouplist[nThisBackref] = pList;
+
+		// right
+		MoveNext(); // skip ')' 
+
+		return pList;
+	}
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildBoundary(int & flags)
+{
+	// char
+	CHART ch = curr.ch;
+
+	// skip
+	MoveNext();
+
+	switch(ch)
+	{
+	case RCHART('^'):
+		return Keep(new CBoundaryElxT <CHART> ((flags & MULTILINE) ? BOUNDARY_LINE_BEGIN : BOUNDARY_FILE_BEGIN));
+
+	case RCHART('$'):
+		return Keep(new CBoundaryElxT <CHART> ((flags & MULTILINE) ? BOUNDARY_LINE_END : BOUNDARY_FILE_END));
+
+	case RCHART('b'):
+		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_WORD_EDGE));
+
+	case RCHART('B'):
+		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_WORD_EDGE, 0));
+
+	case RCHART('A'):
+		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_BEGIN));
+
+	case RCHART('Z'):
+		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_END_N));
+
+	case RCHART('z'):
+		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_END));
+
+	case RCHART('G'):
+		if(flags & GLOBAL)
+			return Keep(new CGlobalElx());
+		else
+			return GetStockElx(STOCKELX_EMPTY);
+
+	default:
+		return GetStockElx(STOCKELX_EMPTY);
+	}
+}
+
+template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildBackref(int & flags)
+{
+	// skip '\\' or '\k' or '\g'
+	MoveNext();
+
+	if(curr.ch == RCHART('<') || curr.ch == RCHART('\''))
+	{
+		CHART named_end = curr.ch == RCHART('<') ? RCHART('>') : RCHART('\'');
+		CBackrefElxT <CHART> * pbackref = (CBackrefElxT <CHART> *)Keep(new CBackrefElxT <CHART> (-1, flags & RIGHTTOLEFT, flags & IGNORECASE));
+
+		MoveNext(); // skip '<' or '\''
+
+		// save name
+		CBufferT <CHART> & name = pbackref->m_szNamed;
+		CBufferT <char> num;
+
+		while(curr.ch != RCHART(0) && curr.ch != named_end)
+		{
+			name.Append(curr.ch, 1);
+			num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
+			MoveNext();
+		}
+		MoveNext(); // skip '>' or '\''
+
+		// check <num>
+		unsigned int number;
+		char * str = num.GetBuffer();
+
+		if( ReadDec(str, number) ? ( *str == '\0') : 0 )
+		{
+			pbackref->m_nnumber = number;
+			name.Release();
+		}
+		else
+		{
+			m_namedbackreflist.Push(pbackref);
+		}
+
+		return pbackref;
+	}
+	else
+	{
+		unsigned int nbackref = 0;
+
+		for(int i=0; i<3; i++)
+		{
+			if(curr.ch >= RCHART('0') && curr.ch <= RCHART('9'))
+				nbackref = nbackref * 10 + (curr.ch - RCHART('0'));
+			else
+				break;
+
+			MoveNext();
+		}
+
+		return Keep(new CBackrefElxT <CHART> (nbackref, flags & RIGHTTOLEFT, flags & IGNORECASE));
+	}
+}
+
+template <class CHART> int CBuilderT <CHART> :: ReadDec(char * & str, unsigned int & dec)
+{
+	int s = 0;
+	while(str[s] != 0 && isspace(str[s])) s++;
+
+	if(str[s] < '0' || str[s] > '9') return 0;
+
+	dec = 0;
+	unsigned int i;
+
+	for(i = s; i<sizeof(CHART)*3 + s; i++)
+	{
+		if(str[i] >= '0' && str[i] <= '9')
+			dec = dec * 10 + (str[i] - '0');
+		else
+			break;
+	}
+
+	while(str[i] != 0 && isspace(str[i])) i++;
+	str += i;
+
+	return 1;
+}
+
+//
+// Regexp
+//
+template <class CHART> class CRegexpT
+{
+public:
+	CRegexpT(const CHART * pattern = 0, int flags = 0);
+	CRegexpT(const CHART * pattern, int length, int flags);
+	void Compile(const CHART * pattern, int flags = 0);
+	void Compile(const CHART * pattern, int length, int flags);
+
+public:
+	MatchResult MatchExact(const CHART * tstring, CContext * pContext = 0) const;
+	MatchResult MatchExact(const CHART * tstring, int length, CContext * pContext = 0) const;
+	MatchResult Match(const CHART * tstring, int start = -1, CContext * pContext = 0) const;
+	MatchResult Match(const CHART * tstring, int length, int start, CContext * pContext = 0) const;
+	MatchResult Match(CContext * pContext) const;
+	CContext * PrepareMatch(const CHART * tstring, int start = -1, CContext * pContext = 0) const;
+	CContext * PrepareMatch(const CHART * tstring, int length, int start, CContext * pContext = 0) const;
+	CHART * Replace(const CHART * tstring, const CHART * replaceto, int start = -1, int ntimes = -1, MatchResult * result = 0, CContext * pContext = 0) const;
+	CHART * Replace(const CHART * tstring, int string_length, const CHART * replaceto, int to_length, int & result_length, int start = -1, int ntimes = -1, MatchResult * result = 0, CContext * pContext = 0) const;
+	int GetNamedGroupNumber(const CHART * group_name) const;
+
+public:
+	static void ReleaseString (CHART    * tstring );
+	static void ReleaseContext(CContext * pContext);
+
+public:
+	CBuilderT <CHART> m_builder;
+};
+
+//
+// Implementation
+//
+template <class CHART> CRegexpT <CHART> :: CRegexpT(const CHART * pattern, int flags)
+{
+	Compile(pattern, CBufferRefT<CHART>(pattern).GetSize(), flags);
+}
+
+template <class CHART> CRegexpT <CHART> :: CRegexpT(const CHART * pattern, int length, int flags)
+{
+	Compile(pattern, length, flags);
+}
+
+template <class CHART> inline void CRegexpT <CHART> :: Compile(const CHART * pattern, int flags)
+{
+	Compile(pattern, CBufferRefT<CHART>(pattern).GetSize(), flags);
+}
+
+template <class CHART> void CRegexpT <CHART> :: Compile(const CHART * pattern, int length, int flags)
+{
+	m_builder.Clear();
+	if(pattern != 0) m_builder.Build(CBufferRefT<CHART>(pattern, length), flags);
+}
+
+template <class CHART> inline MatchResult CRegexpT <CHART> :: MatchExact(const CHART * tstring, CContext * pContext) const
+{
+	return MatchExact(tstring, CBufferRefT<CHART>(tstring).GetSize(), pContext);
+}
+
+template <class CHART> MatchResult CRegexpT <CHART> :: MatchExact(const CHART * tstring, int length, CContext * pContext) const
+{
+	if(m_builder.m_pTopElx == 0)
+		return 0;
+
+	// info
+	int endpos = 0;
+
+	CContext context;
+	if(pContext == 0) pContext = &context;
+
+	pContext->m_stack.Restore(0);
+	pContext->m_capturestack.Restore(0);
+	pContext->m_captureindex.Restore(0);
+
+	pContext->m_nParenZindex  = 0;
+	pContext->m_nLastBeginPos = -1;
+	pContext->m_pMatchString  = (void*)tstring;
+	pContext->m_pMatchStringLength = length;
+
+	if(m_builder.m_nFlags & RIGHTTOLEFT)
+	{
+		pContext->m_nBeginPos   = length;
+		pContext->m_nCurrentPos = length;
+		endpos = 0;
+	}
+	else
+	{
+		pContext->m_nBeginPos   = 0;
+		pContext->m_nCurrentPos = 0;
+		endpos = length;
+	}
+
+	pContext->m_captureindex.Prepare(m_builder.m_nMaxNumber, -1);
+	pContext->m_captureindex[0] = 0;
+	pContext->m_capturestack.Push(0);
+	pContext->m_capturestack.Push(pContext->m_nCurrentPos);
+	pContext->m_capturestack.Push(-1);
+	pContext->m_capturestack.Push(-1);
+
+	// match
+	if( ! m_builder.m_pTopElx->Match( pContext ) )
+		return 0;
+	else
+	{
+		while( pContext->m_nCurrentPos != endpos )
+		{
+			if( ! m_builder.m_pTopElx->MatchNext( pContext ) )
+				return 0;
+			else
+			{
+				if( pContext->m_nLastBeginPos == pContext->m_nBeginPos && pContext->m_nBeginPos == pContext->m_nCurrentPos )
+					return 0;
+				else
+					pContext->m_nLastBeginPos = pContext->m_nCurrentPos;
+			}
+		}
+
+		// end pos
+		pContext->m_capturestack[2] = pContext->m_nCurrentPos;
+
+		return MatchResult( pContext, m_builder.m_nMaxNumber );
+	}
+}
+
+template <class CHART> MatchResult CRegexpT <CHART> :: Match(const CHART * tstring, int start, CContext * pContext) const
+{
+	return Match(tstring, CBufferRefT<CHART>(tstring).GetSize(), start, pContext);
+}
+
+template <class CHART> MatchResult CRegexpT <CHART> :: Match(const CHART * tstring, int length, int start, CContext * pContext) const
+{
+	if(m_builder.m_pTopElx == 0)
+		return 0;
+
+	CContext context;
+	if(pContext == 0) pContext = &context;
+
+	pContext->m_nParenZindex  =  0;
+	pContext->m_nLastBeginPos = -1;
+	pContext->m_pMatchString  = (void*)tstring;
+	pContext->m_pMatchStringLength = length;
+
+	if(start < 0)
+	{
+		if(m_builder.m_nFlags & RIGHTTOLEFT)
+		{
+			pContext->m_nBeginPos   = length;
+			pContext->m_nCurrentPos = length;
+		}
+		else
+		{
+			pContext->m_nBeginPos   = 0;
+			pContext->m_nCurrentPos = 0;
+		}
+	}
+	else
+	{
+		pContext->m_nBeginPos   = start;
+		pContext->m_nCurrentPos = start;
+	}
+
+	return Match( pContext );
+}
+
+template <class CHART> MatchResult CRegexpT <CHART> :: Match(CContext * pContext) const
+{
+	if(m_builder.m_pTopElx == 0)
+		return 0;
+
+	int endpos, delta;
+
+	if(m_builder.m_nFlags & RIGHTTOLEFT)
+	{
+		endpos = -1;
+		delta  = -1;
+	}
+	else
+	{
+		endpos = pContext->m_pMatchStringLength + 1;
+		delta  = 1;
+	}
+
+	while(pContext->m_nCurrentPos != endpos)
+	{
+		pContext->m_captureindex.Restore(0);
+		pContext->m_stack       .Restore(0);
+		pContext->m_capturestack.Restore(0);
+
+		pContext->m_captureindex.Prepare(m_builder.m_nMaxNumber, -1);
+		pContext->m_captureindex[0] = 0;
+		pContext->m_capturestack.Push(0);
+		pContext->m_capturestack.Push(pContext->m_nCurrentPos);
+		pContext->m_capturestack.Push(-1);
+		pContext->m_capturestack.Push(-1);
+
+		if( m_builder.m_pTopElx->Match( pContext ) )
+		{
+			// zero width
+			if( pContext->m_nLastBeginPos == pContext->m_nBeginPos && pContext->m_nBeginPos == pContext->m_nCurrentPos )
+			{
+				pContext->m_nCurrentPos += delta;
+				continue;
+			}
+
+			// save pos
+			pContext->m_nLastBeginPos   = pContext->m_nBeginPos;
+			pContext->m_nBeginPos       = pContext->m_nCurrentPos;
+			pContext->m_capturestack[2] = pContext->m_nCurrentPos;
+
+			// return
+			return MatchResult( pContext, m_builder.m_nMaxNumber );
+		}
+		else
+		{
+			pContext->m_nCurrentPos += delta;
+		}
+	}
+
+	return 0;
+}
+
+template <class CHART> inline CContext * CRegexpT <CHART> :: PrepareMatch(const CHART * tstring, int start, CContext * pContext) const
+{
+	return PrepareMatch(tstring, CBufferRefT<CHART>(tstring).GetSize(), start, pContext);
+}
+
+template <class CHART> CContext * CRegexpT <CHART> :: PrepareMatch(const CHART * tstring, int length, int start, CContext * pContext) const
+{
+	if(m_builder.m_pTopElx == 0)
+		return 0;
+
+	if(pContext == 0) pContext = new CContext();
+
+	pContext->m_nParenZindex  =  0;
+	pContext->m_nLastBeginPos = -1;
+	pContext->m_pMatchString  = (void*)tstring;
+	pContext->m_pMatchStringLength = length;
+
+	if(start < 0)
+	{
+		if(m_builder.m_nFlags & RIGHTTOLEFT)
+		{
+			pContext->m_nBeginPos   = length;
+			pContext->m_nCurrentPos = length;
+		}
+		else
+		{
+			pContext->m_nBeginPos   = 0;
+			pContext->m_nCurrentPos = 0;
+		}
+	}
+	else
+	{
+		pContext->m_nBeginPos   = start;
+		pContext->m_nCurrentPos = start;
+	}
+
+	return pContext;
+}
+
+template <class CHART> inline int CRegexpT <CHART> :: GetNamedGroupNumber(const CHART * group_name) const
+{
+	return m_builder.GetNamedNumber(group_name);
+}
+
+template <class CHART> CHART * CRegexpT <CHART> :: Replace(const CHART * tstring, const CHART * replaceto, int start, int ntimes, MatchResult * result, CContext * pContext) const
+{
+	int result_length = 0;
+	return Replace(tstring, CBufferRefT<CHART>(tstring).GetSize(), replaceto, CBufferRefT<CHART>(replaceto).GetSize(), result_length, start, ntimes, result, pContext);
+}
+
+template <class CHART> CHART * CRegexpT <CHART> :: Replace(const CHART * tstring, int string_length, const CHART * replaceto, int to_length, int & result_length, int start, int ntimes, MatchResult * remote_result, CContext * oContext) const
+{
+	if(m_builder.m_pTopElx == 0) return 0;
+
+	// --- compile replace to ---
+
+	CBufferT <int> compiledto;
+
+	static const CHART rtoptn[] = { RCHART('\\'), RCHART('$' ), RCHART('('), RCHART('?'), RCHART(':'), RCHART('[' ), RCHART('$' ), RCHART('&' ), RCHART('`' ), RCHART('\''), RCHART('+'), RCHART('_' ), RCHART('\\'), RCHART('d'), RCHART(']'), RCHART('|'), RCHART('\\'), RCHART('{'), RCHART('.'), RCHART('*'), RCHART('?'), RCHART('\\'), RCHART('}'), RCHART(')' ), RCHART('\0') };
+	static CRegexpT <CHART> rtoreg(rtoptn);
+
+	MatchResult local_result(0), * result = remote_result ? remote_result : & local_result;
+
+	// prepare
+	CContext * pContext = PrepareMatch(replaceto, to_length, -1, oContext);
+	int lastIndex = 0, nmatch = 0;
+
+	while( ((*result) = rtoreg.Match(pContext)).IsMatched() )
+	{
+		int delta = result->GetStart() - lastIndex;
+		if( delta > 0 )
+		{
+			compiledto.Push(lastIndex);
+			compiledto.Push(delta);
+		}
+
+		lastIndex = result->GetStart();
+		delta     = 2;
+
+		switch(replaceto[lastIndex + 1])
+		{
+		case RCHART('$'):
+			compiledto.Push(lastIndex);
+			compiledto.Push(1);
+			break;
+
+		case RCHART('&'):
+		case RCHART('`'):
+		case RCHART('\''):
+		case RCHART('+'):
+		case RCHART('_'):
+			compiledto.Push(-1);
+			compiledto.Push((int)replaceto[lastIndex + 1]);
+
+		case RCHART('{'):
+			delta  = result->GetEnd() - result->GetStart();
+			nmatch = m_builder.GetNamedNumber(CBufferRefT <CHART> (replaceto + (lastIndex + 2), delta - 3));
+
+			if(nmatch > 0 && nmatch <= m_builder.m_nMaxNumber)
+			{
+				compiledto.Push(-2);
+				compiledto.Push(nmatch);
+			}
+			else
+			{
+				compiledto.Push(lastIndex);
+				compiledto.Push(delta);
+			}
+			break;
+
+		default:
+			nmatch = 0;
+			for(delta=1; delta<=3; delta++)
+			{
+				CHART ch = replaceto[lastIndex + delta];
+
+				if(ch < RCHART('0') || ch > RCHART('9'))
+					break;
+
+				nmatch = nmatch * 10 + (ch - RCHART('0'));
+			}
+
+			if(nmatch > m_builder.m_nMaxNumber)
+			{
+				while(nmatch > m_builder.m_nMaxNumber)
+				{
+					nmatch /= 10;
+					delta --;
+				}
+
+				if(nmatch == 0)
+				{
+					delta = 1;
+				}
+			}
+
+			if(delta == 1)
+			{
+				compiledto.Push(lastIndex);
+				compiledto.Push(1);
+			}
+			else
+			{
+				compiledto.Push(-2);
+				compiledto.Push(nmatch);
+			}
+			break;
+		}
+
+		lastIndex += delta;
+	}
+
+	if(lastIndex < to_length)
+	{
+		compiledto.Push(lastIndex);
+		compiledto.Push(to_length - lastIndex);
+	}
+
+	int rightleft = m_builder.m_nFlags & RIGHTTOLEFT;
+
+	int tb = rightleft ? compiledto.GetSize() - 2 : 0;
+	int te = rightleft ? -2 : compiledto.GetSize();
+	int ts = rightleft ? -2 : 2;
+
+	// --- compile complete ---
+
+	int beginpos  = rightleft ? string_length : 0;
+	int endpos    = rightleft ? 0 : string_length;
+
+	int toIndex0  = 0;
+	int toIndex1  = 0;
+	int i, ntime;
+
+	CBufferT <const CHART *> buffer;
+
+	// prepare
+	pContext  = PrepareMatch(tstring, string_length, start, pContext);
+	lastIndex = beginpos;
+
+	// Match
+	for(ntime = 0; ntimes < 0 || ntime < ntimes; ntime ++)
+	{
+		(*result) = Match(pContext);
+
+		if( ! result->IsMatched() )
+			break;
+
+		// before
+		if( rightleft )
+		{
+			int distance = lastIndex - result->GetEnd();
+			if( distance )
+			{
+				buffer.Push(tstring + result->GetEnd());
+				buffer.Push((const CHART *)distance);
+
+				toIndex1 -= distance;
+			}
+			lastIndex = result->GetStart();
+		}
+		else
+		{
+			int distance = result->GetStart() - lastIndex;
+			if( distance )
+			{
+				buffer.Push(tstring + lastIndex);
+				buffer.Push((const CHART *)distance);
+
+				toIndex1 += distance;
+			}
+			lastIndex = result->GetEnd();
+		}
+
+		toIndex0 = toIndex1;
+
+		// middle
+		for(i=tb; i!=te; i+=ts)
+		{
+			int off = compiledto[i];
+			int len = compiledto[i + 1];
+
+			const CHART * sub = replaceto + off;
+
+			if( off == -1 )
+			{
+				switch(RCHART(len))
+				{
+				case RCHART('&'):
+					sub = tstring + result->GetStart();
+					len = result->GetEnd() - result->GetStart();
+					break;
+
+				case RCHART('`'):
+					sub = tstring;
+					len = result->GetStart();
+					break;
+
+				case RCHART('\''):
+					sub = tstring + result->GetEnd();
+					len = string_length - result->GetEnd();
+					break;
+
+				case RCHART('+'):
+					for(nmatch = result->MaxGroupNumber(); nmatch >= 0; nmatch --)
+					{
+						if(result->GetGroupStart(nmatch) >= 0) break;
+					}
+					sub = tstring + result->GetGroupStart(nmatch);
+					len = result->GetGroupEnd(nmatch) - result->GetGroupStart(nmatch);
+					break;
+
+				case RCHART('_'):
+					sub = tstring;
+					len = string_length;
+					break;
+				}
+			}
+			else if( off == -2 )
+			{
+				sub = tstring + result->GetGroupStart(len);
+				len = result->GetGroupEnd(len) - result->GetGroupStart(len);
+			}
+
+			buffer.Push(sub);
+			buffer.Push((const CHART *)len);
+
+			toIndex1 += rightleft ? (-len) : len;
+		}
+	}
+
+	// after
+	if(rightleft)
+	{
+		if(endpos < lastIndex)
+		{
+			buffer.Push(tstring + endpos);
+			buffer.Push((const CHART *)(lastIndex - endpos));
+		}
+	}
+	else
+	{
+		if(lastIndex < endpos)
+		{
+			buffer.Push(tstring + lastIndex);
+			buffer.Push((const CHART *)(endpos - lastIndex));
+		}
+	}
+
+	if(oContext == 0) ReleaseContext(pContext);
+
+	// join string
+	result_length = 0;
+	for(i=0; i<buffer.GetSize(); i+=2)
+	{
+		result_length += (int)buffer[i+1];
+	}
+
+	CBufferT <CHART> result_string;
+	result_string.Prepare(result_length);
+	result_string.Restore(0);
+
+	if(rightleft)
+	{
+		for(i=buffer.GetSize()-2; i>=0; i-=2)
+		{
+			result_string.Append(buffer[i], (int)buffer[i+1]);
+		}
+	}
+	else
+	{
+		for(i=0; i<buffer.GetSize(); i+=2)
+		{
+			result_string.Append(buffer[i], (int)buffer[i+1]);
+		}
+	}
+
+	result_string.Append(0);
+
+	result->m_result.Append(result_length, 3);
+	result->m_result.Append(ntime);
+
+	if(rightleft)
+	{
+		result->m_result.Append(result_length - toIndex1);
+		result->m_result.Append(result_length - toIndex0);
+	}
+	else
+	{
+		result->m_result.Append(toIndex0);
+		result->m_result.Append(toIndex1);
+	}
+
+	return result_string.Detach();
+}
+
+template <class CHART> inline void CRegexpT <CHART> :: ReleaseString(CHART * tstring)
+{
+	if(tstring != 0) free(tstring);
+}
+
+template <class CHART> inline void CRegexpT <CHART> :: ReleaseContext(CContext * pContext)
+{
+	if(pContext != 0) delete pContext;
+}
+
+//
+// All implementations
+//
+template <int x> CAlternativeElxT <x> :: CAlternativeElxT()
+{
+}
+
+template <int x> int CAlternativeElxT <x> :: Match(CContext * pContext) const
+{
+	if(m_elxlist.GetSize() == 0)
+		return 1;
+
+	// try all
+	for(int n = 0; n < m_elxlist.GetSize(); n++)
+	{
+		if(m_elxlist[n]->Match(pContext))
+		{
+			pContext->m_stack.Push(n);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+template <int x> int CAlternativeElxT <x> :: MatchNext(CContext * pContext) const
+{
+	if(m_elxlist.GetSize() == 0)
+		return 0;
+
+	int n = 0;
+
+	// recall prev
+	pContext->m_stack.Pop(n);
+
+	// prev
+	if(m_elxlist[n]->MatchNext(pContext))
+	{
+		pContext->m_stack.Push(n);
+		return 1;
+	}
+	else
+	{
+		// try rest
+		for(n++; n < m_elxlist.GetSize(); n++)
+		{
+			if(m_elxlist[n]->Match(pContext))
+			{
+				pContext->m_stack.Push(n);
+				return 1;
+			}
+		}
+
+		return 0;
+	}
+}
+
+// assertx.cpp: implementation of the CAssertElx class.
+//
+template <int x> CAssertElxT <x> :: CAssertElxT(ElxInterface * pelx, int byes)
+{
+	m_pelx = pelx;
+	m_byes = byes;
+}
+
+template <int x> int CAssertElxT <x> :: Match(CContext * pContext) const
+{
+	int nbegin = pContext->m_nCurrentPos;
+	int nsize  = pContext->m_stack.GetSize();
+	int ncsize = pContext->m_capturestack.GetSize();
+	int bsucc;
+
+	// match
+	if( m_byes )
+		bsucc =   m_pelx->Match(pContext);
+	else
+		bsucc = ! m_pelx->Match(pContext);
+
+	// status
+	pContext->m_stack.Restore(nsize);
+	pContext->m_nCurrentPos = nbegin;
+
+	if( bsucc )
+		pContext->m_stack.Push(ncsize);
+	else
+		pContext->m_capturestack.Restore(ncsize);
+
+	return bsucc;
+}
+
+template <int x> int CAssertElxT <x> :: MatchNext(CContext * pContext) const
+{
+	int ncsize = 0;
+
+	pContext->m_stack.Pop(ncsize);
+	pContext->m_capturestack.Restore(ncsize);
+
+	return 0;
+}
+
+// emptyelx.cpp: implementation of the CEmptyElx class.
+//
+template <int x> CEmptyElxT <x> :: CEmptyElxT()
+{
+}
+
+template <int x> int CEmptyElxT <x> :: Match(CContext *) const
+{
+	return 1;
+}
+
+template <int x> int CEmptyElxT <x> :: MatchNext(CContext *) const
+{
+	return 0;
+}
+
+// globalx.cpp: implementation of the CGlobalElx class.
+//
+template <int x> CGlobalElxT <x> ::CGlobalElxT()
+{
+}
+
+template <int x> int CGlobalElxT <x> :: Match(CContext * pContext) const
+{
+	return pContext->m_nCurrentPos == pContext->m_nBeginPos;
+}
+
+template <int x> int CGlobalElxT <x> :: MatchNext(CContext *) const
+{
+	return 0;
+}
+
+// greedelx.cpp: implementation of the CGreedyElx class.
+//
+template <int x> CGreedyElxT <x> :: CGreedyElxT(ElxInterface * pelx, int nmin, int nmax) : CRepeatElxT <x> (pelx, nmin)
+{
+	m_nvart = nmax - nmin;
+}
+
+template <int x> int CGreedyElxT <x> :: Match(CContext * pContext) const
+{
+	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
+		return 0;
+
+	while( ! MatchVart(pContext) )
+	{
+		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+			return 0;
+	}
+
+	return 1;
+}
+
+template <int x> int CGreedyElxT <x> :: MatchNext(CContext * pContext) const
+{
+	if( MatchNextVart(pContext) )
+		return 1;
+
+	if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+		return 0;
+
+	while( ! MatchVart(pContext) )
+	{
+		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+			return 0;
+	}
+
+	return 1;
+}
+
+template <int x> int CGreedyElxT <x> :: MatchVart(CContext * pContext) const
+{
+	int n      = 0;
+	int nbegin = pContext->m_nCurrentPos;
+
+	while(n < m_nvart && CRepeatElxT <x> :: m_pelx->Match(pContext))
+	{
+		while(pContext->m_nCurrentPos == nbegin)
+		{
+			if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) ) break;
+		}
+
+		if(pContext->m_nCurrentPos == nbegin) break;
+
+		n ++;
+		nbegin = pContext->m_nCurrentPos;
+	}
+
+	pContext->m_stack.Push(n);
+
+	return 1;
+}
+
+template <int x> int CGreedyElxT <x> :: MatchNextVart(CContext * pContext) const
+{
+	int n = 0;
+	pContext->m_stack.Pop(n);
+
+	if(n == 0) return 0;
+
+	if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) )
+	{
+		n --;
+	}
+
+	pContext->m_stack.Push(n);
+
+	return 1;
+}
+
+// indepelx.cpp: implementation of the CIndependentElx class.
+//
+template <int x> CIndependentElxT <x> :: CIndependentElxT(ElxInterface * pelx)
+{
+	m_pelx = pelx;
+}
+
+template <int x> int CIndependentElxT <x> :: Match(CContext * pContext) const
+{
+	int nbegin = pContext->m_nCurrentPos;
+	int nsize  = pContext->m_stack.GetSize();
+	int ncsize = pContext->m_capturestack.GetSize();
+
+	// match
+	int bsucc  = m_pelx->Match(pContext);
+
+	// status
+	pContext->m_stack.Restore(nsize);
+
+	if( bsucc )
+	{
+		pContext->m_stack.Push(nbegin);
+		pContext->m_stack.Push(ncsize);
+	}
+
+	return bsucc;
+}
+
+template <int x> int CIndependentElxT <x> :: MatchNext(CContext * pContext) const
+{
+	int nbegin = 0, ncsize = 0;
+
+	pContext->m_stack.Pop(ncsize);
+	pContext->m_stack.Pop(nbegin);
+
+	pContext->m_capturestack.Restore(ncsize);
+	pContext->m_nCurrentPos = nbegin;
+
+	return 0;
+}
+
+// listelx.cpp: implementation of the CListElx class.
+//
+template <int x> CListElxT <x> :: CListElxT(int brightleft)
+{
+	m_brightleft = brightleft;
+}
+
+template <int x> int CListElxT <x> :: Match(CContext * pContext) const
+{
+	if(m_elxlist.GetSize() == 0)
+		return 1;
+
+	// prepare
+	int bol = m_brightleft ? m_elxlist.GetSize() : -1;
+	int stp = m_brightleft ? -1 : 1;
+	int eol = m_brightleft ? -1 : m_elxlist.GetSize();
+
+	// from first
+	int n = bol + stp;
+
+	// match all
+	while(n != eol)
+	{
+		if(m_elxlist[n]->Match(pContext))
+		{
+			n += stp;
+		}
+		else
+		{
+			n -= stp;
+
+			while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
+				n -= stp;
+
+			if(n != bol)
+				n += stp;
+			else
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+template <int x> int CListElxT <x> :: MatchNext(CContext * pContext) const
+{
+	if(m_elxlist.GetSize() == 0)
+		return 0;
+
+	// prepare
+	int bol = m_brightleft ? m_elxlist.GetSize() : -1;
+	int stp = m_brightleft ? -1 : 1;
+	int eol = m_brightleft ? -1 : m_elxlist.GetSize();
+
+	// from last
+	int n = eol - stp;
+
+	while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
+		n -= stp;
+
+	if(n != bol)
+		n += stp;
+	else
+		return 0;
+
+	// match rest
+	while(n != eol)
+	{
+		if(m_elxlist[n]->Match(pContext))
+		{
+			n += stp;
+		}
+		else
+		{
+			n -= stp;
+
+			while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
+				n -= stp;
+
+			if(n != bol)
+				n += stp;
+			else
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+// mresult.cpp: implementation of the MatchResult class.
+//
+template <int x> MatchResultT <x> :: MatchResultT(CContext * pContext, int nMaxNumber)
+{
+	if(pContext != 0)
+	{
+		m_result.Prepare(nMaxNumber * 2 + 3, -1);
+
+		// matched
+		m_result[0] = 1;
+		m_result[1] = nMaxNumber;
+
+		for(int n = 0; n <= nMaxNumber; n++)
+		{
+			int index = pContext->m_captureindex[n];
+			if( index < 0 ) continue;
+
+			// check enclosed
+			int pos1 = pContext->m_capturestack[index + 1];
+			int pos2 = pContext->m_capturestack[index + 2];
+
+			// info
+			m_result[n*2 + 2] = pos1 < pos2 ? pos1 : pos2;
+			m_result[n*2 + 3] = pos1 < pos2 ? pos2 : pos1;
+		}
+	}
+}
+
+template <int x> inline int MatchResultT <x> :: IsMatched() const
+{
+	return m_result.At(0, 0);
+}
+
+template <int x> inline int MatchResultT <x> :: MaxGroupNumber() const
+{
+	return m_result.At(1, 0);
+}
+
+template <int x> inline int MatchResultT <x> :: GetStart() const
+{
+	return m_result.At(2, -1);
+}
+
+template <int x> inline int MatchResultT <x> :: GetEnd() const
+{
+	return m_result.At(3, -1);
+}
+
+template <int x> inline int MatchResultT <x> :: GetGroupStart(int nGroupNumber) const
+{
+	return m_result.At(2 + nGroupNumber * 2, -1);
+}
+
+template <int x> inline int MatchResultT <x> :: GetGroupEnd(int nGroupNumber) const
+{
+	return m_result.At(2 + nGroupNumber * 2 + 1, -1);
+}
+
+template <int x> MatchResultT <x> & MatchResultT <x> :: operator = (const MatchResultT <x> & result)
+{
+	m_result.Restore(0);
+	if(result.m_result.GetSize() > 0) m_result.Append(result.m_result.GetBuffer(), result.m_result.GetSize());
+
+	return *this;
+}
+
+// posselx.cpp: implementation of the CPossessiveElx class.
+//
+template <int x> CPossessiveElxT <x> :: CPossessiveElxT(ElxInterface * pelx, int nmin, int nmax) : CGreedyElxT <x> (pelx, nmin, nmax)
+{
+}
+
+template <int x> int CPossessiveElxT <x> :: Match(CContext * pContext) const
+{
+	int nbegin = pContext->m_nCurrentPos;
+	int nsize  = pContext->m_stack.GetSize();
+	int ncsize = pContext->m_capturestack.GetSize();
+	int bsucc  = 1;
+
+	// match
+	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
+	{
+		bsucc = 0;
+	}
+	else
+	{
+		while( ! CGreedyElxT <x> :: MatchVart(pContext) )
+		{
+			if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+			{
+				bsucc = 0;
+				break;
+			}
+		}
+	}
+
+	// status
+	pContext->m_stack.Restore(nsize);
+
+	if( bsucc )
+	{
+		pContext->m_stack.Push(nbegin);
+		pContext->m_stack.Push(ncsize);
+	}
+
+	return bsucc;
+}
+
+template <int x> int CPossessiveElxT <x> :: MatchNext(CContext * pContext) const
+{
+	int nbegin = 0, ncsize = 0;
+
+	pContext->m_stack.Pop(ncsize);
+	pContext->m_stack.Pop(nbegin);
+
+	pContext->m_capturestack.Restore(ncsize);
+	pContext->m_nCurrentPos = nbegin;
+
+	return 0;
+}
+
+// reluctx.cpp: implementation of the CReluctantElx class.
+//
+template <int x> CReluctantElxT <x> :: CReluctantElxT(ElxInterface * pelx, int nmin, int nmax) : CRepeatElxT <x> (pelx, nmin)
+{
+	m_nvart = nmax - nmin;
+}
+
+template <int x> int CReluctantElxT <x> :: Match(CContext * pContext) const
+{
+	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
+		return 0;
+
+	while( ! MatchVart(pContext) )
+	{
+		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+			return 0;
+	}
+
+	return 1;
+}
+
+template <int x> int CReluctantElxT <x> :: MatchNext(CContext * pContext) const
+{
+	if( MatchNextVart(pContext) )
+		return 1;
+
+	if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+		return 0;
+
+	while( ! MatchVart(pContext) )
+	{
+		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
+			return 0;
+	}
+
+	return 1;
+}
+
+template <int x> int CReluctantElxT <x> :: MatchVart(CContext * pContext) const
+{
+	pContext->m_stack.Push(0);
+
+	return 1;
+}
+
+template <int x> int CReluctantElxT <x> :: MatchNextVart(CContext * pContext) const
+{
+	int n = 0, nbegin = pContext->m_nCurrentPos;
+
+	pContext->m_stack.Pop(n);
+
+	if(n < m_nvart && CRepeatElxT <x> :: m_pelx->Match(pContext))
+	{
+		while(pContext->m_nCurrentPos == nbegin)
+		{
+			if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) ) break;
+		}
+
+		if(pContext->m_nCurrentPos != nbegin)
+		{
+			n ++;
+
+			pContext->m_stack.Push(nbegin);
+			pContext->m_stack.Push(n);
+
+			return 1;
+		}
+	}
+
+	while(n > 0)
+	{
+		pContext->m_stack.Pop(nbegin);
+
+		while( CRepeatElxT <x> :: m_pelx->MatchNext(pContext) )
+		{
+			if(pContext->m_nCurrentPos != nbegin)
+			{
+				pContext->m_stack.Push(nbegin);
+				pContext->m_stack.Push(n);
+
+				return 1;
+			}
+		}
+
+		n --;
+	}
+
+	return 0;
+}
+
+// repeatx.cpp: implementation of the CRepeatElx class.
+//
+template <int x> CRepeatElxT <x> :: CRepeatElxT(ElxInterface * pelx, int ntimes)
+{
+	m_pelx   = pelx;
+	m_nfixed = ntimes;
+}
+
+template <int x> int CRepeatElxT <x> :: Match(CContext * pContext) const
+{
+	return MatchFixed(pContext);
+}
+
+template <int x> int CRepeatElxT <x> :: MatchNext(CContext * pContext) const
+{
+	return MatchNextFixed(pContext);
+}
+
+template <int x> int CRepeatElxT <x> :: MatchFixed(CContext * pContext) const
+{
+	if(m_nfixed == 0)
+		return 1;
+
+	int n = 0;
+
+	while(n < m_nfixed)
+	{
+		if(m_pelx->Match(pContext))
+		{
+			n ++;
+		}
+		else
+		{
+			n --;
+
+			while(n >= 0 && ! m_pelx->MatchNext(pContext))
+				n --;
+
+			if(n >= 0)
+				n ++;
+			else
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+template <int x> int CRepeatElxT <x> :: MatchNextFixed(CContext * pContext) const
+{
+	if(m_nfixed == 0)
+		return 0;
+
+	// from last
+	int n = m_nfixed - 1;
+
+	while(n >= 0 && ! m_pelx->MatchNext(pContext))
+		n --;
+
+	if(n >= 0)
+		n ++;
+	else
+		return 0;
+
+	// match rest
+	while(n < m_nfixed)
+	{
+		if(m_pelx->Match(pContext))
+		{
+			n ++;
+		}
+		else
+		{
+			n --;
+
+			while(n >= 0 && ! m_pelx->MatchNext(pContext))
+				n --;
+
+			if(n >= 0)
+				n ++;
+			else
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+// Regexp
+typedef CRegexpT <char> CRegexpA;
+typedef CRegexpT <unsigned short> CRegexpW;
+
+#if defined(_UNICODE) || defined(UNICODE)
+	typedef CRegexpW CRegexp;
+#else
+	typedef CRegexpA CRegexp;
+#endif
+
+#endif//__DEELX_REGEXP__H__
--- src/OSspecific/MSwindows/fileStat.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/fileStat.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,202 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Description
+    Wrapper for stat() system call.
+
+\*---------------------------------------------------------------------------*/
+
+#include "fileStat.H"
+#include "IOstreams.H"
+#include "timer.H"
+
+#include <unistd.h>
+
+
+
+#undef major
+#undef minor
+#undef makedev
+
+# define major(dev) ((int)(((dev) >> 8) & 0xff))
+# define minor(dev) ((int)((dev) & 0xff))
+# define makedev(major, minor) ((((unsigned int) (major)) << 8) \
+				| ((unsigned int) (minor)))
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+// Construct null
+fileStat::fileStat()
+:
+    isValid_(false)
+{}
+
+
+// Construct from components
+fileStat::fileStat(const fileName& fName, const unsigned int maxTime)
+{
+    // Work on volatile
+    volatile bool locIsValid = false;
+
+    timer myTimer(maxTime);
+
+    if (!timedOut(myTimer))
+    {
+        if (::stat(fName.c_str(), &status_) != 0)
+        {
+            locIsValid = false;
+        }
+        else
+        {
+            locIsValid = true;
+        }
+    }
+
+    // Copy into (non-volatile, possible register based) member var
+    isValid_ = locIsValid;
+}
+
+
+// Construct from Istream.
+fileStat::fileStat(Istream& is)
+{
+    is >> *this;
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+// compare two fileStates for same device
+bool fileStat::sameDevice(const fileStat& stat2) const
+{
+    return 
+        isValid_
+     && (
+            major(status_.st_dev) == major(stat2.status().st_dev)
+         && minor(status_.st_dev) == minor(stat2.status().st_dev)
+        );
+}
+
+// compare two fileStates for same Inode
+bool fileStat::sameINode(const fileStat& stat2) const
+{
+    return isValid_ && (status_.st_ino == stat2.status().st_ino);
+}
+
+// compare state against inode
+bool fileStat::sameINode(const label iNode) const
+{
+    return isValid_ && (status_.st_ino == ino_t(iNode));
+}
+
+
+// * * * * * * * * * * * * * * * Friend Operators  * * * * * * * * * * * * * //
+
+// Input in list syntax
+Istream& operator>>(Istream& is, fileStat& fStat)
+{
+    // Read beginning of machine info list
+    is.readBegin("fileStat");
+
+    label 
+        devMaj, devMin,
+        ino, mode, uid, gid,
+        rdevMaj, rdevMin,
+        size, atime, mtime, ctime;
+
+    is  >> fStat.isValid_
+        >> devMaj
+        >> devMin
+        >> ino
+        >> mode
+        >> uid
+        >> gid
+        >> rdevMaj
+        >> rdevMin
+        >> size
+        >> atime
+        >> mtime
+        >> ctime;
+
+    dev_t st_dev = makedev(devMaj, devMin);
+    fStat.status_.st_dev = st_dev;
+
+    fStat.status_.st_ino = ino;
+    fStat.status_.st_mode = mode;
+    fStat.status_.st_uid = uid;
+    fStat.status_.st_gid = gid;
+
+    dev_t st_rdev = makedev(rdevMaj, rdevMin);
+    fStat.status_.st_rdev = st_rdev;
+
+    fStat.status_.st_size = size;
+    fStat.status_.st_atime = atime;
+    fStat.status_.st_mtime = mtime;
+    fStat.status_.st_ctime = ctime;
+
+    // Read end of machine info list
+    is.readEnd("fileStat");
+
+    // Check state of Istream
+    is.check("Istream& operator>>(Istream&, fileStat&)");
+
+    return is;
+}
+
+
+// Output in list syntax
+Ostream& operator<<(Ostream& os, const fileStat& fStat)
+{
+    //Set precision so 32bit unsigned int can be printed
+//    int oldPrecision = os.precision();
+    int oldPrecision = 0;
+    os.precision(10);
+
+    os  << token::BEGIN_LIST << fStat.isValid_
+        << token::SPACE << label(major(fStat.status_.st_dev))
+        << token::SPACE << label(minor(fStat.status_.st_dev))
+        << token::SPACE << label(fStat.status_.st_ino)
+        << token::SPACE << label(fStat.status_.st_mode)
+        << token::SPACE << label(fStat.status_.st_uid)
+        << token::SPACE << label(fStat.status_.st_gid)
+        << token::SPACE << label(major(fStat.status_.st_rdev))
+        << token::SPACE << label(minor(fStat.status_.st_rdev))
+        << token::SPACE << label(fStat.status_.st_size)
+        << token::SPACE << label(fStat.status_.st_atime)
+        << token::SPACE << label(fStat.status_.st_mtime)
+        << token::SPACE << label(fStat.status_.st_ctime)
+        << token::END_LIST;
+
+    os.precision(oldPrecision);
+    return os;
+}
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/Allwmake	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,7 @@
+#!/bin/sh
+cd ${0%/*} || exit 1    # run from this directory
+
+# make (non-shared) object
+wmake libo
+
+# ----------------------------------------------------------------- end-of-file
--- src/OSspecific/MSwindows/signals/sigStopAtWriteNow.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigStopAtWriteNow.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,96 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::sigStopAtWriteNow
+
+Description
+    Signal handler for interupt defined by
+        OptimisationSwitches::stopAtWriteNowSignal
+
+    Write and stop the job.
+
+SourceFiles
+    sigStopAtWriteNow.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigStopAtWriteNow_H
+#define sigStopAtWriteNow_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+class Time;
+
+/*---------------------------------------------------------------------------*\
+                           Class sigStopAtWriteNow Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigStopAtWriteNow
+{
+    // Private data
+
+        //- number of signal to use
+        static int signal_;
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t oldAction_;
+
+    // Private Member Functions
+
+        static void sigHandler(int);
+
+
+public:
+
+    // Constructors
+
+        //- Construct null
+        sigStopAtWriteNow();
+
+        //- Construct from components
+        sigStopAtWriteNow(const bool verbose, const Time& runTime);
+
+
+    //- Destructor
+    ~sigStopAtWriteNow();
+
+
+    // Member functions
+
+        //- Is active?
+        bool active() const;
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigWriteNow.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigWriteNow.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,133 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "sigWriteNow.H"
+#include "error.H"
+#include "JobInfo.H"
+#include "IOstreams.H"
+#include "Time.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+// Signal number to catch
+int Foam::sigWriteNow::signal_
+(
+    debug::optimisationSwitch("writeNowSignal", -1)
+);
+
+static Foam::Time* runTimePtr_ = NULL;
+
+
+__p_sig_fn_t Foam::sigWriteNow::oldAction_ = SIG_DFL;
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::sigWriteNow::sigHandler(int)
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(signal_, oldAction_);
+    oldAction_ = SIG_DFL;
+    
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigWriteNow::sigHandler(int)"
+        )   << "Cannot reset " << signal_ << " trapping"
+            << abort(FatalError);
+    }
+
+    Info<< "sigWriteNow :"
+        << " setting up write at end of the next iteration" << nl << endl;
+    runTimePtr_->writeOnce();
+
+    //// Throw signal (to old handler)
+    //raise(signal_);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigWriteNow::sigWriteNow()
+{}
+
+
+Foam::sigWriteNow::sigWriteNow(const bool verbose, Time& runTime)
+{
+    if (signal_ >= 0)
+    {
+        // Store runTime
+        runTimePtr_ = &runTime;
+
+	oldAction_ = ::signal(signal_, &Foam::sigWriteNow::sigHandler);        
+
+	if (SIG_ERR == oldAction_)
+	{
+            FatalErrorIn
+            (
+                "Foam::sigWriteNow::sigWriteNow(const bool, const Time&)"
+            )   << "Cannot set " << signal_ << " trapping"
+                << abort(FatalError);
+        }
+
+        if (verbose)
+        {
+            Info<< "sigWriteNow :"
+                << " Enabling writing upon signal " << signal_
+                << endl;
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigWriteNow::~sigWriteNow()
+{
+    // Reset old handling
+    if (signal_ > 0)
+    {
+        const __p_sig_fn_t success = ::signal(signal_, oldAction_);
+	oldAction_ = SIG_DFL;
+
+	if (SIG_ERR == success)
+        {
+            FatalErrorIn
+            (
+                "Foam::sigWriteNow::~sigWriteNow()"
+            )   << "Cannot reset " << signal_ << " trapping"
+                << abort(FatalError);
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+bool Foam::sigWriteNow::active() const
+{
+    return signal_ > 0;
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigFpe.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigFpe.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,92 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigFpe
+
+Description
+    Sets up trapping for floating point exceptions (sigfpe).
+
+    Controlled by two env vars:
+    FOAM_SIGFPE : exception trapping
+    FOAM_SETNAN : initialization of all malloced memory to NaN. If also
+                  FOAM_SIGFPE set this will cause usage of uninitialized scalars
+                  to trigger an abort.
+
+SourceFiles
+    sigFpe.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigFpe_H
+#define sigFpe_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class sigFpe Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigFpe
+{
+    // Private data
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t oldAction_;
+
+
+    // Static data members
+
+        //- Handler for caught signals
+        static void sigFpeHandler(int);
+
+public:
+
+
+    // Constructors
+
+        sigFpe();
+
+
+    // Destructor
+
+        ~sigFpe();
+
+
+    // Member functions
+
+        void set(const bool verbose);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigInt.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigInt.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,86 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigInt
+
+Description
+    Signal handler for INT interupt.  The standard interupt handler is
+    overridden to ensure that the runningJob file is removed.
+
+SourceFiles
+    sigInt.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigInt_H
+#define sigInt_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class sigInt Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigInt
+{
+    // Private data
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t oldAction_;
+
+
+    // Private Member Functions
+
+        static void sigIntHandler(int);
+
+
+public:
+
+    // Constructors
+
+        sigInt();
+
+
+    // Destructor
+
+        ~sigInt();
+
+
+    // Member functions
+
+        void set(const bool verbose);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigQuit.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigQuit.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,113 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigQuit
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+#include "sigQuit.H"
+#include "JobInfo.H"
+#include "IOstreams.H"
+
+// SIGBREAK is best alternative to SIGQUIT on windows
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+__p_sig_fn_t Foam::sigQuit::oldAction_ = SIG_DFL;
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::sigQuit::sigQuitHandler(int)
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(SIGBREAK, oldAction_);
+
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn("Foam::sigQuit::sigQuitHandler()")   
+            << "Cannot reset SIGBREAK trapping"
+            << abort(FatalError);    
+    }
+
+    // Update jobInfo file
+    jobInfo.signalEnd();
+
+    error::printStack(Perr);
+
+    // Throw signal (to old handler)
+    ::raise(SIGBREAK);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigQuit::sigQuit()
+{
+    oldAction_ = SIG_DFL;
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigQuit::~sigQuit()
+{
+    // Reset old handling
+    if (SIG_DFL != oldAction_)
+    {
+        const __p_sig_fn_t success = ::signal(SIGBREAK, oldAction_);
+        oldAction_ = SIG_DFL;
+
+        if (SIG_ERR == success)
+        {
+            FatalErrorIn("Foam::sigQuit::~sigQuit()")
+                << "Cannot reset SIGBREAK trapping"
+                << abort(FatalError);    
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::sigQuit::set(const bool verbose)
+{
+    if (SIG_DFL != oldAction_)
+    {
+        FatalErrorIn("Foam::sigQuit::set()")   
+            << "Cannot call sigQuit::set() more than once"
+            << abort(FatalError);
+    }
+
+    oldAction_ = ::signal(SIGBREAK, &Foam::sigQuit::sigQuitHandler);        
+
+    if (SIG_ERR == oldAction_)
+    {
+        oldAction_ = SIG_DFL;
+
+        // Not a FatalErrorIn or abort because fails under wine
+        WarningIn("Foam::sigQuit::set()")
+            << "Cannot set SIGBREAK trapping" << endl;
+    }
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigWriteNow.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigWriteNow.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,98 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::sigWriteNow
+
+Description
+    Signal handler for interupt defined by OptimisationSwitches::writeNowSignal
+
+    Write once and continue.
+
+SourceFiles
+    sigWriteNow.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigWriteNow_H
+#define sigWriteNow_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+class Time;
+
+/*---------------------------------------------------------------------------*\
+                           Class sigWriteNow Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigWriteNow
+{
+    // Private data
+
+        //- number of signal to use
+        static int signal_;
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t  oldAction_;
+
+    // Private Member Functions
+
+        static void sigHandler(int);
+
+
+public:
+
+    friend class sigStopAtWriteNow;
+
+    // Constructors
+
+        //- Construct null
+        sigWriteNow();
+
+        //- Construct from components
+        sigWriteNow(const bool verbose, Time& runTime);
+
+
+    //- Destructor
+    ~sigWriteNow();
+
+
+    // Member functions
+
+        //- Is active?
+        bool active() const;
+
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigSegv.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigSegv.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,116 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigSegv
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+#include "sigSegv.H"
+#include "JobInfo.H"
+#include "IOstreams.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+__p_sig_fn_t Foam::sigSegv::oldAction_ = SIG_DFL;
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::sigSegv::sigSegvHandler(int)
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(SIGSEGV, oldAction_);
+
+    if (SIG_ERR == success)
+    {
+         FatalErrorIn
+        (
+            "Foam::sigSegv::sigSegvHandler()"
+        )   << "Cannot reset SIGSEGV trapping"
+            << abort(FatalError);    
+    }
+
+    // Update jobInfo file
+    jobInfo.signalEnd();
+
+    error::printStack(Perr);
+
+    // Throw signal (to old handler)
+    ::raise(SIGSEGV);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigSegv::sigSegv()
+{
+    oldAction_ = SIG_DFL;
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigSegv::~sigSegv()
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(SIGSEGV, oldAction_);
+    oldAction_ = SIG_DFL;
+
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigSegv::~sigSegv()"
+        )   << "Cannot reset SIGSEGV trapping"
+            << abort(FatalError);    
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::sigSegv::set(const bool verbose)
+{
+    if (SIG_DFL != oldAction_)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigSegv::set()"
+        )   << "Cannot call sigSegv::set() more than once"
+            << abort(FatalError);
+    }
+
+    oldAction_ = ::signal(SIGSEGV, &Foam::sigSegv::sigSegvHandler);        
+
+    if (SIG_ERR == oldAction_)
+    {
+        oldAction_ = SIG_DFL;
+
+        FatalErrorIn
+        (
+            "Foam::sigSegv::set()"
+        )   << "Cannot set SIGSEGV trapping"
+            << abort(FatalError);    
+    }
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigQuit.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigQuit.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,86 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigQuit
+
+Description
+    Signal handler for QUIT interupt.  The standard interupt handler is
+    overridden to ensure that the runningJob file is removed.
+
+SourceFiles
+    sigQuit.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigQuit_H
+#define sigQuit_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class sigQuit Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigQuit
+{
+    // Private data
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t oldAction_;
+
+
+    // Private Member Functions
+
+        static void sigQuitHandler(int);
+
+
+public:
+
+    // Constructors
+
+        sigQuit();
+
+
+    // Destructor
+
+        ~sigQuit();
+
+
+    // Member functions
+
+        void set(const bool verbose);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigSegv.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigSegv.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,86 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigSegv
+
+Description
+    Signal handler for SEGV interupt.  The standard interupt handler is
+    overridden to ensure that the runningJob file is removed.
+
+SourceFiles
+    sigSegv.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef sigSegv_H
+#define sigSegv_H
+
+#include <signal.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class sigSegv Declaration
+\*---------------------------------------------------------------------------*/
+
+class sigSegv
+{
+    // Private data
+
+        //- Saved old signal trapping setting
+        static __p_sig_fn_t oldAction_;
+
+
+    // Private Member Functions
+
+        static void sigSegvHandler(int);
+
+
+public:
+
+    // Constructors
+
+        sigSegv();
+
+
+    // Destructor
+
+        ~sigSegv();
+
+
+    // Member functions
+
+        void set(const bool verbose);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigStopAtWriteNow.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigStopAtWriteNow.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,156 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "sigStopAtWriteNow.H"
+#include "error.H"
+#include "JobInfo.H"
+#include "IOstreams.H"
+#include "Time.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+// Signal number to catch
+int Foam::sigStopAtWriteNow::signal_
+(
+    debug::optimisationSwitch("stopAtWriteNowSignal", -1)
+);
+
+static Foam::Time const* runTimePtr_ = NULL;
+
+
+__p_sig_fn_t Foam::sigStopAtWriteNow::oldAction_ = SIG_DFL;
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::sigStopAtWriteNow::sigHandler(int)
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(signal_, oldAction_);
+    oldAction_ = SIG_DFL;
+    
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigStopAtWriteNow::sigHandler(int)"
+        )   << "Cannot reset " << signal_ << " trapping"
+            << abort(FatalError);
+    }
+
+    // Update jobInfo file
+    jobInfo.signalEnd();
+
+    Info<< "sigStopAtWriteNow :"
+        << " setting up write and stop at end of the next iteration"
+        << nl << endl;
+    runTimePtr_->stopAt(Time::saWriteNow);
+
+    //// Throw signal (to old handler)
+    //raise(signal_);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigStopAtWriteNow::sigStopAtWriteNow(){}
+
+
+Foam::sigStopAtWriteNow::sigStopAtWriteNow
+(
+    const bool verbose,
+    const Time& runTime
+)
+{
+    if (signal_ > 0)
+    {
+        // Check that the signal is different from the writeNowSignal
+        if (sigWriteNow::signal_ == signal_)
+        {
+            FatalErrorIn
+            (
+                "Foam::sigStopAtWriteNow::sigStopAtWriteNow"
+                "(const bool, const Time&)"
+            )   << "stopAtWriteNowSignal : " << signal_
+                << " cannot be the same as the writeNowSignal."
+                << " Please change this in the controlDict ("
+                << findEtcFile("controlDict", false) << ")."
+                << exit(FatalError);
+        }
+
+
+        // Store runTime
+        runTimePtr_ = &runTime;
+
+	oldAction_ = ::signal(signal_, &Foam::sigWriteNow::sigHandler);        
+
+	if (SIG_ERR == oldAction_)
+        {
+            FatalErrorIn
+            (
+                "Foam::sigStopAtWriteNow::sigStopAtWriteNow"
+                "(const bool, const Time&)"
+            )   << "Cannot set " << signal_ << " trapping"
+                << abort(FatalError);
+        }
+
+        if (verbose)
+        {
+            Info<< "sigStopAtWriteNow :"
+                << " Enabling writing and stopping upon signal " << signal_
+                << endl;
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigStopAtWriteNow::~sigStopAtWriteNow()
+{
+    // Reset old handling
+    if (signal_ > 0)
+    {
+        const __p_sig_fn_t success = ::signal(signal_, oldAction_);
+	oldAction_ = SIG_DFL;
+
+	if (SIG_ERR == success)
+        {
+            FatalErrorIn
+            (
+                "Foam::sigStopAtWriteNow::~sigStopAtWriteNow()"
+            )   << "Cannot reset " << signal_ << " trapping"
+                << abort(FatalError);
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+bool Foam::sigStopAtWriteNow::active() const
+{
+    return signal_ > 0;
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigFpe.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigFpe.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,168 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigFpe
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+#include "sigFpe.H"
+
+#include "JobInfo.H"
+#include "OSspecific.H"
+#include "IOstreams.H"
+
+#include <float.h> // *fp functions
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+__p_sig_fn_t Foam::sigFpe::oldAction_ = SIG_DFL;
+
+static unsigned int fpOld_ = 0;
+
+
+static void clearFpe()
+{
+    _clearfp ();
+    _controlfp (fpOld_, 0xFFFFFFFF);
+}
+
+
+void Foam::sigFpe::sigFpeHandler(int)
+{
+    const __p_sig_fn_t success = ::signal(SIGFPE, oldAction_);
+
+    // Reset old handling
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigSegv::sigFpeHandler()"
+        )   << "Cannot reset SIGFPE trapping"
+            << abort(FatalError);    
+    }
+
+    // Update jobInfo file
+    jobInfo.signalEnd();
+
+    error::printStack(Perr);
+
+    clearFpe();
+
+    // Throw signal (to old handler)
+    ::raise(SIGFPE);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigFpe::sigFpe()
+{
+    oldAction_ = SIG_DFL;
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigFpe::~sigFpe()
+{
+    if (env("FOAM_SIGFPE"))
+    {
+        clearFpe();
+
+        // Reset signal
+        const __p_sig_fn_t success = ::signal(SIGFPE, oldAction_);
+        oldAction_ = SIG_DFL;
+
+        if (SIG_ERR == success)
+        {
+            FatalErrorIn
+            (
+                "Foam::sigFpe::~sigFpe()"
+            )   << "Cannot reset SIGFPE trapping"
+                << abort(FatalError);    
+        }
+    }
+
+    if (env("FOAM_SETNAN"))
+    {
+        WarningIn("Foam::sigFpe::~sigFpe()")
+            << "FOAM_SETNAN not supported under MSwindows "
+            << endl;
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::sigFpe::set(const bool verbose)
+{
+    if (SIG_DFL != oldAction_)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigFpe::set()"
+        )   << "Cannot call sigFpe::set() more than once"
+            << abort(FatalError);
+    }
+
+    if (env("FOAM_SIGFPE"))
+    {
+        if (verbose)
+        {
+            Info<< "SigFpe : Enabling floating point exception trapping"
+                << " (FOAM_SIGFPE)." << endl;
+        }
+
+        fpOld_ = _controlfp(0, 0);
+        const unsigned int fpNew = 
+          fpOld_ & ~(_EM_ZERODIVIDE | _EM_INVALID | _EM_OVERFLOW);
+        _controlfp(fpNew, _MCW_EM);
+
+        oldAction_ = ::signal(SIGFPE, &Foam::sigFpe::sigFpeHandler);        
+
+        if (SIG_ERR == oldAction_)
+        {
+            oldAction_ = SIG_DFL;
+
+            FatalErrorIn
+            (
+                "Foam::sigFpe::set()"
+            )   << "Cannot set SIGFPE trapping"
+                << abort(FatalError);    
+        }
+    }
+
+
+    if (env("FOAM_SETNAN"))
+    {
+        if (verbose)
+        {
+            WarningIn("Foam::sigFpe::set()")
+              << "FOAM_SETNAN not supported under MSwindows "
+              << endl;
+        }
+    }
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/signals/sigInt.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/signals/sigInt.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,114 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    sigInt
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+#include "sigInt.H"
+#include "JobInfo.H"
+#include "IOstreams.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+__p_sig_fn_t Foam::sigInt::oldAction_ = SIG_DFL;
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::sigInt::sigIntHandler(int)
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(SIGINT, oldAction_);
+
+    if (SIG_ERR == success)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigInt::sigIntHandler()"
+        )   << "Cannot reset SIGINT trapping"
+            << abort(FatalError);
+    }
+
+    // Update jobInfo file
+    jobInfo.signalEnd();
+
+    // Throw signal (to old handler)
+    ::raise(SIGINT);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::sigInt::sigInt()
+{
+    oldAction_ = SIG_DFL;
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::sigInt::~sigInt()
+{
+    // Reset old handling
+    const __p_sig_fn_t success = ::signal(SIGINT, oldAction_);
+    oldAction_ = SIG_DFL;
+
+    if (SIG_ERR == success)
+    {
+         FatalErrorIn
+        (
+            "Foam::sigInt::~sigInt()"
+        )   << "Cannot reset SIGINT trapping"
+            << abort(FatalError);    
+    }
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::sigInt::set(const bool verbose)
+{
+    if (SIG_DFL != oldAction_)
+    {
+        FatalErrorIn
+        (
+            "Foam::sigInt::set()"
+        )   << "Cannot call sigInt::set() more than once"
+            << abort(FatalError);
+    }
+
+    oldAction_ = ::signal(SIGINT, &Foam::sigInt::sigIntHandler);        
+
+    if (SIG_ERR == oldAction_)
+    {
+        oldAction_ = SIG_DFL;
+ 
+        FatalErrorIn
+        (
+            "Foam::sigInt::set()"
+        )   << "Cannot set SIGINT trapping"
+            << abort(FatalError);    
+    }
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/timer.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/timer.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,175 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Description
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+#include "MSwindows.H"
+#include "timer.H"
+
+#undef WINVER
+#define WINVER 0x0500 // To access CreateTimerQueueTimer
+#include <windows.h>
+
+#define SIGALRM 14
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam 
+{
+  defineTypeNameAndDebug(timer, 0);
+}
+
+jmp_buf Foam::timer::envAlarm;
+
+__p_sig_fn_t Foam::timer::oldAction_ = SIG_DFL;
+
+static HANDLE hTimer_ = NULL;
+
+// * * * * * * * * * * * * * Static Member Functions * * * * * * * * * * * * //
+
+void Foam::timer::signalHandler(int)
+{     
+    if (debug)
+    {
+        Info<< "Foam::timer::signalHandler(int sig) : "
+            << " timed out. Jumping."
+            << endl;
+    }
+    ::longjmp(envAlarm, 1);
+}
+
+
+static VOID CALLBACK timerExpired(PVOID lpParam, BOOLEAN TimerOrWaitFired)
+{
+    ::raise(SIGALRM);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+
+// Construct from components
+Foam::timer::timer(const unsigned int newTimeOut)
+:
+    newTimeOut_(newTimeOut)
+{
+
+    if (newTimeOut > 0)
+    {
+        // Is singleton since handler is static function
+        if (NULL != hTimer_)
+        {
+            FatalErrorIn
+            (
+                "Foam::timer::timer(const unsigned int)"
+            )   << "timer already used."
+                << abort(FatalError);    
+        }
+
+        // Install alarm signal handler:
+        oldAction_ = ::signal(SIGALRM, &Foam::timer::signalHandler);
+
+        if (SIG_ERR == oldAction_)
+        {
+            oldAction_ = SIG_DFL;
+
+            FatalErrorIn
+            (
+                "Foam::timer::timer(const unsigned int)"
+            )   << "sigaction(SIGALRM) error"
+                << abort(FatalError);    
+        }
+
+        if (debug)
+        {
+            Info<< "Foam::timer::timer(const unsigned int) : "
+                << " installing timeout " << int(newTimeOut_)
+                << " seconds." << endl;
+        }
+
+        const bool success = 
+          ::CreateTimerQueueTimer(&hTimer_, 
+                                  NULL, 
+                                  (WAITORTIMERCALLBACK)timerExpired,
+                                  NULL , 
+                                  newTimeOut * 1000, 
+                                  0, 0);
+
+        if (!success) 
+        {
+            hTimer_ = NULL;
+            FatalErrorIn
+            (
+                "Foam::timer::timer(const unsigned int)"
+            )   << "CreateTimerQueueTimer, "
+                << MSwindows::getLastError()
+                << abort(FatalError);    
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::timer::~timer()
+{
+    if (newTimeOut_ > 0)
+    {
+        // Reset timer
+        const bool timerSuccess = 
+          ::DeleteTimerQueueTimer(NULL, hTimer_, NULL);
+        hTimer_ = NULL;
+
+        if (!timerSuccess) 
+        {
+            FatalErrorIn
+            (
+                "Foam::timer::~timer() "
+            )   << "DeleteTimerQueueTimer, "
+                << MSwindows::getLastError()
+                << abort(FatalError);    
+        }
+
+        if (debug)
+        {
+            Info<< "Foam::timer::~timer() timeOut="
+                << int(newTimeOut_) << endl;
+        }
+
+        const __p_sig_fn_t signalSuccess = signal(SIGALRM, oldAction_);
+        oldAction_ = SIG_DFL;
+
+        // Restore signal handler
+        if (SIG_ERR == signalSuccess)
+        {
+            FatalErrorIn
+            (
+                "Foam::timer::~timer()"
+            )   << "sigaction(SIGALRM) error"
+                << abort(FatalError);    
+        }
+    }
+}
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/fileStat.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/fileStat.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,121 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    fileStat
+
+Description
+    Wrapper for stat() system call.
+
+    WARNING: on Linux (an maybe on others) a stat() of an nfs mounted (remote)
+    file does never timeout and cannot be interrupted! So e.g. Foam::ping first
+    and hope nfs is running.
+
+SourceFiles
+    fileStat.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef fileStat_H
+#define fileStat_H
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include "label.H"
+#include "fileName.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class fileStat Declaration
+\*---------------------------------------------------------------------------*/
+
+class fileStat
+{
+    // Private data
+
+        struct stat status_;
+
+        bool isValid_;
+
+
+public:
+
+    // Constructors
+
+        //- Empty constructor
+        fileStat();
+
+        //- Construct from components
+        fileStat(const fileName& fName, const unsigned int maxTime=0);
+
+        //- Construct from Istream
+        fileStat(Istream&);
+
+
+    // Member Functions
+
+        // Access
+
+            //- Raw status
+            const struct stat& status() const
+            {
+                return status_;
+            }
+
+            //- Did constructor fail
+            bool isValid() const
+            {
+                return isValid_;
+            }
+
+
+        // Check
+
+            //- compare two fileStats for same device
+            bool sameDevice(const fileStat& stat2) const;
+
+            //- compare two fileStats for same Inode
+            bool sameINode(const fileStat& stat2) const;
+
+            //- compare state against inode
+            bool sameINode(const label iNode) const;
+
+
+    // IOstream Operators
+
+        friend Istream& operator>>(Istream&, fileStat&);
+        friend Ostream& operator<<(Ostream&, const fileStat&);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/printStack.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/printStack.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,35 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "error.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+void Foam::error::safePrintStack(std::ostream& os)
+{}
+
+
+void Foam::error::printStack(Ostream& os)
+{}
+
+// ************************************************************************* //
+
--- src/OSspecific/MSwindows/cpuTime/cpuTime.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/cpuTime/cpuTime.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,89 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Description
+    Starts timing CPU usage and return elapsed time from start.
+
+\*---------------------------------------------------------------------------*/
+
+#include "cpuTime.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+inline
+void cpuTime::getTime(std::clock_t& t)
+{
+    t = std::clock();
+}
+
+
+inline
+double cpuTime::timeDifference
+(
+    const std::clock_t& start,
+    const std::clock_t& end
+)
+{
+    const double difference = std::difftime(end, start)/CLOCKS_PER_SEC;
+    return difference;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+cpuTime::cpuTime()
+{
+    getTime(startTime_);
+    lastTime_ = startTime_;
+    newTime_ = startTime_;
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+double cpuTime::elapsedCpuTime() const
+{
+    getTime(newTime_);
+    const double elapsed = timeDifference(startTime_, newTime_);
+    return elapsed;
+}
+
+
+double cpuTime::cpuTimeIncrement() const
+{
+    lastTime_ = newTime_;
+    getTime(newTime_);
+    const double increment = timeDifference(lastTime_, newTime_);
+    return increment;
+}
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/cpuTime/cpuTime.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/cpuTime/cpuTime.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,91 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    cpuTime
+
+Description
+    Starts timing CPU usage and return elapsed time from start.
+
+SourceFiles
+    cpuTime.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef cpuTime_H
+#define cpuTime_H
+
+#include <ctime>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class cpuTime Declaration
+\*---------------------------------------------------------------------------*/
+
+class cpuTime
+{
+    // Private data
+
+        std::clock_t startTime_;
+        mutable std::clock_t lastTime_;
+        mutable std::clock_t newTime_;
+
+        static void getTime(std::clock_t& t);
+
+        static double timeDifference
+        (
+            const std::clock_t& start,
+            const std::clock_t& end
+        );
+
+
+public:
+
+    // Constructors
+
+        //- Construct from components
+        cpuTime();
+
+
+    // Member Functions
+
+        // Access
+
+            //- Returns CPU time from start of run
+            double elapsedCpuTime() const;
+
+            //- Returns CPU time from last call of cpuTimeIncrement()
+            double cpuTimeIncrement() const;
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/timer.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/timer.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,126 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    timer
+
+Description
+    Implements a timeout mechanism. Usage is as following:
+
+    timer myTimer(5);     // 5 sec
+    ..
+    if (timedOut(myTimer))
+    {
+        // timed out
+    }
+    else
+    {
+        // do something possible blocking
+    }
+
+    Constructor set signal handler on sigalarm and alarm(). Destructor
+    clears these.
+
+    timedOut is macro because setjmp can't be in member function of timer.
+    ?something to do with stack frames.
+
+    WARNING: setjmp restores complete register state so including local vars
+    held in regs. So if in blocking part something gets calced in a stack
+    based variable make sure it is declared 'volatile'.
+
+SourceFiles
+    timer.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef timer_H
+#define timer_H
+
+#include "className.H"
+
+#include <signal.h>
+#include <setjmp.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+// keep setjmp in same stack frame so no function calls
+#define timedOut(x) \
+    (((x).newTimeOut_ > 0) ? setjmp(Foam::timer::envAlarm) : false)
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class timer Declaration
+\*---------------------------------------------------------------------------*/
+
+class timer
+{
+    // Private data
+
+        //- old signal
+        static __p_sig_fn_t oldAction_;
+
+        //- old alarm() value
+        static unsigned int oldTimeOut_;
+
+
+    // Private Member Functions
+
+        //- alarm handler
+        static void signalHandler(int);
+
+
+public:
+
+    // Public data
+
+        //- Declare name of the class and it's debug switch
+        ClassName("timer");
+
+        //- current time out value. Needed by macro timedOut
+        unsigned int newTimeOut_;
+
+        //- state for setjmp. Needed by macro timedOut
+        static jmp_buf envAlarm;
+
+
+    // Constructors
+
+        //- Construct from components.
+        //  newTimeOut=0 makes it do nothing.
+        timer(const unsigned int newTimeOut);
+
+
+    // Destructor
+
+        ~timer();
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/fileMonitor.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/fileMonitor.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,439 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*----------------------------------------------------------------------------*/
+
+#include "fileMonitor.H"
+#include "IOstreams.H"
+#include "Pstream.H"
+#include "PackedList.H"
+#include "PstreamReduceOps.H"
+#include "OSspecific.H"
+#include "regIOobject.H"     // for fileModificationSkew symbol
+
+#include "OSspecific.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+const Foam::NamedEnum<Foam::fileMonitor::fileState, 3>
+    Foam::fileMonitor::fileStateNames_;
+
+namespace Foam
+{
+    defineTypeNameAndDebug(fileMonitor, 0);
+
+    template<>
+    const char* Foam::NamedEnum
+    <
+        Foam::fileMonitor::fileState,
+        3
+    >::names[] =
+    {
+        "unmodified",
+        "modified",
+        "deleted"
+    };
+
+    //- Reduction operator for PackedList of fileState
+    class reduceFileStates
+    {
+        public:
+        unsigned int operator()(const unsigned int x, const unsigned int y)
+        const
+        {
+            // x,y are sets of 2bits representing fileState
+
+            unsigned int mask = 3u;
+            unsigned int shift = 0;
+            unsigned int result = 0;
+
+            while (mask)
+            {
+                // Combine state
+                unsigned int xState = (x & mask) >> shift;
+                unsigned int yState = (y & mask) >> shift;
+
+                // Combine and add to result. Combine is such that UNMODIFIED
+                // wins.
+                unsigned int state = min(xState, yState);
+                result |= (state << shift);
+
+                shift += 2;
+                mask <<= 2;
+            }
+            return result;
+        }
+    };
+
+    //- Combine operator for PackedList of fileState
+    class combineReduceFileStates
+    {
+        public:
+        void operator()(unsigned int& x, const unsigned int y) const
+        {
+            x = reduceFileStates()(x, y);
+        }
+    };
+
+
+
+    //-  Internal tracking via stat(3p) or inotify(7)
+    class fileMonitorWatcher
+    {
+    public:
+
+        const bool useInotify_;
+
+        // For inotify
+
+            //- File descriptor for the inotify instance
+            int inotifyFd_;
+
+            //- Current watchIDs and corresponding directory id
+            DynamicList<label> dirWatches_;
+            DynamicList<fileName> dirFiles_;
+
+        // For stat
+
+            //- From watch descriptor to modified time
+            DynamicList<time_t> lastMod_;
+
+
+
+        //- initialise inotify
+        inline fileMonitorWatcher(const bool useInotify, const label sz = 20)
+        :
+            useInotify_(useInotify)
+        {
+            if (useInotify_)
+            {
+                    FatalErrorIn("fileMonitorWatcher(const bool, const label)")
+                        << "You selected inotify but this file was compiled"
+                        << " without FOAM_USE_INOTIFY"
+                        << "Please select another fileModification test method"
+                        << exit(FatalError);
+            }
+            else
+            {
+                lastMod_.setCapacity(sz);
+            }
+        }
+
+        //- remove all watches
+        inline ~fileMonitorWatcher()
+        {
+        }
+
+        inline bool addWatch(const label watchFd, const fileName& fName)
+        {
+            if (useInotify_)
+            {
+                if (inotifyFd_ < 0)
+                {
+                    return false;
+                }
+
+            }
+            else
+            {
+                if (watchFd < lastMod_.size() && lastMod_[watchFd] != 0)
+                {
+                    // Reuse of watchFd : should have lastMod set to 0.
+                    FatalErrorIn("addWatch(const label, const fileName&)")
+                        << "Problem adding watch " << watchFd
+                        << " to file " << fName
+                        << abort(FatalError);
+                }
+
+                lastMod_(watchFd) = lastModified(fName);
+            }
+
+            return true;
+        }
+
+        inline bool removeWatch(const label watchFd)
+        {
+            if (useInotify_)
+            {
+                if (inotifyFd_ < 0)
+                {
+                    return false;
+                }
+
+                dirWatches_[watchFd] = -1;
+            }
+            else
+            {
+                lastMod_[watchFd] = 0;
+            }
+            return true;
+        }
+
+    };
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void Foam::fileMonitor::checkFiles() const
+{
+    if (useInotify_)
+    {
+    }
+    else
+    {
+        forAll(watcher_->lastMod_, watchFd)
+        {
+            time_t oldTime = watcher_->lastMod_[watchFd];
+
+            if (oldTime != 0)
+            {
+                const fileName& fName = watchFile_[watchFd];
+                time_t newTime = lastModified(fName);
+
+                if (newTime == 0)
+                {
+                    localState_[watchFd] = DELETED;
+                }
+                else
+                {
+                    if (newTime > (oldTime + regIOobject::fileModificationSkew))
+                    {
+                        localState_[watchFd] = MODIFIED;
+                    }
+                    else
+                    {
+                        localState_[watchFd] = UNMODIFIED;
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+
+Foam::fileMonitor::fileMonitor(const bool useInotify)
+:
+    useInotify_(useInotify),
+    localState_(20),
+    state_(20),
+    watchFile_(20),
+    freeWatchFds_(2),
+    watcher_(new fileMonitorWatcher(useInotify_, 20))
+{
+    if (useInotify_) 
+    {
+        FatalErrorIn("inotify is not available.")
+		     << "Please select another fileModification test method"
+		     << exit(FatalError);
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::fileMonitor::~fileMonitor()
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+// Note: fName might not exist (on slaves if in master-only mode for
+// regIOobject)
+Foam::label Foam::fileMonitor::addWatch(const fileName& fName)
+{
+    label watchFd;
+
+    label sz = freeWatchFds_.size();
+
+    if (sz)
+    {
+        watchFd = freeWatchFds_[sz-1];
+        freeWatchFds_.setSize(sz-1);
+    }
+    else
+    {
+        watchFd = state_.size();
+    }
+
+    watcher_->addWatch(watchFd, fName);
+
+    if (debug)
+    {
+        Pout<< "fileMonitor : added watch " << watchFd << " on file "
+            << fName << endl;
+    }
+
+    if (watchFd < 0)
+    {
+        WarningIn("fileMonitor::addWatch(const fileName&)")
+            << "could not add watch for file " << fName << endl;
+    }
+    else
+    {
+        localState_(watchFd) = UNMODIFIED;
+        state_(watchFd) = UNMODIFIED;
+        watchFile_(watchFd) = fName;
+    }
+    return watchFd;
+}
+
+
+bool Foam::fileMonitor::removeWatch(const label watchFd)
+{
+    if (debug)
+    {
+        Pout<< "fileMonitor : removing watch " << watchFd << " on file "
+            << watchFile_[watchFd] << endl;
+    }
+
+    freeWatchFds_.append(watchFd);
+    return watcher_->removeWatch(watchFd);
+}
+
+
+const Foam::fileName& Foam::fileMonitor::getFile(const label watchFd) const
+{
+    return watchFile_[watchFd];
+}
+
+
+Foam::fileMonitor::fileState Foam::fileMonitor::getState(const label watchFd)
+const
+{
+    return state_[watchFd];
+}
+
+
+void Foam::fileMonitor::updateStates
+(
+    const bool masterOnly,
+    const bool syncPar
+) const
+{
+    if (Pstream::master() || !masterOnly)
+    {
+        // Update the localState_
+        checkFiles();
+    }
+
+    if (syncPar)
+    {
+        // Pack local state (might be on master only)
+        PackedList<2> stats(state_.size(), MODIFIED);
+        if (Pstream::master() || !masterOnly)
+        {
+            forAll(state_, watchFd)
+            {
+                stats[watchFd] = static_cast<unsigned int>
+                (
+                    localState_[watchFd]
+                );
+            }
+        }
+
+
+        // Scatter or reduce to synchronise state
+        if (masterOnly)
+        {
+            // Scatter
+            if (stats.storage().size() == 1)
+            {
+                Pstream::scatter(stats.storage()[0]);
+            }
+            else
+            {
+                Pstream::listCombineScatter(stats.storage());
+            }
+        }
+        else
+        {
+            // Reduce
+            if (stats.storage().size() == 1)
+            {
+                // Optimisation valid for most cases.
+                reduce(stats.storage()[0], reduceFileStates());
+            }
+            else
+            {
+                Pstream::listCombineGather
+                (
+                    stats.storage(),
+                    combineReduceFileStates()
+                );
+            }
+        }
+
+
+        // Update synchronised state
+        forAll(state_, watchFd)
+        {
+            // Assign synchronised state
+            unsigned int stat = stats[watchFd];
+            state_[watchFd] = fileState(stat);
+
+            if (!masterOnly)
+            {
+                // Give warning for inconsistent state
+                if (state_[watchFd] != localState_[watchFd])
+                {
+                    if (debug)
+                    {
+                        Pout<< "fileMonitor : Delaying reading "
+                            << watchFile_[watchFd]
+                            << " due to inconsistent "
+                               "file time-stamps between processors"
+                            << endl;
+                    }
+
+                    WarningIn
+                    (
+                        "fileMonitor::updateStates"
+                        "(const bool, const bool) const"
+                    )   << "Delaying reading " << watchFile_[watchFd]
+                        << " due to inconsistent "
+                           "file time-stamps between processors" << endl;
+                }
+            }
+        }
+    }
+    else
+    {
+        state_ = localState_;
+    }
+}
+
+
+void Foam::fileMonitor::setUnmodified(const label watchFd)
+{
+    state_[watchFd] = UNMODIFIED;
+    localState_[watchFd] = UNMODIFIED;
+
+    if (!useInotify_)
+    {
+        watcher_->lastMod_[watchFd] = lastModified(watchFile_[watchFd]);
+    }
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/clockTime/clockTime.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/clockTime/clockTime.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,92 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    clockTime
+
+Description
+    Starts timing (using rtc) and returns elapsed time from start. Better
+    resolution (2uSec instead of ~20mSec) than cpuTime.
+
+SourceFiles
+    clockTime.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef clockTime_H
+#define clockTime_H
+
+#include <winsock2.h> // timeval definition
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class clockTime Declaration
+\*---------------------------------------------------------------------------*/
+
+class clockTime
+{
+    // Private data
+
+        struct timeval startTime_;
+        mutable struct timeval lastTime_;
+        mutable struct timeval newTime_;
+
+        static void getTime(struct timeval& t);
+
+        static double timeDifference
+        (
+            const struct timeval& start,
+            const struct timeval& end
+        );
+
+
+public:
+
+    // Constructors
+
+        //- Construct from components
+        clockTime();
+
+
+    // Member Functions
+
+        // Access
+
+            //- Returns CPU time from start of run
+            double elapsedTime() const;
+
+            //- Returns CPU time from last call of clockTimeIncrement()
+            double timeIncrement() const;
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/clockTime/clockTime.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/clockTime/clockTime.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,84 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "clockTime.H"
+
+#include <sys/time.h>
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+// * * * * * * * * * * * * * * * Static Members  * * * * * * * * * * * * * * //
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+void clockTime::getTime(struct timeval& t)
+{
+    gettimeofday(&t, NULL);
+}
+
+
+double clockTime::timeDifference
+(
+    const struct timeval& start,
+    const struct timeval& end
+)
+{
+    return end.tv_sec - start.tv_sec + 1E-6*(end.tv_usec - start.tv_usec);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+clockTime::clockTime()
+{
+    getTime(startTime_);
+    lastTime_ = startTime_;
+    newTime_ = startTime_;
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+double clockTime::elapsedTime() const
+{
+    getTime(newTime_);
+    return timeDifference(startTime_, newTime_);
+}
+
+
+double clockTime::timeIncrement() const
+{
+    lastTime_ = newTime_;
+    getTime(newTime_);
+    return timeDifference(lastTime_, newTime_);
+}
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/regExp.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/regExp.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,200 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "regExp.H"
+#include "label.H"
+#include "string.H"
+#include "List.H"
+#include "IOstreams.H"
+
+// Alternative regular expression libraries to consider are:
+// Boost http://www.boost.org/libs/regex/doc/
+// GRETA http://research.microsoft.com/projects/greta/
+// Henry Spencer's http://arglist.com/regex/
+// 
+// Chose DEELX http://www.regexlab.com/en/deelx/
+// for its ease of integration - one header file
+#include "deelx.h"
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::regExp::regExp()
+:
+    preg_(0)
+{}
+
+
+Foam::regExp::regExp(const char* pattern, const bool ignoreCase)
+:
+    preg_(0)
+{
+    set(pattern, ignoreCase);
+}
+
+
+Foam::regExp::regExp(const std::string& pattern, const bool ignoreCase)
+:
+    preg_(0)
+{
+    set(pattern.c_str(), ignoreCase);
+}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
+
+Foam::regExp::~regExp()
+{
+    clear();
+}
+
+
+// * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * * //
+
+
+void Foam::regExp::set(const char* pattern, const bool ignoreCase) const
+{
+    clear();
+
+    // avoid NULL pointer and zero-length patterns
+    if (pattern && *pattern)
+    {
+        int cflags = EXTENDED;
+        if (ignoreCase)
+        {
+            cflags |= IGNORECASE;
+        }
+
+        preg_ = new CRegexpT<char>(pattern, cflags);
+    }
+}
+
+
+void Foam::regExp::set(const std::string& pattern, const bool ignoreCase) const
+{
+    return set(pattern.c_str(), ignoreCase);
+}
+
+
+bool Foam::regExp::clear() const
+{
+    if (preg_)
+    {
+        delete preg_;
+        preg_ = 0;
+
+        return true;
+    }
+
+    return false;
+}
+
+
+std::string::size_type Foam::regExp::find(const std::string& str) const
+{
+    std::string::size_type pos = std::string::npos;
+
+    if (preg_ && !str.empty())
+    {
+        const MatchResult result = preg_->Match(str.c_str());
+
+        if (0 < result.IsMatched())
+        {
+            pos = result.GetStart();
+        }
+    }
+
+    return pos;
+}
+
+
+bool Foam::regExp::match(const std::string& str) const
+{
+    bool isExactMatch = false;
+
+
+    if (preg_ && !str.empty())
+    {
+        const MatchResult result = preg_->MatchExact(str.c_str());
+        isExactMatch = (0 < result.IsMatched());
+    }
+
+    return isExactMatch;
+}
+
+
+bool Foam::regExp::match(const string& str, List<string>& groups) const
+{
+    bool isMatch = false;
+
+    if (preg_ && !str.empty())
+    {
+        const MatchResult results = preg_->MatchExact(str.c_str());
+        isMatch = (0 < results.IsMatched());
+
+        if (isMatch) 
+        {
+            int const notFound = -1;
+            int start, end;
+            const int groupsCount = results.MaxGroupNumber();
+            groups.setSize(groupsCount);
+        
+            for (int i = 0; groupsCount > i; ++i)
+            {
+                start = results.GetGroupStart(i);
+                end   = results.GetGroupEnd(i);
+                  
+                if ((notFound < start) && (notFound < end))
+                {
+                    groups[i] = str.substr(start, end - start);
+                }
+                else
+                {
+                    groups[i].clear();
+                }
+            }
+        }
+    }
+
+    if (!isMatch)
+    {
+        groups.clear();
+    }
+
+    return isMatch;
+}
+
+
+// * * * * * * * * * * * * * * Member Operators  * * * * * * * * * * * * * * //
+
+void Foam::regExp::operator=(const char* pat)
+{
+    set(pat);
+}
+
+
+void Foam::regExp::operator=(const std::string& pat)
+{
+    set(pat);
+}
+
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/MSwindows.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/MSwindows.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,1410 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Description
+    MS Windows specific functions
+
+\*---------------------------------------------------------------------------*/
+
+#include "OSspecific.H"
+#include "MSwindows.H"
+#include "foamVersion.H"
+#include "fileName.H"
+#include "fileStat.H"
+
+#include <cassert>
+#include <cstdlib>
+#include <fstream>
+#include <map>
+
+// Windows system header files
+#include <io.h> // _close
+#include <windows.h>
+#include <signal.h>
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam 
+{
+defineTypeNameAndDebug(MSwindows, 0);
+
+
+// Don't abort under windows, causes abort dialog to
+// popup. Instead just exit with exitCode.
+static
+void sigAbortHandler(int exitCode)
+{
+  ::exit(exitCode);
+}
+
+
+static
+bool installAbortHandler()
+{
+  // If it didn't succeed there's not much we can do,
+  // so don't check result.
+  ::signal(SIGABRT, &sigAbortHandler);
+  return true;
+}
+
+
+static bool const abortHandlerInstalled = installAbortHandler();
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+
+//- Get last windows api error from GetLastError
+std::string MSwindows::getLastError()
+{
+    // Based on an example at:
+    // http://msdn2.microsoft.com/en-us/library/ms680582(VS.85).aspx
+
+    LPVOID lpMsgBuf;
+    LPVOID lpDisplayBuf;
+    DWORD dw = GetLastError(); 
+
+    FormatMessage(
+        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+        FORMAT_MESSAGE_FROM_SYSTEM |
+        FORMAT_MESSAGE_IGNORE_INSERTS,
+        NULL,
+        dw,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+        (LPTSTR) &lpMsgBuf,
+        0, NULL );
+
+    lpDisplayBuf = LocalAlloc(LMEM_ZEROINIT, 
+        (lstrlen(static_cast<LPCTSTR>(lpMsgBuf))+40)*sizeof(TCHAR)); 
+    sprintf(static_cast<LPTSTR>(lpDisplayBuf),
+            "Error %d: %s", int(dw), static_cast<LPCTSTR>(lpMsgBuf));
+
+    const std::string errorMessage = static_cast<LPTSTR>(lpDisplayBuf);
+
+    LocalFree(lpMsgBuf);
+    LocalFree(lpDisplayBuf);
+
+    return errorMessage;
+}
+
+
+//-Declared here to avoid polluting MSwindows.H with windows.h
+namespace MSwindows
+{
+    //- Get windows user name
+    std::string getUserName();
+
+    //- Remove quotes, if any, from std::string
+    void removeQuotes(std::string & arg);
+
+    //- Convert windows directory slash (back-slash) to unix (forward-slash). 
+    //- Windows is fine with unix like directory slashes.
+    //- Foam's file io (see src/OpenFOAM/db/IOstreams/Sstreams/OSwrite.C) 
+    //- uses back-slash as escape character and continuation, 
+    //- so not an option to have windows file paths with back-slashes
+    void toUnixSlash(string & arg);
+
+    //- Auto create and then delete array when this goes out of scope
+    template<class T>
+    class AutoArray
+    {
+      T* const array_;
+
+    public:
+      AutoArray(const unsigned long arrayLength);
+      ~AutoArray();
+
+      //- Access array
+      T* get();
+    }; // class AutoArray
+
+
+    //- Directory contents iterator
+    class DirectoryIterator
+    {
+      WIN32_FIND_DATA findData_;
+      HANDLE findHandle_;
+      fileName nextName_;
+      bool hasMore_;
+      
+    public:
+      DirectoryIterator(const fileName & directory);
+      ~DirectoryIterator();
+      
+      //- Initialization succeeded
+      bool isValid() const;
+
+      //- Has more?
+      bool hasNext() const;
+      
+      //- Next item
+      const fileName & next();
+    }; // class DirectoryIterator
+} // namespace MSwindows
+
+
+inline
+void MSwindows::removeQuotes(std::string & arg)
+{
+    std::size_t pos;
+
+    while (std::string::npos != (pos = arg.find('"')))
+    {
+        arg.erase(pos, 1);
+    }
+}
+
+
+inline
+void MSwindows::toUnixSlash(string & arg)
+{
+    arg.replaceAll("\\", "/");
+
+    const std::string UNC("//");
+
+    // Preserve UNC i.e., \\machine-name\...
+    if (0 == arg.find(UNC)) 
+    {
+        arg.replace(UNC, "\\\\");
+    }
+}
+
+
+std::string MSwindows::getUserName()
+{
+    const DWORD bufferSize = 256;
+    TCHAR buffer[bufferSize];
+    DWORD actualBufferSize = bufferSize;
+    std::string nameAsString;
+
+    bool success = ::GetUserName(buffer, &actualBufferSize);
+
+    if (success)
+    {
+        nameAsString = buffer;
+    }
+    else 
+    {
+        if (ERROR_INSUFFICIENT_BUFFER == ::GetLastError() &&
+            32768 > actualBufferSize) 
+        {
+            AutoArray<TCHAR> actualBuffer(actualBufferSize);
+            ::GetUserName(actualBuffer.get(), &actualBufferSize);
+            nameAsString = actualBuffer.get();
+        }
+    }
+
+    return nameAsString;
+}
+
+
+template<class T>
+inline
+MSwindows::AutoArray<T>::AutoArray(const unsigned long arrayLength)
+    : array_(new T[arrayLength])
+{}
+
+
+template<class T>
+inline
+MSwindows::AutoArray<T>::~AutoArray()
+{
+    delete [] array_;
+}
+
+
+template<class T>
+inline
+T* MSwindows::AutoArray<T>::get()
+{
+    return array_;
+}
+
+
+inline
+bool MSwindows::DirectoryIterator::isValid() const
+{
+    const bool valid = (INVALID_HANDLE_VALUE != findHandle_);
+    return valid;
+}
+
+    
+MSwindows::DirectoryIterator::DirectoryIterator(const fileName & directory)
+{
+    const fileName directoryContents = directory/"*";
+    findHandle_ = ::FindFirstFile(directoryContents.c_str(), &findData_);
+    hasMore_    = isValid();
+}
+        
+
+MSwindows::DirectoryIterator::~DirectoryIterator()
+{
+    if (isValid()) 
+    {
+        ::FindClose(findHandle_);
+    }
+}
+
+
+inline
+bool MSwindows::DirectoryIterator::hasNext() const
+{
+    assert(isValid());
+
+    return hasMore_;
+}
+
+
+inline
+const fileName & MSwindows::DirectoryIterator::next()
+{
+    assert(hasNext());
+
+    nextName_ = findData_.cFileName;
+    hasMore_  = ::FindNextFile(findHandle_, &findData_);
+
+    return nextName_;
+}
+
+
+PID_T pid()
+{
+    const DWORD processId = ::GetCurrentProcessId();
+    return processId;
+}
+
+
+PID_T ppid()
+{
+    // No equivalent under windows.
+
+    if (MSwindows::debug)
+    {
+        Info<< "ppid not supported under MSwindows" << endl;
+    }
+
+    return 0;
+}
+
+
+PID_T pgid()
+{
+    // No equivalent under windows.
+
+    if (MSwindows::debug)
+    {
+        Info<< "pgid not supported under MSwindows" << endl;
+    }
+
+    return 0;
+}
+
+
+bool env(const word& envName)
+{
+    const DWORD actualBufferSize = 
+      ::GetEnvironmentVariable(envName.c_str(), NULL, 0);
+
+    const bool envExists = (0 < actualBufferSize);
+    return envExists;
+}
+
+
+string getEnv(const word& envName)
+{
+    std::string envAsString;
+
+    const DWORD actualBufferSize = 
+      ::GetEnvironmentVariable(envName.c_str(), NULL, 0);
+
+    if (0 < actualBufferSize) 
+    {
+        MSwindows::AutoArray<TCHAR> actualBuffer(actualBufferSize);
+        ::GetEnvironmentVariable(envName.c_str(),
+                                 actualBuffer.get(),
+                                 actualBufferSize);
+        envAsString = actualBuffer.get();
+	toUnixPath(envAsString);
+    }
+
+    return envAsString;
+}
+
+
+bool setEnv
+(
+    const word& envName,
+    const std::string& value,
+    const bool /*overwrite*/
+)
+{
+    const bool success = 
+      ::SetEnvironmentVariable(envName.c_str(), value.c_str());
+    return success;
+}
+
+
+string hostName(const bool full)
+{
+    const DWORD bufferSize = MAX_COMPUTERNAME_LENGTH + 1;
+    TCHAR buffer[bufferSize];
+    DWORD actualBufferSize = bufferSize;
+
+    const bool success = 
+      ::GetComputerName(buffer, &actualBufferSize);
+    const string computerName = success ? buffer : string::null;
+    return computerName;
+}
+
+
+string domainName()
+{
+    // Could use ::gethostname and ::gethostbyname like POSIX.C, but would
+    // then need to link against ws_32. Prefer to minimize dependencies.
+
+    return string::null;
+}
+
+
+string userName()
+{
+    string name = getEnv("USERNAME");
+
+    if (name.empty()) 
+    {
+        name = MSwindows::getUserName();
+    }
+
+    return name;
+}
+
+
+bool isAdministrator()
+{
+    // Not supported but assume worst case for Foam::dynamicCode::checkSecurity
+    return true;
+}
+
+
+fileName home()
+{
+    std::string homeDir = getEnv("HOME");
+
+    if (homeDir.empty()) 
+    {
+        homeDir = getEnv("USERPROFILE");
+    }
+
+    return homeDir;
+}
+
+
+fileName home(const string& userName)
+{
+    return home();
+}
+
+
+fileName cwd()
+{
+    string currentDirectory;
+
+    const DWORD actualBufferSize = 
+      ::GetCurrentDirectory(0, NULL);
+
+    if (0 < actualBufferSize) 
+    {
+        MSwindows::AutoArray<TCHAR> actualBuffer(actualBufferSize);
+        ::GetCurrentDirectory(actualBufferSize,
+                              actualBuffer.get());   
+        currentDirectory = actualBuffer.get();
+        MSwindows::toUnixSlash(currentDirectory);
+    }
+    else 
+    {
+        FatalErrorIn("cwd()")
+            << "Couldn't get the current working directory"
+            << exit(FatalError);
+    }
+
+    return currentDirectory;
+}
+
+
+bool chDir(const fileName& dir)
+{
+    const bool success = ::SetCurrentDirectory(dir.c_str());
+    return success; 
+}
+
+
+fileNameList findEtcFiles
+(
+    const fileName& name,
+    bool mandatory,
+    bool findFirst
+)
+{
+    fileNameList results;
+
+    // Search for user files in
+    // * ~/.OpenFOAM/VERSION
+    // * ~/.OpenFOAM
+    //
+    fileName searchDir = home()/".OpenFOAM";
+    if (isDir(searchDir))
+    {
+        fileName fullName = searchDir/FOAMversion/name;
+        if (isFile(fullName))
+        {
+            results.append(fullName);
+            if (findFirst)
+            {
+                return results;
+            }
+        }
+
+        fullName = searchDir/name;
+        if (isFile(fullName))
+        {
+            results.append(fullName);
+            if (findFirst)
+            {
+                return results;
+            }
+        }
+    }
+
+    // Search for group (site) files in
+    // * $WM_PROJECT_SITE/VERSION
+    // * $WM_PROJECT_SITE
+    //
+    searchDir = getEnv("WM_PROJECT_SITE");
+    if (searchDir.size())
+    {
+        if (isDir(searchDir))
+        {
+            fileName fullName = searchDir/FOAMversion/name;
+            if (isFile(fullName))
+            {
+                results.append(fullName);
+                if (findFirst)
+                {
+                    return results;
+                }
+            }
+
+            fullName = searchDir/name;
+            if (isFile(fullName))
+            {
+                results.append(fullName);
+                if (findFirst)
+                {
+                    return results;
+                }
+            }
+        }
+    }
+    else
+    {
+        // OR search for group (site) files in
+        // * $WM_PROJECT_INST_DIR/site/VERSION
+        // * $WM_PROJECT_INST_DIR/site
+        //
+        searchDir = getEnv("WM_PROJECT_INST_DIR");
+        if (isDir(searchDir))
+        {
+            fileName fullName = searchDir/"site"/FOAMversion/name;
+            if (isFile(fullName))
+            {
+                results.append(fullName);
+                if (findFirst)
+                {
+                    return results;
+                }
+            }
+
+            fullName = searchDir/"site"/name;
+            if (isFile(fullName))
+            {
+                results.append(fullName);
+                if (findFirst)
+                {
+                    return results;
+                }
+            }
+        }
+    }
+
+    // Search for other (shipped) files in
+    // * $WM_PROJECT_DIR/etc
+    //
+    searchDir = getEnv("WM_PROJECT_DIR");
+    if (isDir(searchDir))
+    {
+        fileName fullName = searchDir/"etc"/name;
+        if (isFile(fullName))
+        {
+            results.append(fullName);
+            if (findFirst)
+            {
+                return results;
+            }
+        }
+    }
+
+    // Not found
+    if (results.empty())
+    {
+        // Abort if the file is mandatory, otherwise return null
+        if (mandatory)
+        {
+            std::cerr
+                << "--> FOAM FATAL ERROR in Foam::findEtcFiles() :"
+                   " could not find mandatory file\n    '"
+                << name.c_str() << "'\n\n" << std::endl;
+            ::exit(1);
+        }
+    }
+
+    // Return list of matching paths or empty list if none found
+    return results;
+}
+
+
+fileName findEtcFile(const fileName& name, bool mandatory)
+{
+    // Search most likely location first
+    // Search installation files:
+    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
+    fileName searchDir = getEnv("WM_PROJECT_DIR");
+    if (isDir(searchDir))
+    {
+        // Check for shipped OpenFOAM file in $WM_PROJECT_DIR/etc
+        fileName fullName = searchDir/"etc"/name;
+        if (isFile(fullName))
+        {
+            return fullName;
+        }
+    }
+
+    // Search user files:
+    // ~~~~~~~~~~~~~~~~~~
+    searchDir = home()/".OpenFOAM";
+    if (isDir(searchDir))
+    {
+        // Check for user file in ~/.OpenFOAM/VERSION
+        fileName fullName = searchDir/FOAMversion/name;
+        if (isFile(fullName))
+        {
+            return fullName;
+        }
+
+        // Check for version-independent user file in ~/.OpenFOAM
+        fullName = searchDir/name;
+        if (isFile(fullName))
+        {
+            return fullName;
+        }
+    }
+
+
+    // Search site files:
+    // ~~~~~~~~~~~~~~~~~~
+    searchDir = getEnv("WM_PROJECT_INST_DIR");
+    if (isDir(searchDir))
+    {
+        // Check for site file in $WM_PROJECT_INST_DIR/site/VERSION
+        fileName fullName = searchDir/"site"/FOAMversion/name;
+        if (isFile(fullName))
+        {
+            return fullName;
+        }
+
+        // Check for version-independent site file in $WM_PROJECT_INST_DIR/site
+        fullName = searchDir/"site"/name;
+        if (isFile(fullName))
+        {
+            return fullName;
+        }
+    }
+
+    // Not found
+    // abort if the file is mandatory, otherwise return null
+    if (mandatory)
+    {
+        cerr<< "--> FOAM FATAL ERROR in Foam::findEtcFile() :"
+               " could not find mandatory file\n    '"
+            << name.c_str() << "'\n\n" << std::endl;
+        ::exit(1);
+    }
+
+    // Return null-constructed fileName rather than fileName::null
+    // to avoid cyclic dependencies in the construction of globals
+    return fileName();
+}
+
+
+bool mkDir(const fileName& pathName, const mode_t mode)
+{
+    if (pathName.empty())
+    {
+        return false;
+    }
+
+
+    bool success = ::CreateDirectory(pathName.c_str(), NULL);
+
+    if (success)
+    {
+        chMod(pathName, mode);
+    }
+    else 
+    {
+        const DWORD error = ::GetLastError();
+
+        switch (error)
+        {
+            case ERROR_ALREADY_EXISTS:
+            {
+                success = true;
+                break;
+            }
+            case ERROR_PATH_NOT_FOUND:
+            {
+                // Part of the path does not exist so try to create it
+                const fileName& parentName = pathName.path();
+
+                if (parentName.size() && mkDir(parentName, mode))
+                {
+                    success = mkDir(pathName, mode);
+                }
+                
+                break;
+            }  
+        }
+
+        if (!success) 
+        {
+            FatalErrorIn("mkDir(const fileName&, mode_t)")
+              << "Couldn't create directory: " << pathName
+              << " " << MSwindows::getLastError()
+              << exit(FatalError);
+        }
+    }
+
+    return success;
+}
+
+
+// Set the file mode
+bool chMod(const fileName& name, const mode_t m)
+{
+    const int success = _chmod(name.c_str(), m);
+    return success;
+}
+
+
+// Return the file mode
+mode_t mode(const fileName& name)
+{
+    fileStat fileStatus(name);
+
+    const mode_t m = fileStatus.isValid() ?
+      fileStatus.status().st_mode : 0;
+    return m;
+}
+
+
+// Return the file type: FILE or DIRECTORY
+fileName::Type type(const fileName& name)
+{
+    fileName::Type fileType = fileName::UNDEFINED;
+    const DWORD attrs = ::GetFileAttributes(name.c_str());
+
+    if (attrs != INVALID_FILE_ATTRIBUTES) 
+    {
+        fileType = (attrs & FILE_ATTRIBUTE_DIRECTORY) ?
+	  fileName::DIRECTORY :
+	  fileName::FILE;
+    }
+
+    return fileType;
+}
+
+
+static
+bool 
+isGzFile(const fileName& name)
+{
+    std::string gzName(name);
+    gzName += ".gz";
+    const DWORD attrs = ::GetFileAttributes(gzName.c_str());
+    const bool success = (attrs != INVALID_FILE_ATTRIBUTES);
+
+    return success;
+}
+
+
+// Does the name exist in the filing system?
+bool exists(const fileName& name, const bool checkGzip)
+{
+    const DWORD attrs = ::GetFileAttributes(name.c_str());
+    const bool success = (attrs != INVALID_FILE_ATTRIBUTES) || 
+                         (checkGzip && isGzFile(name));
+
+    return success;
+}
+
+
+// Does the directory exist
+bool isDir(const fileName& name)
+{
+    const DWORD attrs = ::GetFileAttributes(name.c_str());
+    bool success = (attrs != INVALID_FILE_ATTRIBUTES) &&
+                   (attrs & FILE_ATTRIBUTE_DIRECTORY);
+
+    return success;
+}
+
+
+// Does the file exist
+bool isFile(const fileName& name, const bool checkGzip)
+{
+    const DWORD attrs = ::GetFileAttributes(name.c_str());
+    const bool success = ((attrs != INVALID_FILE_ATTRIBUTES) && 
+			  !(attrs & FILE_ATTRIBUTE_DIRECTORY)) || 
+                         (checkGzip && isGzFile(name));
+
+    return success;
+}
+
+
+// Return size of file
+off_t fileSize(const fileName& name)
+{
+    fileStat fileStatus(name);
+
+    const off_t fileSize = fileStatus.isValid() ?
+      fileStatus.status().st_size : -1;
+    return fileSize;
+}
+
+
+// Return time of last file modification
+time_t lastModified(const fileName& name)
+{
+    fileStat fileStatus(name);
+
+    const time_t modifiedTime = fileStatus.isValid() ?
+      fileStatus.status().st_mtime : 0;
+    return modifiedTime;
+}
+
+
+// Read a directory and return the entries as a string list
+fileNameList readDir
+(
+    const fileName& directory,
+    const fileName::Type type,
+    const bool filtergz
+)
+{
+    // Initial filename list size
+    // also used as increment if initial size found to be insufficient
+    const int maxNnames = 100;
+
+    if (MSwindows::debug)
+    {
+        Info<< "readDir(const fileName&, const fileType, const bool filtergz)"
+            << " : reading directory " << directory << endl;
+    }
+
+    // Setup empty string list MAXTVALUES long
+    fileNameList dirEntries(maxNnames);
+
+    // Temporary variables and counters
+    label nEntries = 0;
+
+    MSwindows::DirectoryIterator dirIt(directory);
+
+    if (dirIt.isValid())
+    {
+        while (dirIt.hasNext())
+        {
+            const fileName & fName = dirIt.next();
+
+            // ignore files begining with ., i.e. '.', '..' and '.*'
+            if (fName.size() > 0 && fName[size_t(0)] != '.')
+            {
+                word fileNameExt = fName.ext();
+
+                if
+                (
+                    (type == fileName::DIRECTORY)
+                 ||
+                    (
+                        type == fileName::FILE
+                        && fName[fName.size()-1] != '~'
+                        && fileNameExt != "bak"
+                        && fileNameExt != "BAK"
+                        && fileNameExt != "old"
+                        && fileNameExt != "save"
+                    )
+                )
+                {
+                    if ((directory/fName).type() == type)
+                    {
+                        if (nEntries >= dirEntries.size())
+                        {
+                            dirEntries.setSize(dirEntries.size() + maxNnames);
+                        }
+
+                        if (filtergz && fileNameExt == "gz")
+                        {
+                            dirEntries[nEntries++] = fName.lessExt();
+                        }
+                        else
+                        {
+                            dirEntries[nEntries++] = fName;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else if (MSwindows::debug)
+    {
+        Info<< "readDir(const fileName&, const fileType, "
+               "const bool filtergz) : cannot open directory "
+            << directory << endl;
+    }
+
+    // Reset the length of the entries list
+    dirEntries.setSize(nEntries);
+    
+    return dirEntries;
+}
+
+
+// Copy, recursively if necessary, the source top the destination
+bool cp(const fileName& src, const fileName& dest)
+{
+    // Make sure source exists.
+    if (!exists(src))
+    {
+        return false;
+    }
+
+    fileName destFile(dest);
+
+    // Check type of source file.
+    if (src.type() == fileName::FILE)
+    {
+        // If dest is a directory, create the destination file name.
+        if (destFile.type() == fileName::DIRECTORY)
+        {
+            destFile = destFile/src.name();
+        }
+
+        // Make sure the destination directory exists.
+        if (!isDir(destFile.path()) && !mkDir(destFile.path()))
+        {
+            return false;
+        }
+
+        // Open and check streams.
+        // Use binary mode in case we read binary.
+        // Causes windows reading to fail if we don't.
+        std::ifstream srcStream(src.c_str(), 
+                                ios_base::in|ios_base::binary);      
+        if (!srcStream) 
+        {
+            return false;
+        }
+
+        // Use binary mode in case we write binary.
+        // Causes windows reading to fail if we don't.
+        std::ofstream destStream(destFile.c_str(), 
+                                 ios_base::out|ios_base::binary);
+        if (!destStream)
+        {
+            return false;
+        }
+
+        // Copy character data.
+        char ch;
+        while (srcStream.get(ch))
+        {
+            destStream.put(ch);
+        }
+
+        // Final check.
+        if (!srcStream.eof() || !destStream)
+        {
+            return false;
+        }
+    }
+    else if (src.type() == fileName::DIRECTORY)
+    {
+        // If dest is a directory, create the destination file name.
+        if (destFile.type() == fileName::DIRECTORY)
+        {
+            destFile = destFile/src.component(src.components().size() -1);
+        }
+
+        // Make sure the destination directory extists.
+        if (!isDir(destFile) && !mkDir(destFile))
+        {
+            return false;
+        }
+
+        // Copy files
+        fileNameList contents = readDir(src, fileName::FILE, false);
+        forAll(contents, i)
+        {
+            if (MSwindows::debug)
+            {
+                Info<< "Copying : " << src/contents[i] 
+                    << " to " << destFile/contents[i] << endl;
+            }
+
+            // File to file.
+            cp(src/contents[i], destFile/contents[i]);
+        }
+
+        // Copy sub directories.
+        fileNameList subdirs = readDir(src, fileName::DIRECTORY);
+        forAll(subdirs, i)
+        {
+            if (MSwindows::debug)
+            {
+                Info<< "Copying : " << src/subdirs[i]
+                    << " to " << destFile << endl;
+            }
+
+            // Dir to Dir.
+            cp(src/subdirs[i], destFile);
+        }
+    }
+
+    return true;
+}
+
+
+// Create a softlink. destFile should not exist. Returns true if successful.
+bool ln(const fileName& src, const fileName& dest)
+{
+    // Seems that prior to Vista softlinking was poorly supported.
+    // Vista does a better job, but requires adminstrator privileges.
+    // Skip for now.
+
+    if (MSwindows::debug)
+    {
+        Info<< "MSwindows does not support ln - softlinking" << endl;
+    }
+
+    return false;
+}
+
+
+// Rename srcFile destFile
+bool mv(const fileName& srcFile, const fileName& destFile)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "Move : " << srcFile << " to " << destFile << endl;
+    }
+
+    const fileName destName = 
+      ((destFile.type() == fileName::DIRECTORY)
+       && (srcFile.type() != fileName::DIRECTORY)) ?
+      destFile/srcFile.name() :
+      destFile;
+
+    const bool success = 
+      (0 == std::rename(srcFile.c_str(), destName.c_str()));
+
+    return success;
+}
+
+
+//- Rename to a corresponding backup file
+//  If the backup file already exists, attempt with "01" .. "99" index
+bool mvBak(const fileName& src, const std::string& ext)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "mvBak : " << src << " to extension " << ext << endl;
+    }
+
+    if (exists(src, false))
+    {
+        const int maxIndex = 99;
+        char index[3];
+
+        for (int n = 0; n <= maxIndex; n++)
+        {
+            fileName dstName(src + "." + ext);
+            if (n)
+            {
+                sprintf(index, "%02d", n);
+                dstName += index;
+            }
+
+            // avoid overwriting existing files, except for the last
+            // possible index where we have no choice
+            if (!exists(dstName, false) || n == maxIndex)
+            {
+                return (0 == std::rename(src.c_str(), dstName.c_str()));
+            }
+
+        }
+    }
+
+    // fall-through: nothing to do
+    return false;
+}
+
+
+// Remove a file returning true if successful otherwise false
+bool rm(const fileName& file)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "Removing : " << file << endl;
+    }
+
+    bool success = (0 == std::remove(file.c_str()));
+
+    // If deleting plain file name failed try with .gz
+    if (!success) 
+    {
+        const std::string fileGz = file + ".gz";
+        success = (0 == std::remove(fileGz.c_str()));
+    }
+
+    return success;
+}
+
+
+// Remove a dirctory and it's contents
+bool rmDir(const fileName& directory)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "rmdir(const fileName&) : "
+            << "removing directory " << directory << endl;
+    }
+
+    bool success = true;
+
+    // Need to destroy DirectorIterator prior to
+    // removing directory otherwise fails on Windows XP
+    {
+      MSwindows::DirectoryIterator dirIt(directory);
+
+      while (success && dirIt.hasNext())
+      {
+          const fileName & fName = dirIt.next(); 
+
+          if (fName != "." && fName != "..")
+          {
+              fileName path = directory/fName;
+
+              if (path.type() == fileName::DIRECTORY)
+              {
+                  success = rmDir(path);
+
+                  if (!success)
+                  {
+                      WarningIn("rmdir(const fileName&)")
+                        << "failed to remove directory " << fName
+                        << " while removing directory " << directory
+                        << endl;
+                  }
+              }
+              else
+              {
+                  success = rm(path);
+
+                  if (!success)
+                  {
+                      WarningIn("rmdir(const fileName&)")
+                        << "failed to remove file " << fName
+                        << " while removing directory " << directory
+                        << endl;
+                  }
+              }
+          }
+      }
+    }
+        
+    if (success) 
+    {
+        success = ::RemoveDirectory(directory.c_str());
+
+        if (!success) 
+        {
+            WarningIn("rmdir(const fileName&)")
+                << "failed to remove directory " << directory << endl;
+        }
+    }
+
+    return success;
+}
+
+
+//- Sleep for the specified number of seconds
+unsigned int sleep(const unsigned int s)
+{
+    const DWORD milliseconds = s * 1000;
+
+    ::Sleep(milliseconds);
+
+    return 0;
+}
+
+
+void fdClose(const int fd)
+{
+    const int result = ::_close(fd);
+
+    if (0 != result)
+    {
+        FatalErrorIn
+        (
+            "Foam::fdClose(const int fd)"
+        )   << "close error on " << fd << endl
+            << abort(FatalError);    
+    }
+}
+
+
+//- Check if machine is up by pinging given port
+bool ping
+(
+    const word& destName,
+    const label destPort,
+    const label timeOut
+)
+{
+    // Appears that socket calls require adminstrator privileges.
+    // Skip for now.
+
+    if (MSwindows::debug)
+    {
+        Info<< "MSwindows does not support ping" << endl;
+    }
+
+    return false;
+}
+
+
+//- Check if machine is up by ping port 22 = ssh and 222 = rsh
+bool ping(const word& hostname, const label timeOut)
+{
+    return ping(hostname, 222, timeOut) || ping(hostname, 22, timeOut);
+}
+
+
+int system(const std::string& command)
+{
+    return std::system(command.c_str());
+}
+
+
+// Explicitly track loaded libraries, rather than use
+// EnumerateLoadedModules64 and have to link against 
+// Dbghelp.dll
+// Details at http://msdn.microsoft.com/en-us/library/ms679316(v=vs.85).aspx
+typedef std::map<void*, std::string> OfLoadedLibs;
+
+static
+OfLoadedLibs &
+getLoadedLibs()
+{
+  static OfLoadedLibs loadedLibs;
+  return loadedLibs;
+}
+
+
+//- Open shared library
+void* dlOpen(const fileName& libName, const bool check)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "dlOpen(const fileName&)"
+            << " : LoadLibrary of " << libName << endl;
+    }
+
+    const char* dllExt = ".dll";
+
+    // Assume libName is of the form, lib<name>.so
+    string winLibName(libName);
+    winLibName.replace(".so", dllExt);
+    void* handle = ::LoadLibrary(winLibName.c_str());
+
+    if (NULL == handle)
+    {
+        // Assumes libName = name
+        winLibName = "lib";
+        winLibName += libName;
+        winLibName += dllExt;
+      
+        handle = ::LoadLibrary(winLibName.c_str());
+    }
+
+    if (NULL != handle) 
+    {
+        getLoadedLibs()[handle] = libName;
+    }
+    else if (check)
+    {
+        WarningIn("dlOpen(const fileName&, const bool)")
+            << "dlopen error : " << MSwindows::getLastError()
+            << endl;
+    }
+
+    if (MSwindows::debug)
+    {
+        Info<< "dlOpen(const fileName&)"
+            << " : LoadLibrary of " << libName
+            << " handle " << handle << endl;
+    }
+
+    return handle;
+}
+
+
+//- Close shared library
+bool dlClose(void* const handle)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "dlClose(void*)"
+            << " : FreeLibrary of handle " << handle << endl;
+    }
+
+    const bool success = 
+      ::FreeLibrary(static_cast<HMODULE>(handle));
+  
+    if (success)
+    {
+	getLoadedLibs().erase(handle);
+    }
+    
+    return success;
+}
+
+
+void* dlSym(void* handle, const std::string& symbol)
+{
+    if (MSwindows::debug)
+    {
+        Info<< "dlSym(void*, const std::string&)"
+            << " : GetProcAddress of " << symbol << endl;
+    }
+    // get address of symbol
+    void* fun = (void*) ::GetProcAddress(static_cast<HMODULE>(handle), symbol.c_str());
+
+    if (NULL == fun)
+    {
+        WarningIn("dlSym(void*, const std::string&)")
+	  << "Cannot lookup symbol " << symbol << " : " << MSwindows::getLastError()
+          << endl;
+    }
+
+    return fun;
+}
+
+
+bool dlSymFound(void* handle, const std::string& symbol)
+{
+    if (handle && !symbol.empty())
+    {
+        if (MSwindows::debug)
+        {
+            Info<< "dlSymFound(void*, const std::string&)"
+                << " : GetProcAddress of " << symbol << endl;
+        }
+
+       // get address of symbol
+	void* fun = (void*) ::GetProcAddress(static_cast<HMODULE>(handle), symbol.c_str());
+
+	return (NULL != fun);
+    }
+    else
+    {
+        return false;
+    }
+}
+
+
+fileNameList dlLoaded()
+{
+    fileNameList libs;
+    OfLoadedLibs & loadedLibs = getLoadedLibs();
+
+    for (OfLoadedLibs::const_iterator it = loadedLibs.begin();
+	 it != loadedLibs.end(); ++it)
+    {
+	libs.append(it->second);
+    }
+
+    if (MSwindows::debug)
+    {
+        Info<< "dlLoaded()"
+            << " : determined loaded libraries :" << libs.size() << endl;
+    }
+    return libs;
+}
+
+
+void osRandomSeed(const label seed)
+{
+  std::srand(seed);
+}
+
+
+label osRandomInteger()
+{
+  return std::rand();
+}
+
+
+scalar osRandomDouble()
+{
+  return scalar(std::rand())/RAND_MAX;
+}
+
+
+std::string toUnixPath(const std::string & path)
+{
+    string unixPath(path);
+    MSwindows::toUnixSlash(unixPath);
+    MSwindows::removeQuotes(unixPath);
+
+    return unixPath;
+}
+
+} // namespace Foam
+// ************************************************************************* //
--- src/OSspecific/MSwindows/fileMonitor.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/fileMonitor.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,158 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    fileMonitor
+
+Description
+    Checking for changes to files.
+
+Note
+    The default is to use stat to get the timestamp.
+
+    Compile with FOAM_USE_INOTIFY to use the inotify
+    (Linux specific, since 2.6.13) framework. The problem is that inotify does
+    not work on nfs3 mounted directories!!
+
+SourceFiles
+    fileMonitor.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef fileMonitor_H
+#define fileMonitor_H
+
+#include "NamedEnum.H"
+#include "className.H"
+#include "DynamicList.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+class fileMonitor;
+class fileMonitorWatcher;
+
+/*---------------------------------------------------------------------------*\
+                         Class fileMonitor Declaration
+\*---------------------------------------------------------------------------*/
+
+class fileMonitor
+{
+
+public:
+
+    // Public data types
+
+        //- Enumeration defining the file state.
+        enum fileState
+        {
+            UNMODIFIED = 0,
+            MODIFIED = 1,
+            DELETED = 2
+        };
+
+        static const NamedEnum<fileState, 3> fileStateNames_;
+
+private:
+    // Private data
+
+        //- Whether to use inotify (requires -DFOAM_USE_INOTIFY, see above)
+        const bool useInotify_;
+
+        //- State for all watchFds based on local files
+        mutable DynamicList<fileState> localState_;
+
+        //- State for all watchFds - synchronised
+        mutable DynamicList<fileState> state_;
+
+        //- Filename for all watchFds
+        DynamicList<fileName> watchFile_;
+
+        //- Free watchFds
+        DynamicList<label> freeWatchFds_;
+
+        //- Watch mechanism (stat or inotify)
+        mutable autoPtr<fileMonitorWatcher> watcher_;
+
+
+    // Private Member Functions
+
+        //- Update localState_ from any events.
+        void checkFiles() const;
+
+        //- Disallow default bitwise copy construct
+        fileMonitor(const fileMonitor&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const fileMonitor&);
+
+
+public:
+
+    // Declare name of the class and its debug switch
+    ClassName("fileMonitor");
+
+    // Constructors
+
+        //- Construct null
+        fileMonitor(const bool useInotify);
+
+
+    //- Destructor
+    ~fileMonitor();
+
+
+    // Member Functions
+
+        //- Add file to watch. Return watch descriptor
+        label addWatch(const fileName&);
+
+        //- Remove file to watch. Return true if successful
+        bool removeWatch(const label watchFd);
+
+        //- Get name of file being watched
+        const fileName& getFile(const label watchFd) const;
+
+        //- Check state using handle
+        fileState getState(const label watchFd) const;
+
+        //- Check state of all files. Updates state_.
+        void updateStates
+        (
+            const bool masterOnly,
+            const bool syncPar
+        ) const;
+
+        //- Reset state (e.g. after having read it) using handle
+        void setUnmodified(const label watchFd);
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/OSspecific/MSwindows/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,16 @@
+MSwindows.C
+printStack.C
+regExp.C
+signals/sigFpe.C
+signals/sigSegv.C
+signals/sigInt.C
+signals/sigQuit.C
+signals/sigStopAtWriteNow.C
+signals/sigWriteNow.C
+timer.C
+fileMonitor.C
+fileStat.C
+cpuTime/cpuTime.C
+clockTime/clockTime.C
+
+LIB = $(FOAM_LIBBIN)/libOSspecific
--- src/OSspecific/MSwindows/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ src/OSspecific/MSwindows/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1 @@
+
--- src/gpu/gpuless/PBiCGgpu.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/PBiCGgpu.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,59 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "PBiCGgpu.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineTypeNameAndDebug(PBiCGgpu, 0);
+
+    lduMatrix::solver::addasymMatrixConstructorToTable<PBiCGgpu>
+        addPBiCGgpuAsymMatrixConstructorToTable_;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::PBiCGgpu::PBiCGgpu
+(
+    const word& fieldName,
+    const lduMatrix& matrix,
+    const FieldField<Field, scalar>& interfaceBouCoeffs,
+    const FieldField<Field, scalar>& interfaceIntCoeffs,
+    const lduInterfaceFieldPtrsList& interfaces,
+    const dictionary& solverControls
+)
+:
+    PBiCG
+    (
+        fieldName,
+        matrix,
+        interfaceBouCoeffs,
+        interfaceIntCoeffs,
+        interfaces,
+        solverControls
+    )
+{}
+
+// ************************************************************************* //
--- src/gpu/gpuless/PBiCGgpu.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/PBiCGgpu.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,89 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::PBiCGgpu
+
+Description
+    CPU-based preconditioned bi-conjugate gradient solver for asymmetric lduMatrices
+    using a run-time selectable preconditiioner, identical to PBiCG.
+
+SourceFiles
+    PBiCGgpu.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef PBiCGgpu_H
+#define PBiCGgpu_H
+
+#include "PBiCG.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class PBiCGgpu Declaration
+\*---------------------------------------------------------------------------*/
+
+class PBiCGgpu
+:
+    public PBiCG
+{
+    // Private Member Functions
+
+        //- Disallow default bitwise copy construct
+        PBiCGgpu(const PBiCGgpu&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const PBiCGgpu&);
+
+
+public:
+
+    //- Runtime type information
+    TypeName("PBiCGgpu");
+
+
+    // Constructors
+
+        //- Construct from matrix components and solver data stream
+        PBiCGgpu
+        (
+            const word& fieldName,
+            const lduMatrix& matrix,
+            const FieldField<Field, scalar>& interfaceBouCoeffs,
+            const FieldField<Field, scalar>& interfaceIntCoeffs,
+            const lduInterfaceFieldPtrsList& interfaces,
+            const dictionary& solverControls
+        );
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/gpu/gpuless/PCGgpu.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/PCGgpu.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,59 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "PCGgpu.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineTypeNameAndDebug(PCGgpu, 0);
+
+    lduMatrix::solver::addsymMatrixConstructorToTable<PCGgpu>
+        addPCGgpuAsymMatrixConstructorToTable_;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::PCGgpu::PCGgpu
+(
+    const word& fieldName,
+    const lduMatrix& matrix,
+    const FieldField<Field, scalar>& interfaceBouCoeffs,
+    const FieldField<Field, scalar>& interfaceIntCoeffs,
+    const lduInterfaceFieldPtrsList& interfaces,
+    const dictionary& solverControls
+)
+:
+    PCG
+    (
+        fieldName,
+        matrix,
+        interfaceBouCoeffs,
+        interfaceIntCoeffs,
+        interfaces,
+        solverControls
+    )
+{}
+
+// ************************************************************************* //
--- src/gpu/gpuless/PCGgpu.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/PCGgpu.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,89 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::PCGgpu
+
+Description
+    CPU-based preconditioned conjugate gradient solver for symmetric lduMatrices
+    using a run-time selectable preconditiioner, identical to PCG.
+
+SourceFiles
+    PCGgpu.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef PCGgpu_H
+#define PCGgpu_H
+
+#include "PCG.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class PCGgpu Declaration
+\*---------------------------------------------------------------------------*/
+
+class PCGgpu
+:
+    public PCG
+{
+    // Private Member Functions
+
+        //- Disallow default bitwise copy construct
+        PCGgpu(const PCGgpu&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const PCGgpu&);
+
+
+public:
+
+    //- Runtime type information
+    TypeName("PCGgpu");
+
+
+    // Constructors
+
+        //- Construct from matrix components and solver data stream
+        PCGgpu
+        (
+            const word& fieldName,
+            const lduMatrix& matrix,
+            const FieldField<Field, scalar>& interfaceBouCoeffs,
+            const FieldField<Field, scalar>& interfaceIntCoeffs,
+            const lduInterfaceFieldPtrsList& interfaces,
+            const dictionary& solverControls
+        );
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/gpu/gpuless/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,4 @@
+PBiCGgpu.C
+PCGgpu.C
+
+LIB = $(FOAM_LIBBIN)/gpuless/libgpu
--- src/gpu/gpuless/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/gpuless/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1 @@
+
--- src/gpu/cuda/PBiCGgpu.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/PBiCGgpu.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,105 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 by Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "ofgpu/pbicg.h"
+#include "ofgpu/sparsematrixargs.h"
+
+#include "PBiCGgpu.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineTypeNameAndDebug(PBiCGgpu, 0);
+
+    lduMatrix::solver::addasymMatrixConstructorToTable<PBiCGgpu>
+        addPBiCGgpuAsymMatrixConstructorToTable_;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::PBiCGgpu::PBiCGgpu
+(
+    const word& fieldName,
+    const lduMatrix& matrix,
+    const FieldField<Field, scalar>& interfaceBouCoeffs,
+    const FieldField<Field, scalar>& interfaceIntCoeffs,
+    const lduInterfaceFieldPtrsList& interfaces,
+    const dictionary& solverControls
+)
+:
+    PBiCG
+    (
+        fieldName,
+        matrix,
+        interfaceBouCoeffs,
+        interfaceIntCoeffs,
+        interfaces,
+        solverControls
+    )
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+Foam::solverPerformance Foam::PBiCGgpu::solve
+(
+    scalarField& psi,
+    const scalarField& source,
+    const direction cmpt
+) const
+{
+    scalar initialResidual(0.);
+    scalar finalResidual(0.);
+    label iterationsPerformed(0);
+    bool converged(false);
+
+    lduAddressing const & lduAddr = matrix_.lduAddr();
+    word const preconditionerName = lduMatrix::preconditioner::getName(controlDict_);
+
+    ofgpuPBiCGsolve(ofgpu::SparseMatrixArgs(preconditionerName.c_str(),
+					    psi.size(), lduAddr.lowerAddr().size(),
+					    lduAddr.losortStartAddr().begin(), lduAddr.losortAddr().begin(), lduAddr.lowerAddr().begin(), matrix_.lower().begin(), 
+					    matrix_.diag().begin(),
+					    lduAddr.ownerStartAddr().begin(), lduAddr.upperAddr().begin(), matrix_.upper().begin(),
+					    psi.begin(),
+					    source.begin(),
+					    maxIter_, tolerance_, relTol_,
+					    initialResidual, finalResidual, iterationsPerformed, converged));
+    
+    // --- Setup class containing solver performance data
+    solverPerformance solverPerf
+    (
+        preconditionerName + typeName,
+        fieldName_,
+	initialResidual,
+	finalResidual,
+	iterationsPerformed, 
+	converged
+    );
+
+
+    return solverPerf;
+}
+
+// ************************************************************************* //
--- src/gpu/cuda/PBiCGgpu.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/PBiCGgpu.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,101 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::PBiCGgpu
+
+Description
+    CPU-based preconditioned bi-conjugate gradient solver for asymmetric lduMatrices
+    using a run-time selectable preconditiioner, identical to PBiCG.
+
+SourceFiles
+    PBiCGgpu.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef PBiCGgpu_H
+#define PBiCGgpu_H
+
+#include "PBiCG.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class PBiCGgpu Declaration
+\*---------------------------------------------------------------------------*/
+
+class PBiCGgpu
+:
+    public PBiCG
+{
+    // Private Member Functions
+
+        //- Disallow default bitwise copy construct
+        PBiCGgpu(const PBiCGgpu&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const PBiCGgpu&);
+
+
+public:
+
+    //- Runtime type information
+    TypeName("PBiCGgpu");
+
+
+    // Constructors
+
+        //- Construct from matrix components and solver data stream
+        PBiCGgpu
+        (
+            const word& fieldName,
+            const lduMatrix& matrix,
+            const FieldField<Field, scalar>& interfaceBouCoeffs,
+            const FieldField<Field, scalar>& interfaceIntCoeffs,
+            const lduInterfaceFieldPtrsList& interfaces,
+            const dictionary& solverControls
+        );
+
+
+    // Member Functions
+
+        //- Solve the matrix with this solver
+        virtual solverPerformance solve
+        (
+            scalarField& psi,
+            const scalarField& source,
+            const direction cmpt=0
+        ) const;
+
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/gpu/cuda/PCGgpu.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/PCGgpu.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,104 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "ofgpu/pcg.h"
+#include "ofgpu/sparsematrixargs.h"
+
+#include "PCGgpu.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineTypeNameAndDebug(PCGgpu, 0);
+
+    lduMatrix::solver::addsymMatrixConstructorToTable<PCGgpu>
+        addPCGgpuAsymMatrixConstructorToTable_;
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::PCGgpu::PCGgpu
+(
+    const word& fieldName,
+    const lduMatrix& matrix,
+    const FieldField<Field, scalar>& interfaceBouCoeffs,
+    const FieldField<Field, scalar>& interfaceIntCoeffs,
+    const lduInterfaceFieldPtrsList& interfaces,
+    const dictionary& solverControls
+)
+:
+    PCG
+    (
+        fieldName,
+        matrix,
+        interfaceBouCoeffs,
+        interfaceIntCoeffs,
+        interfaces,
+        solverControls
+    )
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+Foam::solverPerformance Foam::PCGgpu::solve
+(
+    scalarField& psi,
+    const scalarField& source,
+    const direction cmpt
+) const
+{
+    scalar initialResidual(0.);
+    scalar finalResidual(0.);
+    label iterationsPerformed(0);
+    bool converged(false);
+
+    lduAddressing const & lduAddr = matrix_.lduAddr();
+    word const preconditionerName = lduMatrix::preconditioner::getName(controlDict_);
+
+    ofgpuPCGsolve(ofgpu::SparseMatrixArgs(preconditionerName.c_str(),
+					  psi.size(), lduAddr.lowerAddr().size(),
+					  lduAddr.losortStartAddr().begin(), lduAddr.losortAddr().begin(), lduAddr.lowerAddr().begin(), matrix_.lower().begin(), 
+					  matrix_.diag().begin(),
+					  lduAddr.ownerStartAddr().begin(), lduAddr.upperAddr().begin(), matrix_.upper().begin(),
+					  psi.begin(),
+					  source.begin(),
+					  maxIter_, tolerance_, relTol_,
+					  initialResidual, finalResidual, iterationsPerformed, converged));
+
+    // --- Setup class containing solver performance data
+    solverPerformance solverPerf
+    (
+        preconditionerName + typeName,
+        fieldName_,
+	initialResidual,
+	finalResidual,
+	iterationsPerformed,
+	converged
+    );
+
+    return solverPerf;
+}
+
+// ************************************************************************* //
--- src/gpu/cuda/cudaGpu.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/cudaGpu.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,58 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "ofgpu/ofgpuconfig.h"
+
+#include "cudaGpu.H"
+#include "addToRunTimeSelectionTable.H"
+#include "dictionary.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineTypeNameAndDebug(cudaGpu, 0);
+
+    addToRunTimeSelectionTable
+    (
+        functionObject,
+        cudaGpu,
+        dictionary
+    );
+}
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::cudaGpu::cudaGpu
+(
+ const word& name,
+ const Time&,
+ const dictionary& dict
+)
+  : 
+  functionObject(name)
+{
+  const label device = dict.lookupOrDefault<label>("cudaDevice", 0);
+  ofgpuConfig(device);
+}
+
+// ************************************************************************* //
--- src/gpu/cuda/PCGgpu.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/PCGgpu.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,101 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::PCGgpu
+
+Description
+    CPU-based preconditioned conjugate gradient solver for symmetric lduMatrices
+    using a run-time selectable preconditiioner, identical to PCG.
+
+SourceFiles
+    PCGgpu.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef PCGgpu_H
+#define PCGgpu_H
+
+#include "PCG.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+/*---------------------------------------------------------------------------*\
+                           Class PCGgpu Declaration
+\*---------------------------------------------------------------------------*/
+
+class PCGgpu
+:
+    public PCG
+{
+    // Private Member Functions
+
+        //- Disallow default bitwise copy construct
+        PCGgpu(const PCGgpu&);
+
+        //- Disallow default bitwise assignment
+        void operator=(const PCGgpu&);
+
+
+public:
+
+    //- Runtime type information
+    TypeName("PCGgpu");
+
+
+    // Constructors
+
+        //- Construct from matrix components and solver data stream
+        PCGgpu
+        (
+            const word& fieldName,
+            const lduMatrix& matrix,
+            const FieldField<Field, scalar>& interfaceBouCoeffs,
+            const FieldField<Field, scalar>& interfaceIntCoeffs,
+            const lduInterfaceFieldPtrsList& interfaces,
+            const dictionary& solverControls
+        );
+
+
+    // Member Functions
+
+        //- Solve the matrix with this solver
+        virtual solverPerformance solve
+        (
+            scalarField& psi,
+            const scalarField& source,
+            const direction cmpt=0
+        ) const;
+
+};
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/gpu/cuda/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,5 @@
+cudaGpu.C
+PBiCGgpu.C
+PCGgpu.C
+
+LIB = $(FOAM_GPU_LIBBIN)/libgpu
--- src/gpu/cuda/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,5 @@
+include $(RULES)/gpulib$(WM_GPU)
+
+EXE_INC  = $(GPUFLAGS) $(GPUINC)
+LIB_LIBS = $(GPULIBS)
+
--- src/gpu/cuda/cudaGpu.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/cuda/cudaGpu.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,111 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Typedef
+    Foam::cudaGpuFunctionObject
+
+Description
+    FunctionObject to initialize device and enable GPU linear solvers.
+
+@verbatim
+    functions
+    (
+      cudaGpu
+      {
+        // Type of functionObject
+        type cudaGpu;
+
+        // Where to load it from (if not already in solver)
+        functionObjectLibs ("gpu");
+
+	// CUDA Device Id
+        // Optional default = 0
+        // cudaDevice 2;            
+      }
+   );
+   @endverbatim
+
+SourceFiles
+    cudaGpu.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef cudaGpu_H
+#define cudaGpu_H
+
+#include "functionObject.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class cudaGpu : public functionObject
+  {
+    // Private Member Functions
+    
+    //- Disallow default bitwise copy construct
+    cudaGpu(const cudaGpu&);
+    
+    //- Disallow default bitwise assignment
+    void operator=(const cudaGpu&);
+
+  public:
+    //- Runtime type information
+    TypeName("cudaGpu");
+
+    // Constructors
+
+    //- Construct from components
+    cudaGpu
+    (
+     const word& name,
+     const Time&,
+     const dictionary&
+     );
+
+   // Member Functions
+
+    //- Called at the start of the time-loop
+    virtual bool start()
+    { return true; }
+
+    //- Called at each ++ or += of the time-loop
+    virtual bool execute(const bool forceWrite)
+    { return true; }
+
+    //- Read and set the function object if its data have changed
+    virtual bool read(const dictionary&)
+    { return true; }
+
+    //- Update for changes of mesh
+    virtual void updateMesh(const mapPolyMesh& mpm)
+    {}
+    
+    //- Update for changes of mesh
+    virtual void movePoints(const polyMesh& mesh)
+    {}
+  };
+}
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/gpu/Allwmake	(.../tags/2.2.x-2)	(revision 0)
+++ src/gpu/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,15 @@
+#!/bin/sh
+cd ${0%/*} || exit 1    # run from this directory
+makeType=${1:-libso}
+set -x
+
+wmake $makeType gpuless
+
+case "$WM_GPU" in
+*CUDA*)
+    (wmake $makeType cuda)
+    ;;
+esac
+
+
+# ----------------------------------------------------------------- end-of-file
--- src/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -16,17 +16,47 @@
 }
 
 set -x
+set -e
 
 # update OpenFOAM version strings if required
 wmakePrintBuild -check || /bin/rm -f OpenFOAM/Make/*/global.? 2>/dev/null
 
 wmakeLnInclude OpenFOAM
 wmakeLnInclude OSspecific/${WM_OSTYPE:-POSIX}
-Pstream/Allwmake $*
 
 OSspecific/${WM_OSTYPE:-POSIX}/Allwmake
+
+case $WM_COMPILER in
+*mingw* )
+    MINGW=TRUE
+
+    # Cyclic dependency with libOpenFOAM.dll, so link
+    # with objects on first pass
+    wmake libo Pstream/dummy
+    ;;
+* )
+    Pstream/Allwmake $*
+    ;;
+esac
+
 wmake $makeType OpenFOAM
 
+if [ "TRUE" = "$MINGW" ]; then
+    # Can now link against libOpenFOAM.dll
+    Pstream/Allwmake $*
+
+    # Force relink of libOpenFOAM.dll against libPstream.dll
+    touch OpenFOAM/global/global.Cver
+    export LINK_PLIB=TRUE
+    wmake $makeType OpenFOAM
+
+    # mingw excludes default compiler path so 
+    # missing /usr/include/FlexLexer.h for flex
+    cp /usr/include/FlexLexer.h "$FOAM_SRC/OpenFOAM/lnInclude/."
+fi
+
+gpu/Allwmake $*
+
 wmake $makeType fileFormats
 wmake $makeType surfMesh
 wmake $makeType triSurface
@@ -35,19 +65,24 @@
 
 # Decomposition methods needed by dummyThirdParty
 parallel/decompose/AllwmakeLnInclude
+
+if [ "TRUE" != "$MINGW" ]; then
+# Cyclic dependencies with decompositionMethods, so don't try building for MINGW
 # dummyThirdParty (dummy metisDecomp, scotchDecomp etc) needed by e.g. meshTools
 dummyThirdParty/Allwmake $*
+fi
 
 wmake $makeType finiteVolume
 wmake $makeType lagrangian/basic
-wmake $makeType lagrangian/distributionModels
-wmake $makeType genericPatchFields
 
 # Build the proper scotchDecomp, metisDecomp etc.
 parallel/Allwmake $*
 
 renumber/Allwmake $*
 
+wmake $makeType lagrangian/distributionModels
+wmake $makeType genericPatchFields
+
 wmake $makeType conversion
 
 wmake $makeType sampling
@@ -64,8 +99,14 @@
 thermophysicalModels/Allwmake $*
 transportModels/Allwmake $*
 turbulenceModels/Allwmake $*
+
+# Depends on RAS/turbulenceModels/compressible
+# hence not in thermophysicalModels
+wmake $makeType thermophysicalModels/chemistryModel
+wmake $makeType thermophysicalModels/solidChemistryModel
+regionModels/Allwmake $*
+
 wmake $makeType combustionModels
-regionModels/Allwmake $*
 lagrangian/Allwmake $*
 mesh/Allwmake $*
 
--- src/thermophysicalModels/basic/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/basic/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,6 @@
 
 
 LIB_LIBS = \
-    -lfiniteVolume
+    -lmeshTools \
+    -lfiniteVolume \
+    -lspecie
--- src/thermophysicalModels/reactionThermo/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/reactionThermo/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,6 +9,6 @@
 LIB_LIBS = \
     -lfiniteVolume \
     -lfluidThermophysicalModels \
-    -lspecie \
     -lsolidSpecie \
-    -lmeshTools
+    -lmeshTools \
+    -lspecie
--- src/thermophysicalModels/solidChemistryModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/solidChemistryModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -14,4 +14,7 @@
     -lchemistryModel \
     -lfiniteVolume \
     -lODE\
-    -lreactionThermophysicalModels
+    -lreactionThermophysicalModels \
+    -lspecie \
+    -lfluidThermophysicalModels \
+    -lsolidThermo
--- src/thermophysicalModels/SLGThermo/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/SLGThermo/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,4 +9,10 @@
     -I$(LIB_SRC)/thermophysicalModels/reactionThermo/lnInclude
 
 LIB_LIBS = \
-    -lfiniteVolume
+    -lfiniteVolume \
+    -lsolidProperties \
+    -lsolidMixtureProperties \
+    -lliquidProperties \
+    -lliquidMixtureProperties \
+    -lspecie \
+    -lfluidThermophysicalModels
--- src/thermophysicalModels/thermophysicalFunctions/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/thermophysicalFunctions/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1 @@
+LIB_LIBS =
--- src/thermophysicalModels/chemistryModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/chemistryModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,12 +5,14 @@
     -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude \
     -I$(LIB_SRC)/thermophysicalModels/functions/Polynomial \
     -I$(LIB_SRC)/thermophysicalModels/thermophysicalFunctions/lnInclude \
-    -I$(LIB_SRC)/turbulenceModels/compressible/lnInclude \
+    -I$(LIB_SRC)/turbulenceModels/RAS/compressible/lnInclude \
     -I$(LIB_SRC)/ODE/lnInclude
 
 LIB_LIBS = \
     -lfluidThermophysicalModels \
+    -lfiniteVolume \
     -lreactionThermophysicalModels \
     -lspecie \
     -lthermophysicalFunctions \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
     -lODE
--- src/thermophysicalModels/specie/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/specie/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1 @@
+LIB_LIBS =
--- src/thermophysicalModels/specie/thermo/thermo/thermo.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/specie/thermo/thermo/thermo.C	(.../branches/2.2.x-2)	(revision 831)
@@ -29,7 +29,7 @@
 /* * * * * * * * * * * * * * * private static data * * * * * * * * * * * * * */
 
 template<class Thermo, template<class> class Type>
-const Foam::scalar Foam::species::thermo<Thermo, Type>::tol_ = 1.0e-4;
+const Foam::scalar Foam::species::thermo<Thermo, Type>::tol_ = 1.0e-3;
 
 template<class Thermo, template<class> class Type>
 const int Foam::species::thermo<Thermo, Type>::maxIter_ = 100;
--- src/thermophysicalModels/laminarFlameSpeed/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/laminarFlameSpeed/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -5,4 +5,7 @@
     -I$(LIB_SRC)/thermophysicalModels/reactionThermo/lnInclude
 
 LIB_LIBS = \
-    -lfiniteVolume
+    -lfiniteVolume \
+    -lspecie \
+    -lfluidThermophysicalModels \
+    -lreactionThermophysicalModels
--- src/thermophysicalModels/properties/liquidMixtureProperties/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/properties/liquidMixtureProperties/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,6 +6,8 @@
     -I$(LIB_SRC)/thermophysicalModels/thermophysicalFunctions/lnInclude
 
 LIB_LIBS = \
+    -lfluidThermophysicalModels \
+    -lspecie \
     -lliquidProperties \
     -lthermophysicalFunctions
 
--- src/thermophysicalModels/properties/solidMixtureProperties/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/properties/solidMixtureProperties/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -1,3 +1,6 @@
 EXE_INC = \
     -I${LIB_SRC}/thermophysicalModels/properties/solidProperties/lnInclude \
     -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude
+
+LIB_LIBS = \
+    -lsolidProperties
--- src/thermophysicalModels/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -6,18 +6,22 @@
 wmake $makeType specie
 wmake $makeType solidSpecie
 wmake $makeType thermophysicalFunctions
-./properties/Allwmake $*
 
 wmake $makeType basic
 wmake $makeType reactionThermo
 wmake $makeType laminarFlameSpeed
-wmake $makeType chemistryModel
+
+# Can't build here as chemistryModel depends on RAS/turbulenceModels/compressible
+# wmake $makeType chemistryModel
 wmake $makeType barotropicCompressibilityModel
+
+# Depends on basic above
+./properties/Allwmake $*
+
 wmake $makeType SLGThermo
 
 
 wmake $makeType solidThermo
-wmake $makeType solidChemistryModel
 
 wmake $makeType radiationModels
 
--- src/thermophysicalModels/radiationModels/include/createIncompressibleRadiationModel.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/thermophysicalModels/radiationModels/include/createIncompressibleRadiationModel.H	(.../branches/2.2.x-2)	(revision 831)
@@ -26,7 +26,8 @@
         );
 
         dimensionedScalar rhoRef(transportProperties.lookup("rhoRef"));
-        dimensionedScalar CpRef(transportProperties.lookup("CpRef"));
+	// RJS 10/9/13 Prefer Cp over original CpRef for compatiblity with Cp in thermophysicalProperties
+        dimensionedScalar CpRef(transportProperties.lookup("Cp"));
 
         rhoCpRef = rhoRef*CpRef;
     }
--- src/dynamicMesh/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/dynamicMesh/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -6,5 +6,6 @@
 
 LIB_LIBS = \
     -lfiniteVolume \
+    -lextrudeModel \
     -ltriSurface \
-    -lextrudeModel
+    -lmeshTools
--- src/lagrangian/basic/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/lagrangian/basic/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,4 +3,5 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 LIB_LIBS = \
-    -lmeshTools
+    -lmeshTools \
+    -lfiniteVolume
--- src/lagrangian/distributionModels/distributionModel/distributionModel.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/lagrangian/distributionModels/distributionModel/distributionModel.C	(.../branches/2.2.x-2)	(revision 831)
@@ -27,6 +27,13 @@
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
+
+// Symbol to force loading at runtime
+extern "C"
+void distributionModelsLoad()
+{}
+
+
 namespace Foam
 {
     namespace distributionModels
--- src/lagrangian/intermediate/IntegrationScheme/makeIntegrationSchemes.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/lagrangian/intermediate/IntegrationScheme/makeIntegrationSchemes.C	(.../branches/2.2.x-2)	(revision 831)
@@ -30,6 +30,12 @@
 #include "scalar.H"
 #include "vector.H"
 
+// Symbol to force loading at runtime
+extern "C"
+void lagrangianIntermediateLoad()
+{}
+
+
 namespace Foam
 {
     makeIntegrationScheme(scalar);
--- src/lagrangian/intermediate/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/lagrangian/intermediate/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -45,4 +45,3 @@
     -lsurfaceFilmModels \
     -ldynamicFvMesh \
     -lsampling
-
--- src/lagrangian/spray/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/lagrangian/spray/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -38,6 +38,9 @@
     -lcompressibleTurbulenceModel \
     -lcompressibleRASModels \
     -lcompressibleLESModels \
+    -lincompressibleTurbulenceModel \
+    -lincompressibleRASModels \
+    -lincompressibleLESModels \
     -lLESdeltas \
     -lincompressibleTransportModels \
     -lregionModels \
--- src/OpenFOAM/global/argList/argList.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/global/argList/argList.C	(.../branches/2.2.x-2)	(revision 831)
@@ -320,7 +320,7 @@
 
     if (iter != options_.end())
     {
-        casePath = iter();
+        casePath = toUnixPath(iter());
         casePath.clean();
 
         if (casePath.empty() || casePath == ".")
--- src/OpenFOAM/global/clock/clock.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/global/clock/clock.H	(.../branches/2.2.x-2)	(revision 831)
@@ -91,11 +91,18 @@
         //- Return the current wall-clock time as a string
         static string clockTime();
 
+#ifdef MSWIN
+  // Satisfy assumptions elsewhere e.g., streams
+  typedef long TIME_T;
+#else
+  typedef time_t TIME_T;
+#endif
+
         //- Returns wall-clock time from clock instantiation
-        time_t elapsedClockTime() const;
+        TIME_T elapsedClockTime() const;
 
         //- Returns wall-clock time from last call of clockTimeIncrement()
-        time_t clockTimeIncrement() const;
+        TIME_T clockTimeIncrement() const;
 };
 
 
--- src/OpenFOAM/global/clock/clock.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/global/clock/clock.C	(.../branches/2.2.x-2)	(revision 831)
@@ -121,14 +121,14 @@
 
 // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
 
-time_t Foam::clock::elapsedClockTime() const
+Foam::clock::TIME_T Foam::clock::elapsedClockTime() const
 {
     newTime_ = getTime();
     return newTime_ - startTime_;
 }
 
 
-time_t Foam::clock::clockTimeIncrement() const
+Foam::clock::TIME_T Foam::clock::clockTimeIncrement() const
 {
     lastTime_ = newTime_;
     newTime_ = getTime();
--- src/OpenFOAM/global/constants/physicoChemical/physicoChemicalConstants.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/global/constants/physicoChemical/physicoChemicalConstants.C	(.../branches/2.2.x-2)	(revision 831)
@@ -75,14 +75,22 @@
     dimensionedScalar
     (
         "sigma",
-        Foam::dimensionedScalar
+        (Foam::dimensionedScalar
         (
             "C",
             dimensionSet(0, 0, 0, 0, 0),    //Foam::dimless,
             Foam::sqr(mathematical::pi)/60.0
         )
        *Foam::pow4(physicoChemical::k)
-       /(pow3(universal::hr)*sqr(universal::c))
+	 /(pow3(universal::hr)*sqr(universal::c)))
+#ifdef WM_SP
+	    .dimensions(),
+	    // Assuming this is the Stefan-Boltzmann constant
+	    // http://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law
+	    // Single precision can't handle the pow4(k), 
+	    // where k is Boltzmann constant = 1.3806488e-23
+	    5.6704e-8f
+#endif	 
     ),
     constantphysicoChemicalsigma,
     "sigma"
--- src/OpenFOAM/include/OSspecific.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/include/OSspecific.H	(.../branches/2.2.x-2)	(revision 831)
@@ -48,14 +48,21 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+#ifdef MSWIN
+  // Match assumptions elsewhere.
+  typedef long PID_T;
+#else
+  typedef pid_t PID_T;
+#endif
+
 //- Return the PID of this process
-pid_t pid();
+PID_T pid();
 
 //- Return the parent PID of this process
-pid_t ppid();
+PID_T ppid();
 
 //- Return the group PID of this process
-pid_t pgid();
+PID_T pgid();
 
 //- Return true if environment variable of given name is defined
 bool env(const word&);
@@ -225,6 +232,8 @@
 //- Return random double precision (uniform distribution between 0 and 1)
 scalar osRandomDouble();
 
+//- Convert to unix path separators
+std::string toUnixPath(const std::string& path);
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
--- src/OpenFOAM/containers/HashTables/StaticHashTable/StaticHashTable.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/containers/HashTables/StaticHashTable/StaticHashTable.C	(.../branches/2.2.x-2)	(revision 831)
@@ -32,6 +32,7 @@
 
 // * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * * //
 
+inline
 Foam::label Foam::StaticHashTableCore::canonicalSize(const label size)
 {
     if (size < 1)
--- src/OpenFOAM/db/dictionary/functionEntries/codeStream/codeStream.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/dictionary/functionEntries/codeStream/codeStream.C	(.../branches/2.2.x-2)	(revision 831)
@@ -30,6 +30,7 @@
 #include "dynamicCode.H"
 #include "dynamicCodeContext.H"
 #include "Time.H"
+#include "longLong.H"
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
--- src/OpenFOAM/db/IOstreams/Fstreams/OFstream.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/IOstreams/Fstreams/OFstream.C	(.../branches/2.2.x-2)	(revision 831)
@@ -72,7 +72,10 @@
             rm(pathname + ".gz");
         }
 
-        ofPtr_ = new ofstream(pathname.c_str());
+        // Use binary mode in case we write binary.
+        // Causes windows reading to fail if we don't
+        ofPtr_ = new ofstream(pathname.c_str(), 
+                              ios_base::out|ios_base::binary);
     }
 }
 
--- src/OpenFOAM/db/IOstreams/Fstreams/IFstream.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/IOstreams/Fstreams/IFstream.C	(.../branches/2.2.x-2)	(revision 831)
@@ -51,7 +51,10 @@
         }
     }
 
-    ifPtr_ = new ifstream(pathname.c_str());
+    // Use binary mode in case we read binary.
+    // Causes windows reading to fail if we don't.
+    ifPtr_ = new ifstream(pathname.c_str(), 
+                          ios_base::in|ios_base::binary);
 
     // If the file is compressed, decompress it before reading.
     if (!ifPtr_->good() && isFile(pathname + ".gz", false))
--- src/OpenFOAM/db/dynamicLibrary/dlLibraryTable/dlLibraryTable.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/dynamicLibrary/dlLibraryTable/dlLibraryTable.C	(.../branches/2.2.x-2)	(revision 831)
@@ -25,7 +25,7 @@
 
 #include "dlLibraryTable.H"
 #include "OSspecific.H"
-#include "long.H"
+#include "longLong.H"
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
@@ -63,7 +63,7 @@
             {
                 Info<< "dlLibraryTable::~dlLibraryTable() : closing "
                     << libNames_[i]
-                    << " with handle " << long(libPtrs_[i]) << endl;
+                    << " with handle " << reinterpret_cast<long long>(libPtrs_[i]) << endl;
             }
             dlClose(libPtrs_[i]);
         }
@@ -86,7 +86,7 @@
         if (debug)
         {
             Info<< "dlLibraryTable::open : opened " << functionLibName
-                << " resulting in handle " << long(functionLibPtr) << endl;
+                << " resulting in handle " << reinterpret_cast<long long>(functionLibPtr) << endl;
         }
 
         if (!functionLibPtr)
@@ -137,7 +137,7 @@
         if (debug)
         {
             Info<< "dlLibraryTable::close : closing " << functionLibName
-                << " with handle " << long(libPtrs_[index]) << endl;
+                << " with handle " << reinterpret_cast<long long>(libPtrs_[index]) << endl;
         }
 
         bool ok = dlClose(libPtrs_[index]);
--- src/OpenFOAM/db/error/IOerror.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/error/IOerror.C	(.../branches/2.2.x-2)	(revision 831)
@@ -247,7 +247,13 @@
             Perr<< endl << *this << endl
                 << "\nFOAM aborting\n" << endl;
             printStack(Perr);
+
+	    // Prefer ::exit(1) to avoid unnecessary warnings on Windows
+#ifdef MSWIN
+	    ::exit(1);
+#else
             ::abort();
+#endif
         }
     }
 }
--- src/OpenFOAM/db/error/error.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/error/error.C	(.../branches/2.2.x-2)	(revision 831)
@@ -246,7 +246,12 @@
             Perr<< endl << *this << endl
                 << "\nFOAM aborting\n" << endl;
             printStack(Perr);
+	    // Prefer ::exit(1) to avoid unnecessary warnings on Windows
+#ifdef MSWIN
+	    ::exit(1);
+#else
             ::abort();
+#endif
         }
     }
 }
--- src/OpenFOAM/db/IOobject/IOobject.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/IOobject/IOobject.C	(.../branches/2.2.x-2)	(revision 831)
@@ -26,6 +26,7 @@
 #include "IOobject.H"
 #include "Time.H"
 #include "IFstream.H"
+#include "StaticHashTable.H"
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
@@ -34,6 +35,7 @@
 defineTypeNameAndDebug(IOobject, 0);
 }
 
+static Foam::StaticHashTable<Foam::word> replacedFileNames_;
 
 // * * * * * * * * * * * * Static Member Functions * * * * * * * * * * * * * //
 
@@ -302,11 +304,32 @@
 }
 
 
+void Foam::IOobject::replaceFileName(const Foam::word & from, 
+                                     const Foam::word & to)
+{
+    replacedFileNames_.insert(from, to);
+}
+
+
+const Foam::word & Foam::IOobject::uniqueFileName() const
+{
+    StaticHashTable<word>::const_iterator findIt = 
+      replacedFileNames_.find(name());
+
+    const word & diskFileName = (findIt == replacedFileNames_.end()) ?
+      name() : *findIt;
+
+    return diskFileName;
+}
+
+
 Foam::fileName Foam::IOobject::filePath() const
 {
+    const word & diskFileName = uniqueFileName();
+
     if (instance().isAbsolute())
     {
-        fileName objectPath = instance()/name();
+        fileName objectPath = instance()/diskFileName;
         if (isFile(objectPath))
         {
             return objectPath;
@@ -319,7 +342,7 @@
     else
     {
         fileName path = this->path();
-        fileName objectPath = path/name();
+        fileName objectPath = path/diskFileName;
 
         if (isFile(objectPath))
         {
@@ -338,7 +361,7 @@
             {
                 fileName parentObjectPath =
                     rootPath()/caseName()
-                   /".."/instance()/db_.dbDir()/local()/name();
+                   /".."/instance()/db_.dbDir()/local()/diskFileName;
 
                 if (isFile(parentObjectPath))
                 {
@@ -358,7 +381,7 @@
                     fileName fName
                     (
                         rootPath()/caseName()
-                       /newInstancePath/db_.dbDir()/local()/name()
+                       /newInstancePath/db_.dbDir()/local()/diskFileName
                     );
 
                     if (isFile(fName))
--- src/OpenFOAM/db/IOobject/IOobject.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/IOobject/IOobject.H	(.../branches/2.2.x-2)	(revision 831)
@@ -154,6 +154,13 @@
         //- IOobject state
         objectState objState_;
 
+private:
+
+    // Private member functions
+
+        //- Unique on disk file name.
+        const word& uniqueFileName() const;
+
 protected:
 
     // Protected Member Functions
@@ -345,7 +352,7 @@
             //- Return complete path + object name
             fileName objectPath() const
             {
-                return path()/name();
+                return path()/uniqueFileName();
             }
 
             //- Return complete path + object name if the file exists
@@ -410,6 +417,12 @@
     // Member operators
 
         void operator=(const IOobject&);
+
+    // Static functions
+
+        //- Set unique on disk file name 
+        //- e.g., b -> b_ to avoid upper/lowercase clash with B
+        static void replaceFileName(const word& from, const word& to);
 };
 
 
--- src/OpenFOAM/db/IOobject/IOobjectI.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/db/IOobject/IOobjectI.H	(.../branches/2.2.x-2)	(revision 831)
@@ -76,6 +76,16 @@
         "\\*-----------------------------------------"
         "----------------------------------*/\n";
 
+#if defined(MSWIN)
+    os <<
+"/*  Windows port by Symscape (www.symscape.com)                              *\\\n"
+"\\*---------------------------------------------------------------------------*/\n";
+#elif defined(DARWIN)
+    os <<
+"/*  Mac OSX port by Symscape (www.symscape.com)                              *\\\n"
+"\\*---------------------------------------------------------------------------*/\n";
+#endif
+
     return os;
 }
 
--- src/OpenFOAM/primitives/strings/fileName/fileNameI.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/primitives/strings/fileName/fileNameI.H	(.../branches/2.2.x-2)	(revision 831)
@@ -95,8 +95,11 @@
 {
     return
     (
-        !isspace(c)
-     && c != '"'   // string quote
+    // Under windows spaces are common in file paths,
+    // so can't disallow them. Prefer also
+    // to allow them under *nix too.
+    //    !isspace(c) &&
+     c != '"'   // string quote
      && c != '\''  // string quote
     );
 }
--- src/OpenFOAM/primitives/strings/fileName/fileName.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/primitives/strings/fileName/fileName.C	(.../branches/2.2.x-2)	(revision 831)
@@ -56,7 +56,13 @@
 
 bool Foam::fileName::isAbsolute() const
 {
+#ifdef MSWIN
+  // Cater for absolute Windows paths, e.g., C:\..., and file share \\machine_name
+  return ((3 < size()) && (operator[](1) == ':' || 
+                           (operator[](0) == '\\' && operator[](1) == '\\')));
+#else
     return !empty() && operator[](0) == '/';
+#endif
 }
 
 
--- src/OpenFOAM/primitives/Scalar/doubleFloat.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/primitives/Scalar/doubleFloat.H	(.../branches/2.2.x-2)	(revision 831)
@@ -31,6 +31,22 @@
 
 #include <cmath>
 
+#if defined(MSWIN)
+#define j0f _j0
+#define j1f _j1
+#define jnf _jn
+#define y0f _y0
+#define y1f _y1
+#define ynf _yn
+#elif defined(DARWIN)
+#define j0f j0
+#define j1f j1
+#define jnf jn
+#define y0f y0
+#define y1f y1
+#define ynf yn
+#endif
+
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
 namespace Foam
--- src/OpenFOAM/primitives/hashes/Hash/Hash.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/primitives/hashes/Hash/Hash.H	(.../branches/2.2.x-2)	(revision 831)
@@ -209,18 +209,19 @@
 class Hash<void*>
 {
 public:
+   typedef intptr_t HashType;
 
     Hash()
     {}
 
     unsigned operator()(const void* const& p, unsigned seed) const
     {
-        return Hash<long>()(long(p), seed);
+        return Hash<HashType>()(HashType(p), seed);
     }
 
     unsigned operator()(const void* const& p) const
     {
-        return Hash<long>()(long(p));
+        return Hash<HashType>()(HashType(p));
     }
 
 };
--- src/OpenFOAM/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/OpenFOAM/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,22 @@
 EXE_INC = -I$(OBJECTS_DIR)
 
+#ifdef MSWIN
+
+ifeq ($(LINK_PLIB),)
+ LIB_LIBS = $(FOAM_LIBBIN)/dummy/libPstream.o
+else
+ LIB_LIBS = -L$(FOAM_LIBBIN)/dummy -lPstream
+endif
+
+LIB_LIBS += \
+    $(FOAM_LIBBIN)/libOSspecific.o \
+    -lz
+
+#else
 LIB_LIBS = \
     $(FOAM_LIBBIN)/libOSspecific.o \
     -L$(FOAM_LIBBIN)/dummy -lPstream \
-    -lz
+    -lz -ldl
+#endif
+
+PROJECT_LIBS =
--- src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchField.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchField.C	(.../branches/2.2.x-2)	(revision 831)
@@ -46,7 +46,8 @@
     const DimensionedField<Type, volMesh>& iF
 )
 :
-    uniformJumpFvPatchField<Type>(p, iF)
+    uniformJumpFvPatchField<Type>(p, iF),
+    reversed_(false)
 {}
 
 
@@ -59,7 +60,8 @@
     const fvPatchFieldMapper& mapper
 )
 :
-    uniformJumpFvPatchField<Type>(ptf, p, iF, mapper)
+    uniformJumpFvPatchField<Type>(ptf, p, iF, mapper),
+    reversed_(ptf.reversed_)
 {}
 
 
@@ -71,8 +73,11 @@
     const dictionary& dict
 )
 :
-    uniformJumpFvPatchField<Type>(p, iF, dict)
-{}
+    uniformJumpFvPatchField<Type>(p, iF, dict),
+    reversed_(false)
+{    
+    reversed_.readIfPresent("reversed", dict);
+}
 
 
 template<class Type>
@@ -81,7 +86,8 @@
     const fanFvPatchField<Type>& ptf
 )
 :
-    uniformJumpFvPatchField<Type>(ptf)
+    uniformJumpFvPatchField<Type>(ptf),
+    reversed_(ptf.reversed_)
 {}
 
 
@@ -92,7 +98,8 @@
     const DimensionedField<Type, volMesh>& iF
 )
 :
-    uniformJumpFvPatchField<Type>(ptf, iF)
+    uniformJumpFvPatchField<Type>(ptf, iF),
+    reversed_(ptf.reversed_)
 {}
 
 
@@ -113,4 +120,13 @@
 }
 
 
+template<class Type>
+void Foam::fanFvPatchField<Type>::write(Ostream& os) const
+{
+    uniformJumpFvPatchField<Type>::write(os);
+
+    os.writeKeyword("reversed") << reversed_ << token::END_STATEMENT << nl;
+}
+
+
 // ************************************************************************* //
--- src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchFields.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchFields.C	(.../branches/2.2.x-2)	(revision 831)
@@ -48,13 +48,15 @@
 {
     if (this->cyclicPatch().owner())
     {
-        const surfaceScalarField& phi =
+       const scalar dir = reversed_ ? -1 : 1; 
+
+       const surfaceScalarField& phi =
             db().lookupObject<surfaceScalarField>("phi");
 
         const fvsPatchField<scalar>& phip =
             patch().patchField<surfaceScalarField, scalar>(phi);
 
-        scalarField Un(max(phip/patch().magSf(), scalar(0)));
+        scalarField Un(max(dir*phip/patch().magSf(), scalar(0)));
 
         if (phi.dimensions() == dimDensity*dimVelocity*dimArea)
         {
@@ -62,6 +64,7 @@
         }
 
         this->jump_ = max(this->jumpTable_->value(Un), scalar(0));
+	this->jump_ *= dir;
     }
 }
 
--- src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchField.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/fields/fvPatchFields/derived/fan/fanFvPatchField.H	(.../branches/2.2.x-2)	(revision 831)
@@ -98,7 +98,11 @@
 :
     public uniformJumpFvPatchField<Type>
 {
+    // Private data
 
+        //- Reverse direction relative to patch normal
+        Switch reversed_;
+
     // Private Member Functions
 
         //- Calculate the fan pressure jump
@@ -176,6 +180,10 @@
 
         //- Update the coefficients associated with the patch field
         virtual void updateCoeffs();
+
+
+        //- Write
+        virtual void write(Ostream&) const;
 };
 
 
--- src/finiteVolume/fields/fvPatchFields/constraint/processor/processorFvPatchScalarField.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/fields/fvPatchFields/constraint/processor/processorFvPatchScalarField.C	(.../branches/2.2.x-2)	(revision 831)
@@ -33,6 +33,7 @@
 // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
 
 template<>
+inline
 void processorFvPatchField<scalar>::initInterfaceMatrixUpdate
 (
     scalarField&,
@@ -89,6 +90,7 @@
 
 
 template<>
+inline
 void processorFvPatchField<scalar>::updateInterfaceMatrix
 (
     scalarField& result,
--- src/finiteVolume/fields/fvPatchFields/constraint/processor/processorFvPatchScalarField.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/fields/fvPatchFields/constraint/processor/processorFvPatchScalarField.H	(.../branches/2.2.x-2)	(revision 831)
@@ -64,6 +64,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+#ifdef NoRepository
+#   include "processorFvPatchScalarField.C"
 #endif
 
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
 // ************************************************************************* //
--- src/finiteVolume/Make/files	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -115,7 +115,7 @@
 $(constraintFvPatchFields)/jumpCyclicAMI/jumpCyclicAMIFvPatchFields.C
 $(constraintFvPatchFields)/nonuniformTransformCyclic/nonuniformTransformCyclicFvPatchFields.C
 $(constraintFvPatchFields)/processor/processorFvPatchFields.C
-$(constraintFvPatchFields)/processor/processorFvPatchScalarField.C
+/*$(constraintFvPatchFields)/processor/processorFvPatchScalarField.C*/
 $(constraintFvPatchFields)/processorCyclic/processorCyclicFvPatchFields.C
 $(constraintFvPatchFields)/symmetry/symmetryFvPatchFields.C
 $(constraintFvPatchFields)/wedge/wedgeFvPatchFields.C
--- src/finiteVolume/cfdTools/general/adjustPhi/adjustPhi.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/finiteVolume/cfdTools/general/adjustPhi/adjustPhi.C	(.../branches/2.2.x-2)	(revision 831)
@@ -109,7 +109,7 @@
         {
             massCorr = (massIn - fixedMassOut)/adjustableMassOut;
         }
-        else if (mag(fixedMassOut - massIn)/totalFlux > 1e-8)
+        else if (mag(fixedMassOut - massIn)/totalFlux > 1e-6)
         {
             FatalErrorIn
             (
--- src/ODE/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/ODE/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1 @@
+LIB_LIBS =
--- src/fvAgglomerationMethods/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/fvAgglomerationMethods/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -5,10 +5,10 @@
 
 export ParMGridGen=$WM_THIRD_PARTY_DIR/ParMGridGen-1.0
 
-if [ -e "$FOAM_LIBBIN/libMGridGen.so" ]
-then
-    wmake $makeType MGridGenGamgAgglomeration
-fi
+#if [ -e "$FOAM_LIBBIN/libMGridGen.so" ]
+#then
+#    wmake $makeType MGridGenGamgAgglomeration
+#fi
 
 wmake $makeType pairPatchAgglomeration
 
--- src/Pstream/mpi/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/Pstream/mpi/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -3,3 +3,9 @@
 
 EXE_INC  = $(PFLAGS) $(PINC)
 LIB_LIBS = $(PLIBS)
+
+#ifdef MSWIN
+LIB_LIBS += -L$(FOAM_LIBBIN) -lOpenFOAM
+#endif
+
+PROJECT_LIBS =
--- src/Pstream/dummy/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/Pstream/dummy/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,5 @@
+#ifdef MSWIN
+LIB_LIBS = -lOpenFOAM
+#endif
+
+PROJECT_LIBS = 
--- src/Pstream/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/Pstream/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,7 @@
 #!/bin/sh
 cd ${0%/*} || exit 1    # run from this directory
 makeType=${1:-libso}
+set -e
 
 
 #
--- src/turbulenceModels/compressible/LES/LESModel/LESModel.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/compressible/LES/LESModel/LESModel.C	(.../branches/2.2.x-2)	(revision 831)
@@ -28,6 +28,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void compressibleLESModelsLoad()
+{}
+
+
 namespace Foam
 {
 namespace compressible
--- src/turbulenceModels/compressible/LES/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/compressible/LES/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,4 +11,5 @@
     -lLESdeltas \
     -lLESfilters \
     -lfiniteVolume \
-    -lmeshTools
+    -lmeshTools \
+    -lfluidThermophysicalModels
--- src/turbulenceModels/compressible/RAS/RASModel/RASModel.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/compressible/RAS/RASModel/RASModel.C	(.../branches/2.2.x-2)	(revision 831)
@@ -29,6 +29,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void compressibleRASModelsLoad()
+{}
+
+
 namespace Foam
 {
 namespace compressible
@@ -40,6 +46,7 @@
 defineRunTimeSelectionTable(RASModel, dictionary);
 addToRunTimeSelectionTable(turbulenceModel, RASModel, turbulenceModel);
 
+
 // * * * * * * * * * * * * * Protected Member Functions  * * * * * * * * * * //
 
 void RASModel::printCoeffs()
--- src/turbulenceModels/compressible/turbulenceModel/derivedFvPatchFields/temperatureCoupledBase/temperatureCoupledBase.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/compressible/turbulenceModel/derivedFvPatchFields/temperatureCoupledBase/temperatureCoupledBase.C	(.../branches/2.2.x-2)	(revision 831)
@@ -74,8 +74,8 @@
 )
 :
     patch_(patch),
-    method_(KMethodTypeNames_.read(dict.lookup("kappa"))),
-    kappaName_(dict.lookup("kappaName"))
+    method_(KMethodType(KMethodTypeNames_.find(dict.lookupOrDefault<word>("kappa", "fluidThermo"))())),
+    kappaName_(dict.lookupOrDefault<word>("kappaName", "notset"))
 {}
 
 
--- src/turbulenceModels/incompressible/LES/LESModel/LESModel.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/LES/LESModel/LESModel.C	(.../branches/2.2.x-2)	(revision 831)
@@ -28,6 +28,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void incompressibleLESModelsLoad()
+{}
+
+
 namespace Foam
 {
 namespace incompressible
--- src/turbulenceModels/incompressible/LES/LESModel/LESModel.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/LES/LESModel/LESModel.H	(.../branches/2.2.x-2)	(revision 831)
@@ -111,7 +111,6 @@
     //- Runtime type information
     TypeName("LESModel");
 
-
     // Declare run-time constructor selection table
 
         declareRunTimeSelectionTable
@@ -128,7 +127,6 @@
             (U, phi, transport, turbulenceModelName)
         );
 
-
     // Constructors
 
         //- Construct from components
--- src/turbulenceModels/incompressible/LES/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/LES/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -11,4 +11,5 @@
     -lLESdeltas \
     -lLESfilters\
     -lfiniteVolume \
-    -lmeshTools
+    -lmeshTools \
+    -lincompressibleTransportModels
--- src/turbulenceModels/incompressible/RAS/derivedFvPatchFields/turbulentHeatFluxTemperature/turbulentHeatFluxTemperatureFvPatchScalarField.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/RAS/derivedFvPatchFields/turbulentHeatFluxTemperature/turbulentHeatFluxTemperatureFvPatchScalarField.C	(.../branches/2.2.x-2)	(revision 831)
@@ -23,11 +23,13 @@
 
 \*---------------------------------------------------------------------------*/
 
+#include "incompressible/transportModel/transportModel.H"
 #include "turbulentHeatFluxTemperatureFvPatchScalarField.H"
 #include "addToRunTimeSelectionTable.H"
 #include "fvPatchFieldMapper.H"
 #include "volFields.H"
 #include "incompressible/turbulenceModel/turbulenceModel.H"
+#include "RASModel.H"
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
@@ -109,7 +111,7 @@
     fixedGradientFvPatchScalarField(p, iF),
     heatSource_(heatSourceTypeNames_.read(dict.lookup("heatSource"))),
     q_("q", dict, p.size()),
-    alphaEffName_(dict.lookup("alphaEff"))
+    alphaEffName_(dict.lookupOrDefault<word>("alphaEff", "alphat"))
 {
     fvPatchField<scalar>::operator=(patchInternalField());
     gradient() = 0.0;
@@ -184,21 +186,27 @@
         patch().lookupPatchField<volScalarField, scalar>(alphaEffName_);
 
     // retrieve (constant) specific heat capacity from transport dictionary
-    const turbulenceModel& turbulence =
-        db().lookupObject<turbulenceModel>("turbulenceModel");
-    const scalar Cp0(readScalar(turbulence.transport().lookup("Cp0")));
+    const RASModel& rasModel = db().lookupObject<RASModel>("RASProperties");
+    // Assume alphaEffp = alphat, renamed at 2.2.x from kappat,
+    // need kappaEff = kappa(laminar) + kappat, where kappal = nu/Pr
+    // See applications/solvers/heatTransfer/buoyantBoussinesqSimpleFoam/TEqn.H
+    const label patchI = patch().index();
+    const scalarField& nu = rasModel.nu()->boundaryField()[patchI];
+    const scalar
+      Pr(dimensionedScalar(rasModel.transport().lookup("Pr")).value());
+    const scalar Cp0(dimensionedScalar(rasModel.transport().lookup("Cp")).value());
 
     switch (heatSource_)
     {
         case hsPower:
         {
             const scalar Ap = gSum(patch().magSf());
-            gradient() = q_/(Ap*Cp0*alphaEffp);
+            gradient() = q_/(Ap*Cp0*(nu/Pr + alphaEffp));
             break;
         }
         case hsFlux:
         {
-            gradient() = q_/(Cp0*alphaEffp);
+	    gradient() = q_/(Cp0*(nu/Pr + alphaEffp));
             break;
         }
         default:
--- src/turbulenceModels/incompressible/RAS/kkLOmega/kkLOmega.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/RAS/kkLOmega/kkLOmega.C	(.../branches/2.2.x-2)	(revision 831)
@@ -650,11 +650,31 @@
 
     const volScalarField lambdaEff(min(Clambda_*y_, lambdaT));
 
+    /*
+      18th International Conference
+      ENGINEERING MECHANICS 2012 pp. 309315
+      Svratka, Czech Republic, May 14  17, 2012 Paper #195
+      NUMERICAL SIMULATION OF TRANSITIONAL FLOWS WITH LAMINAR KINETIC ENERGY
+      J. Furst
+      http://www.engmech.cz/2012/proceedings/pdf/195_Furst_J-FT.pdf
+
+      "Note that the article Walters and Cokljat (2008) does not include the exponent
+      2/3 in the denition of fW. The original model Walters and Leylek (2004) as well as the Walters and
+      Leylek (2005) do include the exponent."
+      fw = pow(lambdaEff/(lambdaT + dimensionedScalar("SMALL", dimLength, ROOTVSMALL)), 2.0/3.0)
+
+      "The coefcient C2 = 0.92 is constant in the original article. Nevertheless the correct form is"
+      Cw2 = Cw2_(0.92) * sqr(fw)
+    */
+
     const volScalarField fw
     (
-        lambdaEff/(lambdaT + dimensionedScalar("SMALL", dimLength, ROOTVSMALL))
+     //  lambdaEff/(lambdaT + dimensionedScalar("SMALL", dimLength, ROOTVSMALL))
+     pow(lambdaEff/(lambdaT + dimensionedScalar("SMALL", dimLength, ROOTVSMALL)), 2.0/3.0)
     );
 
+    const volScalarField Cw2(Cw2_*sqr(fw));
+
     const volTensorField gradU(fvc::grad(U_));
 
     const volScalarField omega(sqrt(2.0)*mag(skew(gradU)));
@@ -772,7 +792,7 @@
             (CwR_/(fw + fwMin) - 1.0)*kl_*(Rbp + Rnat)/(kt_ + kMin_)
           , omega_
         )
-      - fvm::Sp(Cw2_*omega_, omega_)
+      - fvm::Sp(Cw2*omega_, omega_)
       + Cw3_*fOmega(lambdaEff, lambdaT)*alphaTEff*sqr(fw)*sqrt(kt_)/pow3(y_)
     );
 
--- src/turbulenceModels/incompressible/RAS/RASModel/RASModel.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/RAS/RASModel/RASModel.C	(.../branches/2.2.x-2)	(revision 831)
@@ -28,6 +28,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void incompressibleRASModelsLoad()
+{}
+
+
 namespace Foam
 {
 namespace incompressible
--- src/turbulenceModels/incompressible/RAS/RASModel/RASModel.H	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/RAS/RASModel/RASModel.H	(.../branches/2.2.x-2)	(revision 831)
@@ -119,7 +119,6 @@
     //- Runtime type information
     TypeName("RASModel");
 
-
     // Declare run-time constructor selection table
 
         declareRunTimeSelectionTable
@@ -136,7 +135,6 @@
             (U, phi, transport, turbulenceModelName)
         );
 
-
     // Constructors
 
         //- Construct from components
--- src/turbulenceModels/incompressible/RAS/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/RAS/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,4 +7,5 @@
 LIB_LIBS = \
     -lincompressibleTurbulenceModel \
     -lfiniteVolume \
-    -lmeshTools
+    -lmeshTools \
+    -lincompressibleTransportModels
--- src/turbulenceModels/incompressible/turbulenceModel/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/turbulenceModels/incompressible/turbulenceModel/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,5 +4,5 @@
     -I$(LIB_SRC)/transportModels
 
 LIB_LIBS = \
-    -lfiniteVolume
-
+    -lfiniteVolume \
+    -lincompressibleTransportModels
--- src/renumber/renumberMethods/renumberMethod/renumberMethod.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/renumber/renumberMethods/renumberMethod/renumberMethod.C	(.../branches/2.2.x-2)	(revision 831)
@@ -31,6 +31,12 @@
 
 // * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void renumberMethodsLoad()
+{}
+
+
 namespace Foam
 {
     defineTypeNameAndDebug(renumberMethod, 0);
--- src/renumber/SloanRenumber/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/renumber/SloanRenumber/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,4 +9,4 @@
     -L$(BOOST_ARCH_PATH)/lib -lboost_thread \
     -lmeshTools \
     -ldecompositionMethods \
-    -lrenumberMethods
+    -lrenumberMethods -u renumberMethodsLoad
--- src/postProcessing/functionObjects/forces/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/postProcessing/functionObjects/forces/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -9,12 +9,14 @@
 
 LIB_LIBS = \
     -lincompressibleTransportModels \
-    -lincompressibleRASModels \
-    -lincompressibleLESModels \
+    -lincompressibleTurbulenceModel \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfluidThermophysicalModels \
     -lspecie \
-    -lcompressibleRASModels \
-    -lcompressibleLESModels \
+    -lcompressibleTurbulenceModel \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
     -lfiniteVolume \
     -lmeshTools \
     -lfileFormats
--- src/postProcessing/functionObjects/derivedFields/vorticityWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/vorticityWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,75 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::vorticityWriter
+
+Description
+    Write Vorticity field
+
+SourceFiles
+    vorticityWriter.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef vorticityWriter_H
+#define vorticityWriter_H
+
+#include "derivedFieldWriter.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class dictionary;
+
+
+  /*---------------------------------------------------------------------------*\
+    Class vorticityWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class vorticityWriter : public derivedFieldWriter
+  {
+  public:
+    //- Runtime type information
+    TypeName("vorticityWriter");
+
+    //- Field file name.
+    static const word FIELD_NAME;
+
+    // Constructors
+
+    vorticityWriter(const dictionary& dict);
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr);
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/wallHeatFluxWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/wallHeatFluxWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,84 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::wallHeatFluxWriter
+
+Description
+    Write wallHeatFlux field
+
+SourceFiles
+    wallShearStress.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef wallHeatFluxWriter_H
+#define wallHeatFluxWriter_H
+
+#include "derivedFieldWriter.H"
+#include "volFieldsFwd.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class dictionary;
+
+
+  /*---------------------------------------------------------------------------*\
+    Class wallHeatFluxWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class wallHeatFluxWriter : public derivedFieldWriter
+  {
+    // Private data
+
+    // Private methods
+
+    //- Return heat transfer coefficient
+    tmp<volScalarField> htc(const objectRegistry& obr, 
+			    bool & foundField) const;
+  public:
+    //- Runtime type information
+    TypeName("wallHeatFluxWriter");
+
+    //- Field file name.
+    static const word FIELD_NAME;
+
+    // Constructors
+
+    wallHeatFluxWriter(const dictionary& dict);
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr);
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/machWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/machWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,103 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "machWriter.H"
+#include "volFields.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "fluidThermo.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(machWriter, 0);
+  const word machWriter::FIELD_NAME("Ma");
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::machWriter::machWriter(const dictionary & dict)
+  : derivedFieldWriter(dict)
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::machWriter::write(const objectRegistry& obr)
+{
+  const fvMesh& mesh = refCast<const fvMesh>(obr);
+  const Time& runTime = obr.time();
+
+  volScalarField machNo
+    (
+     IOobject
+     (
+      FIELD_NAME,
+      runTime.timeName(),
+      mesh,
+      IOobject::NO_READ,
+      IOobject::NO_WRITE
+      ),
+     mesh,
+     dimensionedScalar(FIELD_NAME, dimless, 0.0)
+     );
+  
+  const word UName("U");
+  const word TName("T");
+  const word thermoPhysicalName("thermophysicalProperties");
+  const word thermoName("thermodynamicProperties");
+
+  if (obr.foundObject<volVectorField>(UName) && 
+      obr.foundObject<volScalarField>(TName))
+    {
+      const volVectorField& U = obr.lookupObject<volVectorField>(UName);
+      
+      if (obr.foundObject<fluidThermo>(thermoPhysicalName))
+        {
+          const fluidThermo& thermo =
+            obr.lookupObject<fluidThermo>(thermoPhysicalName);
+      
+          volScalarField Cp = thermo.Cp();
+          volScalarField Cv = thermo.Cv();
+
+          machNo = mag(U)/(sqrt((Cp/Cv)*(Cp - Cv)*thermo.T()));
+        }
+      else if (obr.foundObject<dictionary>(thermoName))
+        {
+          const volScalarField& T = obr.lookupObject<volScalarField>(TName);
+          const dictionary& thermoProps =
+            obr.lookupObject<dictionary>(thermoName);
+
+          dimensionedScalar R(thermoProps.lookup("R"));
+          dimensionedScalar Cv(thermoProps.lookup("Cv"));
+
+          machNo = mag(U)/(sqrt(((Cv + R)/Cv)*R*T));
+        }
+    }
+
+  machNo.write();
+}
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFieldsFunctionObject.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFieldsFunctionObject.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,39 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "derivedFieldsFunctionObject.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    defineNamedTemplateTypeNameAndDebug(derivedFieldsFunctionObject, 0);
+
+    addToRunTimeSelectionTable
+    (
+        functionObject,
+        derivedFieldsFunctionObject,
+        dictionary
+    );
+}
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/IOderivedFields.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/IOderivedFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,46 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Typedef
+    Foam::IOderivedFields
+
+Description
+    Instance of the generic IOOutputFilter for derivedFields.
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef IOderivedFields_H
+#define IOderivedFields_H
+
+#include "derivedFields.H"
+#include "IOOutputFilter.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    typedef IOOutputFilter<derivedFields> IOderivedFields;
+}
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFields.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFields.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,118 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "derivedFields.H"
+#include "machWriter.H"
+#include "yPlusWriter.H"
+#include "vorticityWriter.H"
+#include "wallHeatFluxWriter.H"
+#include "wallShearStressWriter.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "PtrList.H"
+#include "fvMesh.H"
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(derivedFields, 0);
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+inline
+void Foam::derivedFields::addWriter(derivedFieldWriter* writer)
+{
+  if (0 != writer) 
+    {
+      const label id = writers_->size();
+      
+      writers_->setSize(id + 1);
+      writers_->set(id, writer);
+    }
+}
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::derivedFields::derivedFields(const word& name,
+                                   const objectRegistry& obr,
+                                   const dictionary& dict,
+                                   const bool loadFromFiles)
+  : writers_(new PtrList<derivedFieldWriter>),
+    name_(name),
+    obr_(obr)
+{
+  read(dict);
+}
+
+
+Foam::derivedFields::~derivedFields()
+{
+  delete writers_;
+}
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+
+void Foam::derivedFields::read(const dictionary& dict)
+{
+  writers_->clear();
+
+  // Check if the available mesh is an fvMesh otherise deactivate
+  if (!isA<fvMesh>(obr_))
+    {
+      WarningIn
+        (
+         "derivedFields::derivedFields(const objectRegistry& obr, const dictionary& dict)"
+         )   << "No fvMesh available, deactivating."
+             << endl;
+    }
+  else
+    {
+      addWriter(derivedFieldWriter::read<machWriter>(dict));
+      addWriter(derivedFieldWriter::read<vorticityWriter>(dict));
+      addWriter(derivedFieldWriter::read<wallHeatFluxWriter>(dict));
+      addWriter(derivedFieldWriter::read<wallShearStressWriter>(dict));
+      addWriter(derivedFieldWriter::read<yPlusWriter>(dict));
+
+      Switch writeOnStart(dict.lookupOrDefault<Switch>("writeOnStart", false));
+
+      if (writeOnStart) 
+        {
+          write();
+        }
+    }
+}
+
+
+void Foam::derivedFields::write()
+{
+  forAll(*writers_, i)
+    {
+      (*writers_)[i].write(obr_);
+    }
+}
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/yPlusWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/yPlusWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,228 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "yPlusWriter.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "wallFvPatch.H"
+#include "nearWallDist.H"
+
+#include "incompressible/RAS/RASModel/RASModel.H"
+#include "nutWallFunction/nutWallFunctionFvPatchScalarField.H"
+#include "compressible/RAS/RASModel/RASModel.H"
+#include "mutWallFunction/mutWallFunctionFvPatchScalarField.H"
+#include "incompressible/LES/LESModel/LESModel.H"
+#include "compressible/LES/LESModel/LESModel.H"
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(yPlusWriter, 0);
+  const word yPlusWriter::FIELD_NAME("yPlus");
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+
+
+
+inline
+static const Foam::volScalarField nutORmut(const Foam::incompressible::RASModel & model)
+{
+  return model.nut()();
+}
+
+
+inline
+static const Foam::volScalarField nutORmut(const Foam::compressible::RASModel & model)
+{
+  return model.mut()();
+}
+
+
+template<class T_Model, class T_WallFunctionPatchField>
+bool 
+Foam::yPlusWriter::extractedFromRAS(char const * const modelProperties,
+                                    const fvMesh& mesh,
+                                    volScalarField::GeometricBoundaryField& yPlusb)
+{
+  int count = 0;
+
+  if (mesh.foundObject<T_Model>(modelProperties)) 
+    {
+      const T_Model & model
+        = mesh.lookupObject<T_Model>(modelProperties);
+    
+      const volScalarField::GeometricBoundaryField patches =
+        nutORmut(model).boundaryField();
+      
+      forAll(patches, patchI)
+        {
+          const fvPatchField<scalar>& currPatch = patches[patchI];
+          
+          if (isA<T_WallFunctionPatchField>(currPatch))
+            {
+              const T_WallFunctionPatchField& wP =
+                dynamic_cast<const T_WallFunctionPatchField&>(currPatch);
+              scalarField& yp = yPlusb[patchI];
+              yp = wP.yPlus();
+              ++count;
+
+              writeStatistics(yp, currPatch.patch().name(), FIELD_NAME);
+            }
+        }
+    }
+
+  return (0 < count);
+}
+
+
+inline
+static Foam::tmp<Foam::volScalarField> nuEffFor(const Foam::incompressible::LESModel & model)
+{
+  return model.nuEff();
+}
+
+
+inline
+static Foam::tmp<Foam::volScalarField> nuEffFor(const Foam::compressible::LESModel & model)
+{
+  return model.muEff() / model.rho();
+}
+
+
+inline
+static Foam::tmp<Foam::volScalarField> nuFor(const Foam::incompressible::LESModel & model)
+{
+  return model.nu();
+}
+
+
+inline
+static Foam::tmp<Foam::volScalarField> nuFor(const Foam::compressible::LESModel & model)
+{
+  return model.mu() / model.rho();
+}
+
+
+template<class T_Model>
+bool 
+Foam::yPlusWriter::extractedFromLES(char const * const modelProperties,
+                                    const fvMesh& mesh,
+                                    volScalarField::GeometricBoundaryField& yPlusb)
+{
+  int count = 0;
+
+  if (mesh.foundObject<T_Model>(modelProperties)) 
+    {
+      const fvPatchList& patches = mesh.boundary();
+
+      const T_Model & model
+        = mesh.lookupObject<T_Model>(modelProperties);
+
+      const volScalarField::GeometricBoundaryField d = 
+        nearWallDist(mesh).y();
+      tmp<volScalarField> nuEff = nuEffFor(model);
+      const volScalarField::GeometricBoundaryField& nuEffb = 
+        nuEff().boundaryField();
+      tmp<volScalarField> nu = nuFor(model);
+      const volScalarField::GeometricBoundaryField& nub = 
+        nu().boundaryField();
+      const volVectorField::GeometricBoundaryField& Ub = 
+        model.U().boundaryField();
+      
+      forAll(patches, patchI)
+        {
+          const fvPatch& currPatch = patches[patchI];
+          
+          if (isA<wallFvPatch>(currPatch))
+            {
+              scalarField& yp = yPlusb[patchI];
+              yp = d[patchI] *
+                sqrt
+                (
+                 nuEffb[patchI]
+                 *mag(Ub[patchI].snGrad())
+                 )
+                /nub[patchI];
+
+              ++count;
+              writeStatistics(yp, currPatch.name(), FIELD_NAME);
+           }
+        }
+    }
+
+  return (0 < count);
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::yPlusWriter::yPlusWriter(const dictionary & dict)
+  : derivedFieldWriter(dict)
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+
+void Foam::yPlusWriter::write(const objectRegistry& obr)
+{
+  const fvMesh& mesh = refCast<const fvMesh>(obr);
+  
+  volScalarField yPlus
+    (
+     IOobject
+     (
+      FIELD_NAME,
+      obr.time().timeName(),
+      mesh,
+      IOobject::NO_READ,
+      IOobject::NO_WRITE
+      ),
+     mesh,
+     dimensionedScalar(FIELD_NAME, dimless, 0.0)
+     );
+
+  volScalarField::GeometricBoundaryField& yPlusb =
+    yPlus.boundaryField();
+
+  if (!extractedFromRAS<incompressible::RASModel,
+      incompressible::nutWallFunctionFvPatchScalarField>
+      ("RASProperties", mesh, yPlusb) &&
+      !extractedFromRAS<compressible::RASModel,
+      compressible::mutWallFunctionFvPatchScalarField>
+      ("RASProperties", mesh, yPlusb) &&
+      !extractedFromLES<incompressible::LESModel>
+      ("LESProperties", mesh, yPlusb)) {
+    extractedFromLES<compressible::LESModel>
+      ("LESProperties", mesh, yPlusb);
+  }
+  
+  yPlus.write();
+}
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/machWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/machWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,75 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::machWriter
+
+Description
+    Write Mach number field
+
+SourceFiles
+    machWriter.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef machWriter_H
+#define machWriter_H
+
+#include "derivedFieldWriter.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class dictionary;
+
+
+  /*---------------------------------------------------------------------------*\
+    Class machWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class machWriter : public derivedFieldWriter
+  {
+  public:
+    //- Runtime type information
+    TypeName("machWriter");
+
+    //- Field file name.
+    static const word FIELD_NAME;
+
+    // Constructors
+
+    machWriter(const dictionary& dict);
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr);
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFieldsFunctionObject.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFieldsFunctionObject.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,50 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Typedef
+    Foam::derivedFieldsFunctionObject
+
+Description
+    FunctionObject wrapper around derivedFields to allow them to be created via the
+    functions list within controlDict.
+
+SourceFiles
+    derivedFieldsFunctionObject.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef derivedFieldsFunctionObject_H
+#define derivedFieldsFunctionObject_H
+
+#include "derivedFields.H"
+#include "OutputFilterFunctionObject.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+    typedef OutputFilterFunctionObject<derivedFields> derivedFieldsFunctionObject;
+}
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFields.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFields.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,195 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::derivedFields
+
+Description
+    Provide derived fields such as wallShearStress and yPlus
+
+    Optionally provides statistics: min, max & average
+
+    Member function derivedFields::write() writes
+    derivedFields into the directory \<timeDir\>, e.g.
+
+    @verbatim
+    functions
+    (
+      derivedFields1
+      {
+        // Type of functionObject
+        type derivedFields;
+
+        // Where to load it from (if not already in solver)
+        functionObjectLibs ("derivedFields");
+
+        // Flow region
+        // Optional default = defaultRegion
+        // region someWhere;
+
+        // Dedicated dictionary
+        // Optional defualt = ""
+        dictionary "";
+
+        // Write interval
+        outputControl timeStep;
+        outputInterval 1;
+        
+        // functionObject will be called.
+        // Optional default = on
+        enabled on;
+
+        // Write fields on first start up (e.g., time zero)
+        // Optional default = off
+        writeOnStart on;
+
+        wallShearStress 
+        {
+          // min, max & average to Info (optional default = off)
+          statistics on;
+
+          // Incompressible density reference (optional default = 1.)
+          rhoInf 1.;
+        }
+
+        yPlus
+        {
+          statistics on;
+        }               
+      }
+   );
+   @endverbatim
+
+SourceFiles
+    derivedFields.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef derivedFields_H
+#define derivedFields_H
+
+#include "pointFieldFwd.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+  // Forward declaration of classes
+  template<class T> class PtrList;
+  class objectRegistry;
+  class dictionary;
+  class derivedFieldWriter;
+  class mapPolyMesh;
+  class polyMesh;
+
+  /*---------------------------------------------------------------------------*\
+    Class derivedFields Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class derivedFields
+  {
+    // Private data
+
+    //- Active writers, if any.
+    PtrList<derivedFieldWriter>* const writers_;
+
+    //- Name of this set of derivedFields,
+    word name_;
+
+    const objectRegistry& obr_;
+
+    // Private Member Functions
+
+    //- Add writer to active list.
+    void addWriter(derivedFieldWriter* writer);
+
+    //- Disallow default bitwise copy construct
+    derivedFields(const derivedFields&);
+
+    //- Disallow default bitwise assignment
+    void operator=(const derivedFields&);
+
+  public:
+
+    //- Runtime type information
+    TypeName("derivedFields");
+
+    // Constructors
+
+    //- Construct for given objectRegistry and dictionary.
+    //  Allow the possibility to load fields from files
+    derivedFields
+    (
+     const word& name,
+     const objectRegistry&,
+     const dictionary&,
+     const bool loadFromFiles = false
+     );
+
+    // Destructor
+    virtual ~derivedFields();
+
+    // Member Functions
+
+    //- Return name of the set of derivedFields
+    const word& name() const
+    {
+      return name_;
+    }
+
+    //- Read the derivedFields data
+    void read(const dictionary& dict);
+
+    //- Calculate the derivedFields and write
+    void write();
+
+    //- Satisfy OutputFilterFunctionObject
+    void execute()
+    {}
+
+    //- Satisfy OutputFilterFunctionObject
+    void end()
+    {}
+
+    //- Called when time was set at the end of the Time::operator++
+    bool timeSet()
+    { return true; }
+
+    //- Update for changes of mesh
+    void updateMesh(const mapPolyMesh&)
+    {}
+
+    //- Update for changes of mesh
+    void movePoints(const polyMesh&)
+    {}
+  };
+
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/yPlusWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/yPlusWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,103 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::yPlusWriter
+
+Description
+    Write yPlus field
+
+SourceFiles
+    yPlus.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef yPlusWriter_H
+#define yPlusWriter_H
+
+#include "derivedFieldWriter.H"
+#include "volFields.H"
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class dictionary;
+  class fvMesh;
+
+
+  /*---------------------------------------------------------------------------*\
+    Class yPlusWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class yPlusWriter : public derivedFieldWriter
+  {
+    // Private data
+
+    
+    // Private methods
+
+    //- Extract yPlus from LES models.
+    template<class T_Model>
+    bool 
+    extractedFromLES(char const * const modelProperties,
+                  const fvMesh& mesh,
+                  volScalarField::GeometricBoundaryField& yPlusb);
+
+    //- Extract yPlus from RAS wall function model.
+    template<class T_Model, class T_WallFunctionPatchField>
+    bool 
+    extractedFromRAS(char const * const modelProperties,
+                  const fvMesh& mesh,
+                  volScalarField::GeometricBoundaryField& yPlusb);
+
+    //- Extract yPlus from RAS wall function low-Re model.
+    template<class T_Model>
+    bool 
+    extractedFromRAS(char const * const modelProperties,
+                  const fvMesh& mesh,
+                  volScalarField::GeometricBoundaryField& yPlusb);
+
+  public:
+    //- Runtime type information
+    TypeName("yPlusWriter");
+
+    //- Field file name.
+    static const word FIELD_NAME;
+
+    // Constructors
+
+    yPlusWriter(const dictionary& dict);
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr);
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/wallShearStressWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/wallShearStressWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,231 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "wallShearStressWriter.H"
+#include "volFields.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "wallFvPatch.H"
+
+#include "incompressible/singlePhaseTransportModel/singlePhaseTransportModel.H"
+#include "incompressible/RAS/RASModel/RASModel.H"
+#include "incompressible/LES/LESModel/LESModel.H"
+#include "fluidThermo.H"
+#include "compressible/RAS/RASModel/RASModel.H"
+#include "compressible/LES/LESModel/LESModel.H"
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(wallShearStressWriter, 0);
+  const word wallShearStressWriter::FIELD_NAME("wallShearStress");
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+Foam::tmp<Foam::volSymmTensorField> 
+Foam::wallShearStressWriter::devRhoReff(const objectRegistry& obr, 
+                                        bool & foundField) const
+{
+  if (obr.foundObject<incompressible::RASModel>("RASProperties"))
+    {
+      const incompressible::RASModel& ras
+        = obr.lookupObject<incompressible::RASModel>("RASProperties");
+
+      return rho(obr)*ras.devReff();
+    }
+  else if (obr.foundObject<compressible::RASModel>("RASProperties"))
+    {
+      const compressible::RASModel& ras
+        = obr.lookupObject<compressible::RASModel>("RASProperties");
+
+      return ras.devRhoReff();
+    }
+  else if (obr.foundObject<incompressible::LESModel>("LESProperties"))
+    {
+      const incompressible::LESModel& les
+        = obr.lookupObject<incompressible::LESModel>("LESProperties");
+
+      return rho(obr)*les.devReff();
+    }
+  else if (obr.foundObject<compressible::LESModel>("LESProperties"))
+    {
+      const compressible::LESModel& les =
+        obr.lookupObject<compressible::LESModel>("LESProperties");
+
+      return les.devRhoBeff();
+    }
+  else  if (obr.foundObject<fluidThermo>("thermophysicalProperties"))
+    {
+      const fluidThermo& thermo =
+        obr.lookupObject<fluidThermo>("thermophysicalProperties");
+
+      const volVectorField& U = obr.lookupObject<volVectorField>(UName_);
+
+      return -thermo.mu()*dev(twoSymm(fvc::grad(U)));
+    }
+  else if
+    (
+     obr.foundObject<singlePhaseTransportModel>("transportProperties")
+     )
+    {
+      const singlePhaseTransportModel& laminarT =
+        obr.lookupObject<singlePhaseTransportModel>
+        ("transportProperties");
+
+      const volVectorField& U = obr.lookupObject<volVectorField>(UName_);
+
+      return -rho(obr)*laminarT.nu()*dev(twoSymm(fvc::grad(U)));
+    }
+  else if (obr.foundObject<dictionary>("transportProperties"))
+    {
+      const dictionary& transportProperties =
+        obr.lookupObject<dictionary>("transportProperties");
+
+      dimensionedScalar nu(transportProperties.lookup("nu"));
+
+      const volVectorField& U = obr.lookupObject<volVectorField>(UName_);
+
+      return -rho(obr)*nu*dev(twoSymm(fvc::grad(U)));
+    }
+  else
+    {
+      foundField = false;
+      return volSymmTensorField::null();
+    }
+}
+
+
+Foam::tmp<Foam::volScalarField> 
+Foam::wallShearStressWriter::rho(const objectRegistry& obr) const
+{
+    if (rhoName_ == "rhoInf")
+    {
+        const fvMesh& mesh = refCast<const fvMesh>(obr);
+
+        return tmp<volScalarField>
+        (
+            new volScalarField
+            (
+                IOobject
+                (
+                    "rho",
+                    mesh.time().timeName(),
+                    mesh
+                ),
+                mesh,
+                dimensionedScalar("rho", dimDensity, rhoRef_)
+            )
+        );
+    }
+    else
+    {
+        return(obr.lookupObject<volScalarField>(rhoName_));
+    }
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::wallShearStressWriter::wallShearStressWriter(const dictionary & dict)
+  : derivedFieldWriter(dict),
+    UName_("U"),
+    rhoName_("rho"),
+    rhoRef_(1.)
+{
+  // Optional entry U
+  dict.readIfPresent("UName", UName_);
+
+  // Optional entry U
+  dict.readIfPresent("rhoName", rhoName_);
+
+  // Reference density needed for incompressible calculations
+  dict.readIfPresent("rhoInf", rhoRef_);
+}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::wallShearStressWriter::write(const objectRegistry& obr)
+{
+  const fvMesh& mesh = refCast<const fvMesh>(obr);
+  
+  volVectorField wallShearStress
+    (
+     IOobject
+     (
+      FIELD_NAME,
+      obr.time().timeName(),
+      mesh,
+      IOobject::NO_READ,
+      IOobject::NO_WRITE
+      ),
+     mesh,
+     dimensionedVector
+     (
+      FIELD_NAME,
+      //tdevRhoReff().dimensions() / tmagSf().dimensions(),
+      dimensionSet(0, 2, -2, 0, 0, 0, 0),
+      vector::zero
+      )
+     );
+
+  bool foundField = true;
+  tmp<volSymmTensorField> tdevRhoReff = devRhoReff(obr, foundField);
+
+  if (foundField) {
+    const volSymmTensorField::GeometricBoundaryField& devRhoReffb =
+      tdevRhoReff().boundaryField();
+
+    tmp<surfaceScalarField> tmagSf = mesh.magSf();
+    const surfaceScalarField::GeometricBoundaryField& magSfb =
+      tmagSf().boundaryField();
+
+    volVectorField::GeometricBoundaryField& wShearStressb =
+      wallShearStress.boundaryField();
+    const surfaceVectorField::GeometricBoundaryField& Sfb =
+      mesh.Sf().boundaryField();
+    const fvPatchList& patches = mesh.boundary();
+    
+    forAll(patches, patchi)
+      {
+        const fvPatch& currPatch = patches[patchi];
+        
+        if (isA<wallFvPatch>(currPatch))
+          {
+            vectorField& wssp = wShearStressb[patchi];
+            wssp =
+              (Sfb[patchi]/magSfb[patchi]) & devRhoReffb[patchi];
+            
+            writeStatistics(wssp, currPatch.name(), FIELD_NAME);
+          }
+      }
+  }
+
+  wallShearStress.write();
+}
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFieldWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFieldWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,39 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "derivedFieldWriter.H"
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::derivedFieldWriter::derivedFieldWriter(const dictionary& dict)
+  : statistics_(dict.lookupOrDefault<Switch>("statistics", false))
+{}
+
+
+// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * //
+
+Foam::derivedFieldWriter::~derivedFieldWriter()
+{}
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/wallShearStressWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/wallShearStressWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,97 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::wallShearStressWriter
+
+Description
+    Write wallShearStress field
+
+SourceFiles
+    wallShearStress.C
+
+\*---------------------------------------------------------------------------*/
+
+#ifndef wallShearStressWriter_H
+#define wallShearStressWriter_H
+
+#include "derivedFieldWriter.H"
+#include "volFieldsFwd.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  class dictionary;
+
+
+  /*---------------------------------------------------------------------------*\
+    Class wallShearStressWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class wallShearStressWriter : public derivedFieldWriter
+  {
+    // Private data
+
+    //- Name of velocity field
+    word UName_;
+            
+    //- Name of density field (optional)
+    word rhoName_;
+
+    //- Reference density needed for incompressible calculations
+    scalar rhoRef_;
+    
+    // Private methods
+
+    //- Return the effective viscous stress (laminar + turbulent).
+    tmp<volSymmTensorField> devRhoReff(const objectRegistry& obr, 
+                                       bool & foundField) const;
+
+    //- Return rho field if it exists or rhoRef_ for incompressible rho
+    tmp<Foam::volScalarField> rho(const objectRegistry& obr) const;
+
+  public:
+    //- Runtime type information
+    TypeName("wallShearStressWriter");
+
+    //- Field file name.
+    static const word FIELD_NAME;
+
+    // Constructors
+
+    wallShearStressWriter(const dictionary& dict);
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr);
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/derivedFieldWriter.H	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/derivedFieldWriter.H	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,115 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+Class
+    Foam::derivedFieldWriter
+
+Description
+    Basis for writers used in derivedFields e.g., wallShearStressWriter
+
+    \*---------------------------------------------------------------------------*/
+
+#ifndef derivedFieldWriter_H
+#define derivedFieldWriter_H
+
+#include "dictionary.H"
+#include "entry.H"
+#include "Switch.H"
+#include "Pstream.H"
+
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+namespace Foam
+{
+
+  // Forward declaration of classes
+  class objectRegistry;
+
+  /*---------------------------------------------------------------------------*\
+    Class derivedFieldWriter Declaration
+  \*---------------------------------------------------------------------------*/
+
+  class derivedFieldWriter
+  {
+    // Private data
+  
+    //- Produce statistics
+    Switch statistics_;
+
+  public:
+    // Destructor
+
+    virtual ~derivedFieldWriter();
+
+    // Member Functions
+
+    //- Write derived field.
+    virtual void write(const objectRegistry& obr) = 0;
+
+    //- Create obj if requested.
+    template<class T>
+    static T* read(const dictionary& dict)
+    {
+      const bool nonRecursive = false;
+      const bool noPatternMatch = false;
+      T* obj = 0;
+      const entry* entry = 
+        dict.lookupEntryPtr(T::FIELD_NAME, nonRecursive, noPatternMatch);
+    
+      if (0 != entry) 
+        {
+          obj = new T(entry->dict());
+        }
+
+      return obj;
+    }
+
+  protected:
+    // Constructors
+
+    derivedFieldWriter(const dictionary& dict);
+
+    //- Write min/max/average
+    template<class T_Field>
+    void writeStatistics(const T_Field& fieldp,
+                         const word& patchName,
+                         const word& fieldName)
+    {
+      if (statistics_ && Pstream::master()) 
+        {   
+            Info<< "Patch: " << patchName
+                << ", Field: " << fieldName
+                << ", min: " << min(fieldp) 
+                << ", max: " << max(fieldp)
+                << ", average: " << average(fieldp) << nl << endl;
+        }
+    }
+  };
+
+  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+} // End namespace Foam
+
+// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
+
+#endif
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/vorticityWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/vorticityWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,69 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2011 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "vorticityWriter.H"
+#include "volFields.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "fvc.H"
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(vorticityWriter, 0);
+  const word vorticityWriter::FIELD_NAME("vorticity");
+}
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::vorticityWriter::vorticityWriter(const dictionary & dict)
+  : derivedFieldWriter(dict)
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::vorticityWriter::write(const objectRegistry& obr)
+{
+  const fvMesh& mesh = refCast<const fvMesh>(obr);
+  const Time& runTime = obr.time();
+  const volVectorField& U = obr.lookupObject<volVectorField>("U");
+
+  volVectorField vorticity
+    (
+     IOobject
+     (
+      FIELD_NAME,
+      runTime.timeName(),
+      mesh,
+      IOobject::NO_READ
+      ),
+     fvc::curl(U)
+     );
+  
+  vorticity.write();
+}
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/derivedFields/Make/files	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/Make/files	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,10 @@
+derivedFields.C
+derivedFieldsFunctionObject.C
+derivedFieldWriter.C
+machWriter.C
+vorticityWriter.C
+wallHeatFluxWriter.C
+wallShearStressWriter.C
+yPlusWriter.C
+
+LIB = $(FOAM_LIBBIN)/libderivedFields
--- src/postProcessing/functionObjects/derivedFields/Make/options	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,23 @@
+EXE_INC = \
+    -I$(LIB_SRC)/finiteVolume/lnInclude \
+    -I$(LIB_SRC)/meshTools/lnInclude \
+    -I$(LIB_SRC)/sampling/lnInclude \
+    -I$(LIB_SRC)/turbulenceModels/incompressible/RAS/derivedFvPatchFields/wallFunctions/nutWallFunctions \
+    -I$(LIB_SRC)/turbulenceModels/compressible/RAS/derivedFvPatchFields/wallFunctions/mutWallFunctions \
+    -I$(LIB_SRC)/turbulenceModels/incompressible/RAS/derivedFvPatchFields/wallFunctions/nutWallFunctions/nutWallFunction \
+    -I$(LIB_SRC)/turbulenceModels/compressible/RAS/derivedFvPatchFields/wallFunctions/mutWallFunctions/mutWallFunction \
+    -I$(LIB_SRC)/transportModels \
+    -I$(LIB_SRC)/turbulenceModels \
+    -I$(LIB_SRC)/turbulenceModels/LES/LESdeltas/lnInclude \
+    -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude
+
+LIB_LIBS = \
+    -lfiniteVolume \
+    -lmeshTools \
+    -lincompressibleTransportModels \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
+    -lfluidThermophysicalModels \
+    -lspecie \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad
--- src/postProcessing/functionObjects/derivedFields/wallHeatFluxWriter.C	(.../tags/2.2.x-2)	(revision 0)
+++ src/postProcessing/functionObjects/derivedFields/wallHeatFluxWriter.C	(.../branches/2.2.x-2)	(revision 831)
@@ -0,0 +1,144 @@
+/*---------------------------------------------------------------------------*\
+    Copyright            : (C) 2012 Symscape
+    Website              : www.symscape.com
+-------------------------------------------------------------------------------
+License
+    This file is part of OpenFOAM.
+
+    OpenFOAM is free software: you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
+
+\*---------------------------------------------------------------------------*/
+
+#include "wallHeatFluxWriter.H"
+#include "volFields.H"
+#include "dictionary.H"
+#include "Time.H"
+#include "wallFvPatch.H"
+
+#include "incompressible/RAS/RASModel/RASModel.H"
+#include "compressible/RAS/RASModel/RASModel.H"
+
+
+// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
+
+namespace Foam
+{
+  defineTypeNameAndDebug(wallHeatFluxWriter, 0);
+  const word wallHeatFluxWriter::FIELD_NAME("wallHeatFlux");
+}
+
+
+// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
+
+Foam::tmp<Foam::volScalarField> 
+Foam::wallHeatFluxWriter::htc(const objectRegistry& obr,
+			      bool & foundField) const
+{
+  if (obr.foundObject<incompressible::RASModel>("RASProperties"))
+    {
+      const incompressible::RASModel& ras
+        = obr.lookupObject<incompressible::RASModel>("RASProperties");
+      dimensionedScalar Pr(ras.transport().lookup("Pr"));
+      dimensionedScalar Cp0(ras.transport().lookup("Cp"));
+
+      return Cp0 * (ras.nu()/Pr + obr.lookupObject<volScalarField>("alphat"));
+    }
+  else if (obr.foundObject<compressible::RASModel>("RASProperties"))
+    {
+      const compressible::RASModel& ras
+        = obr.lookupObject<compressible::RASModel>("RASProperties");
+
+      return ras.thermo().Cp() * ras.alphaEff();
+    }
+  else
+    {
+      foundField = false;
+      return volScalarField::null();
+    }
+}
+
+
+
+// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
+
+Foam::wallHeatFluxWriter::wallHeatFluxWriter(const dictionary & dict)
+  : derivedFieldWriter(dict)
+{}
+
+
+// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
+
+void Foam::wallHeatFluxWriter::write(const objectRegistry& obr)
+{
+  const fvMesh& mesh = refCast<const fvMesh>(obr);
+
+  bool foundField = true;
+  word hName;
+  tmp<volScalarField> thtc = htc(obr, foundField);
+
+
+  volScalarField wallHeatFlux
+    (
+     IOobject
+     (
+      FIELD_NAME,
+      obr.time().timeName(),
+      mesh,
+      IOobject::NO_READ,
+      IOobject::NO_WRITE
+      ),
+     mesh,
+     dimensionedScalar
+     (
+      FIELD_NAME,
+      dimensionSet(1, 0, -3, 0, 0, 0, 0), // W.m-2
+      0.
+      )
+     );
+
+
+  if (foundField) {
+    const volScalarField & T = obr.lookupObject<volScalarField>("T");
+
+    surfaceScalarField heatFlux
+      (
+       fvc::interpolate(thtc())*fvc::snGrad(T)
+       );
+
+    const surfaceScalarField::GeometricBoundaryField& patchHeatFlux =
+      heatFlux.boundaryField();
+
+    const fvPatchList& patches = mesh.boundary();
+	    
+    volScalarField::GeometricBoundaryField & wHeatFluxb =
+      wallHeatFlux.boundaryField();
+    
+    forAll(patches, patchi)
+      {
+        const fvPatch& currPatch = patches[patchi];
+        
+        if (isA<wallFvPatch>(currPatch))
+          {	    
+	    scalarField & whfp = wHeatFluxb[patchi];
+	    whfp = patchHeatFlux[patchi];
+	    writeStatistics(whfp, currPatch.name(), FIELD_NAME);
+	  }
+      }
+  }
+
+  wallHeatFlux.write();
+ }
+
+
+// ************************************************************************* //
--- src/postProcessing/functionObjects/utilities/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/postProcessing/functionObjects/utilities/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -20,8 +20,10 @@
     -llagrangian \
     -ldsmc \
     -lincompressibleTransportModels \
-    -lcompressibleRASModels \
-    -lincompressibleRASModels \
-    -lcompressibleLESModels \
-    -lincompressibleLESModels \
+    -lcompressibleTurbulenceModel \
+    -lincompressibleTurbulenceModel \
+    -lcompressibleRASModels -u compressibleRASModelsLoad \
+    -lincompressibleRASModels -u incompressibleRASModelsLoad \
+    -lcompressibleLESModels -u compressibleLESModelsLoad \
+    -lincompressibleLESModels -u incompressibleLESModelsLoad \
     -lfluidThermophysicalModels
--- src/postProcessing/functionObjects/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/postProcessing/functionObjects/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -11,5 +11,6 @@
 wmake $makeType jobControl
 wmake $makeType systemCall
 wmake $makeType utilities
+wmake $makeType derivedFields
 
 # ----------------------------------------------------------------- end-of-file
--- src/postProcessing/postCalc/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/postProcessing/postCalc/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -2,4 +2,5 @@
     -I$(LIB_SRC)/finiteVolume/lnInclude
 
 LIB_LIBS = \
+    -lgenericPatchFields -u genericPatchFieldsLoad \
     -lfiniteVolume
--- src/fvOptions/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/fvOptions/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -14,4 +14,5 @@
     -lsampling \
     -lmeshTools \
     /*-lsolidThermo*/ \
+    -lfluidThermophysicalModels \
     -lcompressibleTurbulenceModel
--- src/parallel/decompose/scotchDecomp/scotchDecomp.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/parallel/decompose/scotchDecomp/scotchDecomp.C	(.../branches/2.2.x-2)	(revision 831)
@@ -127,7 +127,13 @@
 #include "globalIndex.H"
 #include "SubField.H"
 
+// Symbol to force loading at runtime
 extern "C"
+void scotchDecompLoad()
+{}
+
+
+extern "C"
 {
 #include "scotch.h"
 }
--- src/parallel/decompose/scotchDecomp/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/parallel/decompose/scotchDecomp/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -7,10 +7,9 @@
 
 EXE_INC = \
     $(PFLAGS) $(PINC) \
-    -I$(SCOTCH_ROOT)/include \
-    -I$(SCOTCH_ARCH_PATH)/include \
-    -I/usr/include/scotch \
+    -I$(WM_THIRD_PARTY_DIR)/scotch/src/libscotch \
     -I../decompositionMethods/lnInclude
 
 LIB_LIBS = \
-    -L$(SCOTCH_ROOT)/lib -L$(FOAM_EXT_LIBBIN) -lscotch -lscotcherrexit -lrt
+    -ldecompositionMethods \
+    -L$(FOAM_EXT_LIBBIN) -lscotch
--- src/parallel/decompose/Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ src/parallel/decompose/Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -1,6 +1,7 @@
 #!/bin/sh
 cd ${0%/*} || exit 1    # run from this directory
 makeType=${1:-libso}
+set -e
 
 # get SCOTCH_VERSION, SCOTCH_ARCH_PATH
 if settings=`$WM_PROJECT_DIR/bin/foamEtcFile config/scotch.sh`
@@ -41,11 +42,13 @@
 
 wmakeLnInclude decompositionMethods
 
+wmake $makeType decompositionMethods
+
 if [ -n "$SCOTCH_ARCH_PATH" ]
 then
     wmake $makeType scotchDecomp
 
-    if [ -d "$FOAM_LIBBIN/$FOAM_MPI" ]
+    if [ "" = "SKIP" -a -d "$FOAM_LIBBIN/$FOAM_MPI" ]
     then
         #- Bit of a hack: ptscotch 6 requires scotch linked as well as. Can be
         #  removed once ptscotch declares dependency on scotch itself.
@@ -62,8 +65,6 @@
     echo
 fi
 
-wmake $makeType decompositionMethods
-
 wmake $makeType decompose
 
 # ----------------------------------------------------------------- end-of-file
--- src/transportModels/twoPhaseProperties/alphaContactAngle/alphaContactAngle/alphaContactAngleFvPatchScalarField.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/transportModels/twoPhaseProperties/alphaContactAngle/alphaContactAngle/alphaContactAngleFvPatchScalarField.C	(.../branches/2.2.x-2)	(revision 831)
@@ -30,6 +30,12 @@
 
 // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void twoPhasePropertiesLoad()
+{}
+
+
 namespace Foam
 {
     defineTypeNameAndDebug(alphaContactAngleFvPatchScalarField, 0);
--- src/transportModels/interfaceProperties/interfaceProperties.C	(.../tags/2.2.x-2)	(revision 831)
+++ src/transportModels/interfaceProperties/interfaceProperties.C	(.../branches/2.2.x-2)	(revision 831)
@@ -33,10 +33,15 @@
 
 // * * * * * * * * * * * * * * * Static Member Data  * * * * * * * * * * * * //
 
+// Symbol to force loading at runtime
+extern "C"
+void interfacePropertiesLoad()
+{}
+
+
 const Foam::scalar Foam::interfaceProperties::convertToRad =
     Foam::constant::mathematical::pi/180.0;
 
-
 // * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //
 
 // Correction for the boundary condition on the unit normal nHat on
--- src/triSurface/Make/options	(.../tags/2.2.x-2)	(revision 831)
+++ src/triSurface/Make/options	(.../branches/2.2.x-2)	(revision 831)
@@ -4,4 +4,5 @@
 
 LIB_LIBS = \
     -lfileFormats \
-    -lsurfMesh
+    -lsurfMesh \
+    -lz
--- etc/bashrc	(.../tags/2.2.x-2)	(revision 831)
+++ etc/bashrc	(.../branches/2.2.x-2)	(revision 831)
@@ -79,12 +79,15 @@
 export WM_COMPILE_OPTION=Opt
 
 #- MPI implementation:
-#    WM_MPLIB = SYSTEMOPENMPI | OPENMPI | MPICH | MPICH-GM | HPMPI
-#               | GAMMA | MPI | QSMPI | SGIMPI
+#    WM_MPLIB = NONE | SYSTEMOPENMPI | OPENMPI | MPICH | MPICH-GM | HPMPI
+#               | GAMMA | MPI | QSMPI | SGIMPI | MSMPI
 export WM_MPLIB=OPENMPI
 
+# WM_GPU = NONE | CUDA
+export WM_GPU=NONE
+
 #- Operating System:
-#    WM_OSTYPE = POSIX | ???
+#    WM_OSTYPE = POSIX | MSwindows
 export WM_OSTYPE=POSIX
 
 #- Floating-point signal handling:
--- etc/controlDict	(.../tags/2.2.x-2)	(revision 831)
+++ etc/controlDict	(.../branches/2.2.x-2)	(revision 831)
@@ -220,7 +220,7 @@
     NonlinearKEShih     0;
     ODE                 0;
     ODESolver           0;
-    OFstream            0;
+    OFstream            1;
     ORourke             0;
     OSPRE               0;
     OSPREV              0;
@@ -891,7 +891,7 @@
     waveTransmissive    0;
     wedge               0;
     weighted            0;
-    word                2;
+    word                0;
     writer              0;
     xmgr                0;
     zeroGradient        0;
--- etc/config/settings.sh	(.../tags/2.2.x-2)	(revision 831)
+++ etc/config/settings.sh	(.../branches/2.2.x-2)	(revision 831)
@@ -151,6 +151,10 @@
     export WM_LDFLAGS='-mabi=64 -G0'
     ;;
 
+Darwin)
+    WM_ARCH=darwin
+    ;;
+
 *)    # an unsupported operating system
     /bin/cat <<USAGE 1>&2
 
@@ -395,7 +399,7 @@
 # Communications library
 # ~~~~~~~~~~~~~~~~~~~~~~
 
-unset MPI_ARCH_PATH MPI_HOME FOAM_MPI_LIBBIN
+unset MPI_HOME FOAM_MPI_LIBBIN
 
 case "$WM_MPLIB" in
 SYSTEMOPENMPI)
@@ -417,7 +421,7 @@
     # optional configuration tweaks:
     _foamSource `$WM_PROJECT_DIR/bin/foamEtcFile config/openmpi.sh`
 
-    export MPI_ARCH_PATH=$WM_THIRD_PARTY_DIR/platforms/$WM_ARCH$WM_COMPILER/$FOAM_MPI
+    : ${MPI_ARCH_PATH:=$WM_THIRD_PARTY_DIR/platforms/$WM_ARCH$WM_COMPILER/$FOAM_MPI}; export MPI_ARCH_PATH
 
     # Tell OpenMPI where to find its install directory
     export OPAL_PREFIX=$MPI_ARCH_PATH
@@ -563,6 +567,12 @@
     _foamAddPath    $MPI_ARCH_PATH/bin64
     _foamAddLib     $MPI_ARCH_PATH/lib64
     ;;
+
+MSMPI)
+    export FOAM_MPI=msmpi
+    : ${MPI_ARCH_PATH:=$HOME/projects/msmpi/install}; export MPI_ARCH_PATH
+    ;;
+
 *)
     export FOAM_MPI=dummy
     ;;
@@ -588,6 +598,26 @@
 export MPI_BUFFER_SIZE
 
 
+
+# GPU library
+# ~~~~~~~~~~~~~~~~~~~~~~
+
+
+case "$WM_GPU" in
+CUDA)
+    : ${CUDA_ARCH_PATH:=$HOME/projects/ofgpu}; export CUDA_ARCH_PATH
+    export FOAM_GPU_LIBBIN=$FOAM_LIBBIN/cuda
+    _foamAddLib     /usr/local/cuda/lib64
+    _foamAddLib     ${CUDA_ARCH_PATH}/install/lib
+    ;;
+*)
+    export FOAM_GPU_LIBBIN=$FOAM_LIBBIN/gpuless
+    ;;
+esac
+
+_foamAddLib $FOAM_GPU_LIBBIN
+
+
 # cleanup environment:
 # ~~~~~~~~~~~~~~~~~~~~
 unset _foamAddPath _foamAddLib _foamAddMan foamCompiler minBufferSize
--- Allwmake	(.../tags/2.2.x-2)	(revision 831)
+++ Allwmake	(.../branches/2.2.x-2)	(revision 831)
@@ -18,7 +18,8 @@
 ( cd wmake/src && make )
 
 # build ThirdParty sources
-if [ -d "$WM_THIRD_PARTY_DIR" ]
+#if [ -d "$WM_THIRD_PARTY_DIR" ]
+if [ 1 -eq 0 ]
 then
     $WM_THIRD_PARTY_DIR/Allwmake
 else
